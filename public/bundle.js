/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(7);
var isBuffer = __webpack_require__(24);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object' && !isArray(obj)) {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge() /* obj1, obj2, obj3, ... */{
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate
    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 3 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(0);
var normalizeHeaderName = __webpack_require__(26);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(8);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(8);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {/* Ignore */}
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(57)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 6 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(0);
var settle = __webpack_require__(27);
var buildURL = __webpack_require__(29);
var parseHeaders = __webpack_require__(30);
var isURLSameOrigin = __webpack_require__(31);
var createError = __webpack_require__(9);
var btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(32);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || request.readyState !== 4 && !xDomain) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(33);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(28);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Vue-awesome-swiper
 * @author Surmon.me
 */

var Swiper = __webpack_require__(13);
var SwiperComponent = __webpack_require__(41);
var SlideComponent = __webpack_require__(47);
SwiperComponent = SwiperComponent.default || SwiperComponent;
SlideComponent = SlideComponent.default || SlideComponent;
if (typeof window !== 'undefined') {
  window.Swiper = Swiper;
}

var swiper = {
  swiperSlide: SlideComponent,
  swiper: SwiperComponent,
  swiperPlugins: Swiper.prototype.plugins,
  install: function (Vue) {
    Vue.component(SwiperComponent.name, SwiperComponent);
    Vue.component(SlideComponent.name, SlideComponent);
  }
};

module.exports = swiper;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Swiper 3.4.2
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * 
 * http://www.idangero.us/swiper/
 * 
 * Copyright 2017, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 * 
 * Licensed under MIT
 * 
 * Released on: March 10, 2017
 */
(function () {
    'use strict';

    var $;

    /*===========================
    Swiper
    ===========================*/
    var Swiper = function (container, params) {
        if (!(this instanceof Swiper)) return new Swiper(container, params);

        var defaults = {
            direction: 'horizontal',
            touchEventsTarget: 'container',
            initialSlide: 0,
            speed: 300,
            // autoplay
            autoplay: false,
            autoplayDisableOnInteraction: true,
            autoplayStopOnLast: false,
            // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
            iOSEdgeSwipeDetection: false,
            iOSEdgeSwipeThreshold: 20,
            // Free mode
            freeMode: false,
            freeModeMomentum: true,
            freeModeMomentumRatio: 1,
            freeModeMomentumBounce: true,
            freeModeMomentumBounceRatio: 1,
            freeModeMomentumVelocityRatio: 1,
            freeModeSticky: false,
            freeModeMinimumVelocity: 0.02,
            // Autoheight
            autoHeight: false,
            // Set wrapper width
            setWrapperSize: false,
            // Virtual Translate
            virtualTranslate: false,
            // Effects
            effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
            coverflow: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                modifier: 1,
                slideShadows: true
            },
            flip: {
                slideShadows: true,
                limitRotation: true
            },
            cube: {
                slideShadows: true,
                shadow: true,
                shadowOffset: 20,
                shadowScale: 0.94
            },
            fade: {
                crossFade: false
            },
            // Parallax
            parallax: false,
            // Zoom
            zoom: false,
            zoomMax: 3,
            zoomMin: 1,
            zoomToggle: true,
            // Scrollbar
            scrollbar: null,
            scrollbarHide: true,
            scrollbarDraggable: false,
            scrollbarSnapOnRelease: false,
            // Keyboard Mousewheel
            keyboardControl: false,
            mousewheelControl: false,
            mousewheelReleaseOnEdges: false,
            mousewheelInvert: false,
            mousewheelForceToAxis: false,
            mousewheelSensitivity: 1,
            mousewheelEventsTarged: 'container',
            // Hash Navigation
            hashnav: false,
            hashnavWatchState: false,
            // History
            history: false,
            // Commong Nav State
            replaceState: false,
            // Breakpoints
            breakpoints: undefined,
            // Slides grid
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerColumn: 1,
            slidesPerColumnFill: 'column',
            slidesPerGroup: 1,
            centeredSlides: false,
            slidesOffsetBefore: 0, // in px
            slidesOffsetAfter: 0, // in px
            // Round length
            roundLengths: false,
            // Touches
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: 0.5,
            longSwipesMs: 300,
            followFinger: true,
            onlyExternal: false,
            threshold: 0,
            touchMoveStopPropagation: true,
            touchReleaseOnEdges: false,
            // Unique Navigation Elements
            uniqueNavElements: true,
            // Pagination
            pagination: null,
            paginationElement: 'span',
            paginationClickable: false,
            paginationHide: false,
            paginationBulletRender: null,
            paginationProgressRender: null,
            paginationFractionRender: null,
            paginationCustomRender: null,
            paginationType: 'bullets', // 'bullets' or 'progress' or 'fraction' or 'custom'
            // Resistance
            resistance: true,
            resistanceRatio: 0.85,
            // Next/prev buttons
            nextButton: null,
            prevButton: null,
            // Progress
            watchSlidesProgress: false,
            watchSlidesVisibility: false,
            // Cursor
            grabCursor: false,
            // Clicks
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            // Lazy Loading
            lazyLoading: false,
            lazyLoadingInPrevNext: false,
            lazyLoadingInPrevNextAmount: 1,
            lazyLoadingOnTransitionStart: false,
            // Images
            preloadImages: true,
            updateOnImagesReady: true,
            // loop
            loop: false,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            // Control
            control: undefined,
            controlInverse: false,
            controlBy: 'slide', //or 'container'
            normalizeSlideIndex: true,
            // Swiping/no swiping
            allowSwipeToPrev: true,
            allowSwipeToNext: true,
            swipeHandler: null, //'.swipe-handler',
            noSwiping: true,
            noSwipingClass: 'swiper-no-swiping',
            // Passive Listeners
            passiveListeners: true,
            // NS
            containerModifierClass: 'swiper-container-', // NEW
            slideClass: 'swiper-slide',
            slideActiveClass: 'swiper-slide-active',
            slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
            slideVisibleClass: 'swiper-slide-visible',
            slideDuplicateClass: 'swiper-slide-duplicate',
            slideNextClass: 'swiper-slide-next',
            slideDuplicateNextClass: 'swiper-slide-duplicate-next',
            slidePrevClass: 'swiper-slide-prev',
            slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
            wrapperClass: 'swiper-wrapper',
            bulletClass: 'swiper-pagination-bullet',
            bulletActiveClass: 'swiper-pagination-bullet-active',
            buttonDisabledClass: 'swiper-button-disabled',
            paginationCurrentClass: 'swiper-pagination-current',
            paginationTotalClass: 'swiper-pagination-total',
            paginationHiddenClass: 'swiper-pagination-hidden',
            paginationProgressbarClass: 'swiper-pagination-progressbar',
            paginationClickableClass: 'swiper-pagination-clickable', // NEW
            paginationModifierClass: 'swiper-pagination-', // NEW
            lazyLoadingClass: 'swiper-lazy',
            lazyStatusLoadingClass: 'swiper-lazy-loading',
            lazyStatusLoadedClass: 'swiper-lazy-loaded',
            lazyPreloaderClass: 'swiper-lazy-preloader',
            notificationClass: 'swiper-notification',
            preloaderClass: 'preloader',
            zoomContainerClass: 'swiper-zoom-container',

            // Observer
            observer: false,
            observeParents: false,
            // Accessibility
            a11y: false,
            prevSlideMessage: 'Previous slide',
            nextSlideMessage: 'Next slide',
            firstSlideMessage: 'This is the first slide',
            lastSlideMessage: 'This is the last slide',
            paginationBulletMessage: 'Go to slide {{index}}',
            // Callbacks
            runCallbacksOnInit: true
            /*
            Callbacks:
            onInit: function (swiper)
            onDestroy: function (swiper)
            onBeforeResize: function (swiper)
            onAfterResize: function (swiper)
            onClick: function (swiper, e)
            onTap: function (swiper, e)
            onDoubleTap: function (swiper, e)
            onSliderMove: function (swiper, e)
            onSlideChangeStart: function (swiper)
            onSlideChangeEnd: function (swiper)
            onTransitionStart: function (swiper)
            onTransitionEnd: function (swiper)
            onImagesReady: function (swiper)
            onProgress: function (swiper, progress)
            onTouchStart: function (swiper, e)
            onTouchMove: function (swiper, e)
            onTouchMoveOpposite: function (swiper, e)
            onTouchEnd: function (swiper, e)
            onReachBeginning: function (swiper)
            onReachEnd: function (swiper)
            onSetTransition: function (swiper, duration)
            onSetTranslate: function (swiper, translate)
            onAutoplayStart: function (swiper)
            onAutoplayStop: function (swiper),
            onLazyImageLoad: function (swiper, slide, image)
            onLazyImageReady: function (swiper, slide, image)
            onKeyPress: function (swiper, keyCode)
            */

        };
        var initialVirtualTranslate = params && params.virtualTranslate;

        params = params || {};
        var originalParams = {};
        for (var param in params) {
            if (typeof params[param] === 'object' && params[param] !== null && !(params[param].nodeType || params[param] === window || params[param] === document || typeof Dom7 !== 'undefined' && params[param] instanceof Dom7 || typeof jQuery !== 'undefined' && params[param] instanceof jQuery)) {
                originalParams[param] = {};
                for (var deepParam in params[param]) {
                    originalParams[param][deepParam] = params[param][deepParam];
                }
            } else {
                originalParams[param] = params[param];
            }
        }
        for (var def in defaults) {
            if (typeof params[def] === 'undefined') {
                params[def] = defaults[def];
            } else if (typeof params[def] === 'object') {
                for (var deepDef in defaults[def]) {
                    if (typeof params[def][deepDef] === 'undefined') {
                        params[def][deepDef] = defaults[def][deepDef];
                    }
                }
            }
        }

        // Swiper
        var s = this;

        // Params
        s.params = params;
        s.originalParams = originalParams;

        // Classname
        s.classNames = [];
        /*=========================
          Dom Library and plugins
          ===========================*/
        if (typeof $ !== 'undefined' && typeof Dom7 !== 'undefined') {
            $ = Dom7;
        }
        if (typeof $ === 'undefined') {
            if (typeof Dom7 === 'undefined') {
                $ = window.Dom7 || window.Zepto || window.jQuery;
            } else {
                $ = Dom7;
            }
            if (!$) return;
        }
        // Export it to Swiper instance
        s.$ = $;

        /*=========================
          Breakpoints
          ===========================*/
        s.currentBreakpoint = undefined;
        s.getActiveBreakpoint = function () {
            //Get breakpoint for window width
            if (!s.params.breakpoints) return false;
            var breakpoint = false;
            var points = [],
                point;
            for (point in s.params.breakpoints) {
                if (s.params.breakpoints.hasOwnProperty(point)) {
                    points.push(point);
                }
            }
            points.sort(function (a, b) {
                return parseInt(a, 10) > parseInt(b, 10);
            });
            for (var i = 0; i < points.length; i++) {
                point = points[i];
                if (point >= window.innerWidth && !breakpoint) {
                    breakpoint = point;
                }
            }
            return breakpoint || 'max';
        };
        s.setBreakpoint = function () {
            //Set breakpoint for window width and update parameters
            var breakpoint = s.getActiveBreakpoint();
            if (breakpoint && s.currentBreakpoint !== breakpoint) {
                var breakPointsParams = breakpoint in s.params.breakpoints ? s.params.breakpoints[breakpoint] : s.originalParams;
                var needsReLoop = s.params.loop && breakPointsParams.slidesPerView !== s.params.slidesPerView;
                for (var param in breakPointsParams) {
                    s.params[param] = breakPointsParams[param];
                }
                s.currentBreakpoint = breakpoint;
                if (needsReLoop && s.destroyLoop) {
                    s.reLoop(true);
                }
            }
        };
        // Set breakpoint on load
        if (s.params.breakpoints) {
            s.setBreakpoint();
        }

        /*=========================
          Preparation - Define Container, Wrapper and Pagination
          ===========================*/
        s.container = $(container);
        if (s.container.length === 0) return;
        if (s.container.length > 1) {
            var swipers = [];
            s.container.each(function () {
                var container = this;
                swipers.push(new Swiper(this, params));
            });
            return swipers;
        }

        // Save instance in container HTML Element and in data
        s.container[0].swiper = s;
        s.container.data('swiper', s);

        s.classNames.push(s.params.containerModifierClass + s.params.direction);

        if (s.params.freeMode) {
            s.classNames.push(s.params.containerModifierClass + 'free-mode');
        }
        if (!s.support.flexbox) {
            s.classNames.push(s.params.containerModifierClass + 'no-flexbox');
            s.params.slidesPerColumn = 1;
        }
        if (s.params.autoHeight) {
            s.classNames.push(s.params.containerModifierClass + 'autoheight');
        }
        // Enable slides progress when required
        if (s.params.parallax || s.params.watchSlidesVisibility) {
            s.params.watchSlidesProgress = true;
        }
        // Max resistance when touchReleaseOnEdges
        if (s.params.touchReleaseOnEdges) {
            s.params.resistanceRatio = 0;
        }
        // Coverflow / 3D
        if (['cube', 'coverflow', 'flip'].indexOf(s.params.effect) >= 0) {
            if (s.support.transforms3d) {
                s.params.watchSlidesProgress = true;
                s.classNames.push(s.params.containerModifierClass + '3d');
            } else {
                s.params.effect = 'slide';
            }
        }
        if (s.params.effect !== 'slide') {
            s.classNames.push(s.params.containerModifierClass + s.params.effect);
        }
        if (s.params.effect === 'cube') {
            s.params.resistanceRatio = 0;
            s.params.slidesPerView = 1;
            s.params.slidesPerColumn = 1;
            s.params.slidesPerGroup = 1;
            s.params.centeredSlides = false;
            s.params.spaceBetween = 0;
            s.params.virtualTranslate = true;
        }
        if (s.params.effect === 'fade' || s.params.effect === 'flip') {
            s.params.slidesPerView = 1;
            s.params.slidesPerColumn = 1;
            s.params.slidesPerGroup = 1;
            s.params.watchSlidesProgress = true;
            s.params.spaceBetween = 0;
            if (typeof initialVirtualTranslate === 'undefined') {
                s.params.virtualTranslate = true;
            }
        }

        // Grab Cursor
        if (s.params.grabCursor && s.support.touch) {
            s.params.grabCursor = false;
        }

        // Wrapper
        s.wrapper = s.container.children('.' + s.params.wrapperClass);

        // Pagination
        if (s.params.pagination) {
            s.paginationContainer = $(s.params.pagination);
            if (s.params.uniqueNavElements && typeof s.params.pagination === 'string' && s.paginationContainer.length > 1 && s.container.find(s.params.pagination).length === 1) {
                s.paginationContainer = s.container.find(s.params.pagination);
            }

            if (s.params.paginationType === 'bullets' && s.params.paginationClickable) {
                s.paginationContainer.addClass(s.params.paginationModifierClass + 'clickable');
            } else {
                s.params.paginationClickable = false;
            }
            s.paginationContainer.addClass(s.params.paginationModifierClass + s.params.paginationType);
        }
        // Next/Prev Buttons
        if (s.params.nextButton || s.params.prevButton) {
            if (s.params.nextButton) {
                s.nextButton = $(s.params.nextButton);
                if (s.params.uniqueNavElements && typeof s.params.nextButton === 'string' && s.nextButton.length > 1 && s.container.find(s.params.nextButton).length === 1) {
                    s.nextButton = s.container.find(s.params.nextButton);
                }
            }
            if (s.params.prevButton) {
                s.prevButton = $(s.params.prevButton);
                if (s.params.uniqueNavElements && typeof s.params.prevButton === 'string' && s.prevButton.length > 1 && s.container.find(s.params.prevButton).length === 1) {
                    s.prevButton = s.container.find(s.params.prevButton);
                }
            }
        }

        // Is Horizontal
        s.isHorizontal = function () {
            return s.params.direction === 'horizontal';
        };
        // s.isH = isH;

        // RTL
        s.rtl = s.isHorizontal() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');
        if (s.rtl) {
            s.classNames.push(s.params.containerModifierClass + 'rtl');
        }

        // Wrong RTL support
        if (s.rtl) {
            s.wrongRTL = s.wrapper.css('display') === '-webkit-box';
        }

        // Columns
        if (s.params.slidesPerColumn > 1) {
            s.classNames.push(s.params.containerModifierClass + 'multirow');
        }

        // Check for Android
        if (s.device.android) {
            s.classNames.push(s.params.containerModifierClass + 'android');
        }

        // Add classes
        s.container.addClass(s.classNames.join(' '));

        // Translate
        s.translate = 0;

        // Progress
        s.progress = 0;

        // Velocity
        s.velocity = 0;

        /*=========================
          Locks, unlocks
          ===========================*/
        s.lockSwipeToNext = function () {
            s.params.allowSwipeToNext = false;
            if (s.params.allowSwipeToPrev === false && s.params.grabCursor) {
                s.unsetGrabCursor();
            }
        };
        s.lockSwipeToPrev = function () {
            s.params.allowSwipeToPrev = false;
            if (s.params.allowSwipeToNext === false && s.params.grabCursor) {
                s.unsetGrabCursor();
            }
        };
        s.lockSwipes = function () {
            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;
            if (s.params.grabCursor) s.unsetGrabCursor();
        };
        s.unlockSwipeToNext = function () {
            s.params.allowSwipeToNext = true;
            if (s.params.allowSwipeToPrev === true && s.params.grabCursor) {
                s.setGrabCursor();
            }
        };
        s.unlockSwipeToPrev = function () {
            s.params.allowSwipeToPrev = true;
            if (s.params.allowSwipeToNext === true && s.params.grabCursor) {
                s.setGrabCursor();
            }
        };
        s.unlockSwipes = function () {
            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;
            if (s.params.grabCursor) s.setGrabCursor();
        };

        /*=========================
          Round helper
          ===========================*/
        function round(a) {
            return Math.floor(a);
        }
        /*=========================
          Set grab cursor
          ===========================*/
        s.setGrabCursor = function (moving) {
            s.container[0].style.cursor = 'move';
            s.container[0].style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
            s.container[0].style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
            s.container[0].style.cursor = moving ? 'grabbing' : 'grab';
        };
        s.unsetGrabCursor = function () {
            s.container[0].style.cursor = '';
        };
        if (s.params.grabCursor) {
            s.setGrabCursor();
        }
        /*=========================
          Update on Images Ready
          ===========================*/
        s.imagesToLoad = [];
        s.imagesLoaded = 0;

        s.loadImage = function (imgElement, src, srcset, sizes, checkForComplete, callback) {
            var image;
            function onReady() {
                if (callback) callback();
            }
            if (!imgElement.complete || !checkForComplete) {
                if (src) {
                    image = new window.Image();
                    image.onload = onReady;
                    image.onerror = onReady;
                    if (sizes) {
                        image.sizes = sizes;
                    }
                    if (srcset) {
                        image.srcset = srcset;
                    }
                    if (src) {
                        image.src = src;
                    }
                } else {
                    onReady();
                }
            } else {
                //image already loaded...
                onReady();
            }
        };
        s.preloadImages = function () {
            s.imagesToLoad = s.container.find('img');
            function _onReady() {
                if (typeof s === 'undefined' || s === null || !s) return;
                if (s.imagesLoaded !== undefined) s.imagesLoaded++;
                if (s.imagesLoaded === s.imagesToLoad.length) {
                    if (s.params.updateOnImagesReady) s.update();
                    s.emit('onImagesReady', s);
                }
            }
            for (var i = 0; i < s.imagesToLoad.length; i++) {
                s.loadImage(s.imagesToLoad[i], s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src'), s.imagesToLoad[i].srcset || s.imagesToLoad[i].getAttribute('srcset'), s.imagesToLoad[i].sizes || s.imagesToLoad[i].getAttribute('sizes'), true, _onReady);
            }
        };

        /*=========================
          Autoplay
          ===========================*/
        s.autoplayTimeoutId = undefined;
        s.autoplaying = false;
        s.autoplayPaused = false;
        function autoplay() {
            var autoplayDelay = s.params.autoplay;
            var activeSlide = s.slides.eq(s.activeIndex);
            if (activeSlide.attr('data-swiper-autoplay')) {
                autoplayDelay = activeSlide.attr('data-swiper-autoplay') || s.params.autoplay;
            }
            s.autoplayTimeoutId = setTimeout(function () {
                if (s.params.loop) {
                    s.fixLoop();
                    s._slideNext();
                    s.emit('onAutoplay', s);
                } else {
                    if (!s.isEnd) {
                        s._slideNext();
                        s.emit('onAutoplay', s);
                    } else {
                        if (!params.autoplayStopOnLast) {
                            s._slideTo(0);
                            s.emit('onAutoplay', s);
                        } else {
                            s.stopAutoplay();
                        }
                    }
                }
            }, autoplayDelay);
        }
        s.startAutoplay = function () {
            if (typeof s.autoplayTimeoutId !== 'undefined') return false;
            if (!s.params.autoplay) return false;
            if (s.autoplaying) return false;
            s.autoplaying = true;
            s.emit('onAutoplayStart', s);
            autoplay();
        };
        s.stopAutoplay = function (internal) {
            if (!s.autoplayTimeoutId) return;
            if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
            s.autoplaying = false;
            s.autoplayTimeoutId = undefined;
            s.emit('onAutoplayStop', s);
        };
        s.pauseAutoplay = function (speed) {
            if (s.autoplayPaused) return;
            if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
            s.autoplayPaused = true;
            if (speed === 0) {
                s.autoplayPaused = false;
                autoplay();
            } else {
                s.wrapper.transitionEnd(function () {
                    if (!s) return;
                    s.autoplayPaused = false;
                    if (!s.autoplaying) {
                        s.stopAutoplay();
                    } else {
                        autoplay();
                    }
                });
            }
        };
        /*=========================
          Min/Max Translate
          ===========================*/
        s.minTranslate = function () {
            return -s.snapGrid[0];
        };
        s.maxTranslate = function () {
            return -s.snapGrid[s.snapGrid.length - 1];
        };
        /*=========================
          Slider/slides sizes
          ===========================*/
        s.updateAutoHeight = function () {
            var activeSlides = [];
            var newHeight = 0;
            var i;

            // Find slides currently in view
            if (s.params.slidesPerView !== 'auto' && s.params.slidesPerView > 1) {
                for (i = 0; i < Math.ceil(s.params.slidesPerView); i++) {
                    var index = s.activeIndex + i;
                    if (index > s.slides.length) break;
                    activeSlides.push(s.slides.eq(index)[0]);
                }
            } else {
                activeSlides.push(s.slides.eq(s.activeIndex)[0]);
            }

            // Find new height from heighest slide in view
            for (i = 0; i < activeSlides.length; i++) {
                if (typeof activeSlides[i] !== 'undefined') {
                    var height = activeSlides[i].offsetHeight;
                    newHeight = height > newHeight ? height : newHeight;
                }
            }

            // Update Height
            if (newHeight) s.wrapper.css('height', newHeight + 'px');
        };
        s.updateContainerSize = function () {
            var width, height;
            if (typeof s.params.width !== 'undefined') {
                width = s.params.width;
            } else {
                width = s.container[0].clientWidth;
            }
            if (typeof s.params.height !== 'undefined') {
                height = s.params.height;
            } else {
                height = s.container[0].clientHeight;
            }
            if (width === 0 && s.isHorizontal() || height === 0 && !s.isHorizontal()) {
                return;
            }

            //Subtract paddings
            width = width - parseInt(s.container.css('padding-left'), 10) - parseInt(s.container.css('padding-right'), 10);
            height = height - parseInt(s.container.css('padding-top'), 10) - parseInt(s.container.css('padding-bottom'), 10);

            // Store values
            s.width = width;
            s.height = height;
            s.size = s.isHorizontal() ? s.width : s.height;
        };

        s.updateSlidesSize = function () {
            s.slides = s.wrapper.children('.' + s.params.slideClass);
            s.snapGrid = [];
            s.slidesGrid = [];
            s.slidesSizesGrid = [];

            var spaceBetween = s.params.spaceBetween,
                slidePosition = -s.params.slidesOffsetBefore,
                i,
                prevSlideSize = 0,
                index = 0;
            if (typeof s.size === 'undefined') return;
            if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
                spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * s.size;
            }

            s.virtualSize = -spaceBetween;
            // reset margins
            if (s.rtl) s.slides.css({ marginLeft: '', marginTop: '' });else s.slides.css({ marginRight: '', marginBottom: '' });

            var slidesNumberEvenToRows;
            if (s.params.slidesPerColumn > 1) {
                if (Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn) {
                    slidesNumberEvenToRows = s.slides.length;
                } else {
                    slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;
                }
                if (s.params.slidesPerView !== 'auto' && s.params.slidesPerColumnFill === 'row') {
                    slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, s.params.slidesPerView * s.params.slidesPerColumn);
                }
            }

            // Calc slides
            var slideSize;
            var slidesPerColumn = s.params.slidesPerColumn;
            var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
            var numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
            for (i = 0; i < s.slides.length; i++) {
                slideSize = 0;
                var slide = s.slides.eq(i);
                if (s.params.slidesPerColumn > 1) {
                    // Set slides order
                    var newSlideOrderIndex;
                    var column, row;
                    if (s.params.slidesPerColumnFill === 'column') {
                        column = Math.floor(i / slidesPerColumn);
                        row = i - column * slidesPerColumn;
                        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
                            if (++row >= slidesPerColumn) {
                                row = 0;
                                column++;
                            }
                        }
                        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
                        slide.css({
                            '-webkit-box-ordinal-group': newSlideOrderIndex,
                            '-moz-box-ordinal-group': newSlideOrderIndex,
                            '-ms-flex-order': newSlideOrderIndex,
                            '-webkit-order': newSlideOrderIndex,
                            'order': newSlideOrderIndex
                        });
                    } else {
                        row = Math.floor(i / slidesPerRow);
                        column = i - row * slidesPerRow;
                    }
                    slide.css('margin-' + (s.isHorizontal() ? 'top' : 'left'), row !== 0 && s.params.spaceBetween && s.params.spaceBetween + 'px').attr('data-swiper-column', column).attr('data-swiper-row', row);
                }
                if (slide.css('display') === 'none') continue;
                if (s.params.slidesPerView === 'auto') {
                    slideSize = s.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
                    if (s.params.roundLengths) slideSize = round(slideSize);
                } else {
                    slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;
                    if (s.params.roundLengths) slideSize = round(slideSize);

                    if (s.isHorizontal()) {
                        s.slides[i].style.width = slideSize + 'px';
                    } else {
                        s.slides[i].style.height = slideSize + 'px';
                    }
                }
                s.slides[i].swiperSlideSize = slideSize;
                s.slidesSizesGrid.push(slideSize);

                if (s.params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - s.size / 2 - spaceBetween;
                    if (i === 0) slidePosition = slidePosition - s.size / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                    if (index % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
                    s.slidesGrid.push(slidePosition);
                } else {
                    if (index % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
                    s.slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }

                s.virtualSize += slideSize + spaceBetween;

                prevSlideSize = slideSize;

                index++;
            }
            s.virtualSize = Math.max(s.virtualSize, s.size) + s.params.slidesOffsetAfter;
            var newSlidesGrid;

            if (s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')) {
                s.wrapper.css({ width: s.virtualSize + s.params.spaceBetween + 'px' });
            }
            if (!s.support.flexbox || s.params.setWrapperSize) {
                if (s.isHorizontal()) s.wrapper.css({ width: s.virtualSize + s.params.spaceBetween + 'px' });else s.wrapper.css({ height: s.virtualSize + s.params.spaceBetween + 'px' });
            }

            if (s.params.slidesPerColumn > 1) {
                s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;
                s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;
                if (s.isHorizontal()) s.wrapper.css({ width: s.virtualSize + s.params.spaceBetween + 'px' });else s.wrapper.css({ height: s.virtualSize + s.params.spaceBetween + 'px' });
                if (s.params.centeredSlides) {
                    newSlidesGrid = [];
                    for (i = 0; i < s.snapGrid.length; i++) {
                        if (s.snapGrid[i] < s.virtualSize + s.snapGrid[0]) newSlidesGrid.push(s.snapGrid[i]);
                    }
                    s.snapGrid = newSlidesGrid;
                }
            }

            // Remove last grid elements depending on width
            if (!s.params.centeredSlides) {
                newSlidesGrid = [];
                for (i = 0; i < s.snapGrid.length; i++) {
                    if (s.snapGrid[i] <= s.virtualSize - s.size) {
                        newSlidesGrid.push(s.snapGrid[i]);
                    }
                }
                s.snapGrid = newSlidesGrid;
                if (Math.floor(s.virtualSize - s.size) - Math.floor(s.snapGrid[s.snapGrid.length - 1]) > 1) {
                    s.snapGrid.push(s.virtualSize - s.size);
                }
            }
            if (s.snapGrid.length === 0) s.snapGrid = [0];

            if (s.params.spaceBetween !== 0) {
                if (s.isHorizontal()) {
                    if (s.rtl) s.slides.css({ marginLeft: spaceBetween + 'px' });else s.slides.css({ marginRight: spaceBetween + 'px' });
                } else s.slides.css({ marginBottom: spaceBetween + 'px' });
            }
            if (s.params.watchSlidesProgress) {
                s.updateSlidesOffset();
            }
        };
        s.updateSlidesOffset = function () {
            for (var i = 0; i < s.slides.length; i++) {
                s.slides[i].swiperSlideOffset = s.isHorizontal() ? s.slides[i].offsetLeft : s.slides[i].offsetTop;
            }
        };

        /*=========================
          Dynamic Slides Per View
          ===========================*/
        s.currentSlidesPerView = function () {
            var spv = 1,
                i,
                j;
            if (s.params.centeredSlides) {
                var size = s.slides[s.activeIndex].swiperSlideSize;
                var breakLoop;
                for (i = s.activeIndex + 1; i < s.slides.length; i++) {
                    if (s.slides[i] && !breakLoop) {
                        size += s.slides[i].swiperSlideSize;
                        spv++;
                        if (size > s.size) breakLoop = true;
                    }
                }
                for (j = s.activeIndex - 1; j >= 0; j--) {
                    if (s.slides[j] && !breakLoop) {
                        size += s.slides[j].swiperSlideSize;
                        spv++;
                        if (size > s.size) breakLoop = true;
                    }
                }
            } else {
                for (i = s.activeIndex + 1; i < s.slides.length; i++) {
                    if (s.slidesGrid[i] - s.slidesGrid[s.activeIndex] < s.size) {
                        spv++;
                    }
                }
            }
            return spv;
        };
        /*=========================
          Slider/slides progress
          ===========================*/
        s.updateSlidesProgress = function (translate) {
            if (typeof translate === 'undefined') {
                translate = s.translate || 0;
            }
            if (s.slides.length === 0) return;
            if (typeof s.slides[0].swiperSlideOffset === 'undefined') s.updateSlidesOffset();

            var offsetCenter = -translate;
            if (s.rtl) offsetCenter = translate;

            // Visible Slides
            s.slides.removeClass(s.params.slideVisibleClass);
            for (var i = 0; i < s.slides.length; i++) {
                var slide = s.slides[i];
                var slideProgress = (offsetCenter + (s.params.centeredSlides ? s.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
                if (s.params.watchSlidesVisibility) {
                    var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
                    var slideAfter = slideBefore + s.slidesSizesGrid[i];
                    var isVisible = slideBefore >= 0 && slideBefore < s.size || slideAfter > 0 && slideAfter <= s.size || slideBefore <= 0 && slideAfter >= s.size;
                    if (isVisible) {
                        s.slides.eq(i).addClass(s.params.slideVisibleClass);
                    }
                }
                slide.progress = s.rtl ? -slideProgress : slideProgress;
            }
        };
        s.updateProgress = function (translate) {
            if (typeof translate === 'undefined') {
                translate = s.translate || 0;
            }
            var translatesDiff = s.maxTranslate() - s.minTranslate();
            var wasBeginning = s.isBeginning;
            var wasEnd = s.isEnd;
            if (translatesDiff === 0) {
                s.progress = 0;
                s.isBeginning = s.isEnd = true;
            } else {
                s.progress = (translate - s.minTranslate()) / translatesDiff;
                s.isBeginning = s.progress <= 0;
                s.isEnd = s.progress >= 1;
            }
            if (s.isBeginning && !wasBeginning) s.emit('onReachBeginning', s);
            if (s.isEnd && !wasEnd) s.emit('onReachEnd', s);

            if (s.params.watchSlidesProgress) s.updateSlidesProgress(translate);
            s.emit('onProgress', s, s.progress);
        };
        s.updateActiveIndex = function () {
            var translate = s.rtl ? s.translate : -s.translate;
            var newActiveIndex, i, snapIndex;
            for (i = 0; i < s.slidesGrid.length; i++) {
                if (typeof s.slidesGrid[i + 1] !== 'undefined') {
                    if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2) {
                        newActiveIndex = i;
                    } else if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]) {
                        newActiveIndex = i + 1;
                    }
                } else {
                    if (translate >= s.slidesGrid[i]) {
                        newActiveIndex = i;
                    }
                }
            }
            // Normalize slideIndex
            if (s.params.normalizeSlideIndex) {
                if (newActiveIndex < 0 || typeof newActiveIndex === 'undefined') newActiveIndex = 0;
            }
            // for (i = 0; i < s.slidesGrid.length; i++) {
            // if (- translate >= s.slidesGrid[i]) {
            // newActiveIndex = i;
            // }
            // }
            snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);
            if (snapIndex >= s.snapGrid.length) snapIndex = s.snapGrid.length - 1;

            if (newActiveIndex === s.activeIndex) {
                return;
            }
            s.snapIndex = snapIndex;
            s.previousIndex = s.activeIndex;
            s.activeIndex = newActiveIndex;
            s.updateClasses();
            s.updateRealIndex();
        };
        s.updateRealIndex = function () {
            s.realIndex = parseInt(s.slides.eq(s.activeIndex).attr('data-swiper-slide-index') || s.activeIndex, 10);
        };

        /*=========================
          Classes
          ===========================*/
        s.updateClasses = function () {
            s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass + ' ' + s.params.slideDuplicateActiveClass + ' ' + s.params.slideDuplicateNextClass + ' ' + s.params.slideDuplicatePrevClass);
            var activeSlide = s.slides.eq(s.activeIndex);
            // Active classes
            activeSlide.addClass(s.params.slideActiveClass);
            if (params.loop) {
                // Duplicate to all looped slides
                if (activeSlide.hasClass(s.params.slideDuplicateClass)) {
                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + s.realIndex + '"]').addClass(s.params.slideDuplicateActiveClass);
                } else {
                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + s.realIndex + '"]').addClass(s.params.slideDuplicateActiveClass);
                }
            }
            // Next Slide
            var nextSlide = activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);
            if (s.params.loop && nextSlide.length === 0) {
                nextSlide = s.slides.eq(0);
                nextSlide.addClass(s.params.slideNextClass);
            }
            // Prev Slide
            var prevSlide = activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass);
            if (s.params.loop && prevSlide.length === 0) {
                prevSlide = s.slides.eq(-1);
                prevSlide.addClass(s.params.slidePrevClass);
            }
            if (params.loop) {
                // Duplicate to all looped slides
                if (nextSlide.hasClass(s.params.slideDuplicateClass)) {
                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + nextSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicateNextClass);
                } else {
                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + nextSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicateNextClass);
                }
                if (prevSlide.hasClass(s.params.slideDuplicateClass)) {
                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + prevSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicatePrevClass);
                } else {
                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + prevSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicatePrevClass);
                }
            }

            // Pagination
            if (s.paginationContainer && s.paginationContainer.length > 0) {
                // Current/Total
                var current,
                    total = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
                if (s.params.loop) {
                    current = Math.ceil((s.activeIndex - s.loopedSlides) / s.params.slidesPerGroup);
                    if (current > s.slides.length - 1 - s.loopedSlides * 2) {
                        current = current - (s.slides.length - s.loopedSlides * 2);
                    }
                    if (current > total - 1) current = current - total;
                    if (current < 0 && s.params.paginationType !== 'bullets') current = total + current;
                } else {
                    if (typeof s.snapIndex !== 'undefined') {
                        current = s.snapIndex;
                    } else {
                        current = s.activeIndex || 0;
                    }
                }
                // Types
                if (s.params.paginationType === 'bullets' && s.bullets && s.bullets.length > 0) {
                    s.bullets.removeClass(s.params.bulletActiveClass);
                    if (s.paginationContainer.length > 1) {
                        s.bullets.each(function () {
                            if ($(this).index() === current) $(this).addClass(s.params.bulletActiveClass);
                        });
                    } else {
                        s.bullets.eq(current).addClass(s.params.bulletActiveClass);
                    }
                }
                if (s.params.paginationType === 'fraction') {
                    s.paginationContainer.find('.' + s.params.paginationCurrentClass).text(current + 1);
                    s.paginationContainer.find('.' + s.params.paginationTotalClass).text(total);
                }
                if (s.params.paginationType === 'progress') {
                    var scale = (current + 1) / total,
                        scaleX = scale,
                        scaleY = 1;
                    if (!s.isHorizontal()) {
                        scaleY = scale;
                        scaleX = 1;
                    }
                    s.paginationContainer.find('.' + s.params.paginationProgressbarClass).transform('translate3d(0,0,0) scaleX(' + scaleX + ') scaleY(' + scaleY + ')').transition(s.params.speed);
                }
                if (s.params.paginationType === 'custom' && s.params.paginationCustomRender) {
                    s.paginationContainer.html(s.params.paginationCustomRender(s, current + 1, total));
                    s.emit('onPaginationRendered', s, s.paginationContainer[0]);
                }
            }

            // Next/active buttons
            if (!s.params.loop) {
                if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                    if (s.isBeginning) {
                        s.prevButton.addClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.disable(s.prevButton);
                    } else {
                        s.prevButton.removeClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.enable(s.prevButton);
                    }
                }
                if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                    if (s.isEnd) {
                        s.nextButton.addClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.disable(s.nextButton);
                    } else {
                        s.nextButton.removeClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.enable(s.nextButton);
                    }
                }
            }
        };

        /*=========================
          Pagination
          ===========================*/
        s.updatePagination = function () {
            if (!s.params.pagination) return;
            if (s.paginationContainer && s.paginationContainer.length > 0) {
                var paginationHTML = '';
                if (s.params.paginationType === 'bullets') {
                    var numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
                    for (var i = 0; i < numberOfBullets; i++) {
                        if (s.params.paginationBulletRender) {
                            paginationHTML += s.params.paginationBulletRender(s, i, s.params.bulletClass);
                        } else {
                            paginationHTML += '<' + s.params.paginationElement + ' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';
                        }
                    }
                    s.paginationContainer.html(paginationHTML);
                    s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);
                    if (s.params.paginationClickable && s.params.a11y && s.a11y) {
                        s.a11y.initPagination();
                    }
                }
                if (s.params.paginationType === 'fraction') {
                    if (s.params.paginationFractionRender) {
                        paginationHTML = s.params.paginationFractionRender(s, s.params.paginationCurrentClass, s.params.paginationTotalClass);
                    } else {
                        paginationHTML = '<span class="' + s.params.paginationCurrentClass + '"></span>' + ' / ' + '<span class="' + s.params.paginationTotalClass + '"></span>';
                    }
                    s.paginationContainer.html(paginationHTML);
                }
                if (s.params.paginationType === 'progress') {
                    if (s.params.paginationProgressRender) {
                        paginationHTML = s.params.paginationProgressRender(s, s.params.paginationProgressbarClass);
                    } else {
                        paginationHTML = '<span class="' + s.params.paginationProgressbarClass + '"></span>';
                    }
                    s.paginationContainer.html(paginationHTML);
                }
                if (s.params.paginationType !== 'custom') {
                    s.emit('onPaginationRendered', s, s.paginationContainer[0]);
                }
            }
        };
        /*=========================
          Common update method
          ===========================*/
        s.update = function (updateTranslate) {
            if (!s) return;
            s.updateContainerSize();
            s.updateSlidesSize();
            s.updateProgress();
            s.updatePagination();
            s.updateClasses();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
            }
            var newTranslate;
            function forceSetTranslate() {
                var translate = s.rtl ? -s.translate : s.translate;
                newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
                s.setWrapperTranslate(newTranslate);
                s.updateActiveIndex();
                s.updateClasses();
            }
            if (updateTranslate) {
                var translated;
                if (s.controller && s.controller.spline) {
                    s.controller.spline = undefined;
                }
                if (s.params.freeMode) {
                    forceSetTranslate();
                    if (s.params.autoHeight) {
                        s.updateAutoHeight();
                    }
                } else {
                    if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                        translated = s.slideTo(s.slides.length - 1, 0, false, true);
                    } else {
                        translated = s.slideTo(s.activeIndex, 0, false, true);
                    }
                    if (!translated) {
                        forceSetTranslate();
                    }
                }
            } else if (s.params.autoHeight) {
                s.updateAutoHeight();
            }
        };

        /*=========================
          Resize Handler
          ===========================*/
        s.onResize = function (forceUpdatePagination) {
            if (s.params.onBeforeResize) s.params.onBeforeResize(s);
            //Breakpoints
            if (s.params.breakpoints) {
                s.setBreakpoint();
            }

            // Disable locks on resize
            var allowSwipeToPrev = s.params.allowSwipeToPrev;
            var allowSwipeToNext = s.params.allowSwipeToNext;
            s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;

            s.updateContainerSize();
            s.updateSlidesSize();
            if (s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination) s.updatePagination();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
            }
            if (s.controller && s.controller.spline) {
                s.controller.spline = undefined;
            }
            var slideChangedBySlideTo = false;
            if (s.params.freeMode) {
                var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
                s.setWrapperTranslate(newTranslate);
                s.updateActiveIndex();
                s.updateClasses();

                if (s.params.autoHeight) {
                    s.updateAutoHeight();
                }
            } else {
                s.updateClasses();
                if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                    slideChangedBySlideTo = s.slideTo(s.slides.length - 1, 0, false, true);
                } else {
                    slideChangedBySlideTo = s.slideTo(s.activeIndex, 0, false, true);
                }
            }
            if (s.params.lazyLoading && !slideChangedBySlideTo && s.lazy) {
                s.lazy.load();
            }
            // Return locks after resize
            s.params.allowSwipeToPrev = allowSwipeToPrev;
            s.params.allowSwipeToNext = allowSwipeToNext;
            if (s.params.onAfterResize) s.params.onAfterResize(s);
        };

        /*=========================
          Events
          ===========================*/

        //Define Touch Events
        s.touchEventsDesktop = { start: 'mousedown', move: 'mousemove', end: 'mouseup' };
        if (window.navigator.pointerEnabled) s.touchEventsDesktop = { start: 'pointerdown', move: 'pointermove', end: 'pointerup' };else if (window.navigator.msPointerEnabled) s.touchEventsDesktop = { start: 'MSPointerDown', move: 'MSPointerMove', end: 'MSPointerUp' };
        s.touchEvents = {
            start: s.support.touch || !s.params.simulateTouch ? 'touchstart' : s.touchEventsDesktop.start,
            move: s.support.touch || !s.params.simulateTouch ? 'touchmove' : s.touchEventsDesktop.move,
            end: s.support.touch || !s.params.simulateTouch ? 'touchend' : s.touchEventsDesktop.end
        };

        // WP8 Touch Events Fix
        if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
            (s.params.touchEventsTarget === 'container' ? s.container : s.wrapper).addClass('swiper-wp8-' + s.params.direction);
        }

        // Attach/detach events
        s.initEvents = function (detach) {
            var actionDom = detach ? 'off' : 'on';
            var action = detach ? 'removeEventListener' : 'addEventListener';
            var touchEventsTarget = s.params.touchEventsTarget === 'container' ? s.container[0] : s.wrapper[0];
            var target = s.support.touch ? touchEventsTarget : document;

            var moveCapture = s.params.nested ? true : false;

            //Touch Events
            if (s.browser.ie) {
                touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
                target[action](s.touchEvents.move, s.onTouchMove, moveCapture);
                target[action](s.touchEvents.end, s.onTouchEnd, false);
            } else {
                if (s.support.touch) {
                    var passiveListener = s.touchEvents.start === 'touchstart' && s.support.passiveListener && s.params.passiveListeners ? { passive: true, capture: false } : false;
                    touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, passiveListener);
                    touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture);
                    touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, passiveListener);
                }
                if (params.simulateTouch && !s.device.ios && !s.device.android || params.simulateTouch && !s.support.touch && s.device.ios) {
                    touchEventsTarget[action]('mousedown', s.onTouchStart, false);
                    document[action]('mousemove', s.onTouchMove, moveCapture);
                    document[action]('mouseup', s.onTouchEnd, false);
                }
            }
            window[action]('resize', s.onResize);

            // Next, Prev, Index
            if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                s.nextButton[actionDom]('click', s.onClickNext);
                if (s.params.a11y && s.a11y) s.nextButton[actionDom]('keydown', s.a11y.onEnterKey);
            }
            if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                s.prevButton[actionDom]('click', s.onClickPrev);
                if (s.params.a11y && s.a11y) s.prevButton[actionDom]('keydown', s.a11y.onEnterKey);
            }
            if (s.params.pagination && s.params.paginationClickable) {
                s.paginationContainer[actionDom]('click', '.' + s.params.bulletClass, s.onClickIndex);
                if (s.params.a11y && s.a11y) s.paginationContainer[actionDom]('keydown', '.' + s.params.bulletClass, s.a11y.onEnterKey);
            }

            // Prevent Links Clicks
            if (s.params.preventClicks || s.params.preventClicksPropagation) touchEventsTarget[action]('click', s.preventClicks, true);
        };
        s.attachEvents = function () {
            s.initEvents();
        };
        s.detachEvents = function () {
            s.initEvents(true);
        };

        /*=========================
          Handle Clicks
          ===========================*/
        // Prevent Clicks
        s.allowClick = true;
        s.preventClicks = function (e) {
            if (!s.allowClick) {
                if (s.params.preventClicks) e.preventDefault();
                if (s.params.preventClicksPropagation && s.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        };
        // Clicks
        s.onClickNext = function (e) {
            e.preventDefault();
            if (s.isEnd && !s.params.loop) return;
            s.slideNext();
        };
        s.onClickPrev = function (e) {
            e.preventDefault();
            if (s.isBeginning && !s.params.loop) return;
            s.slidePrev();
        };
        s.onClickIndex = function (e) {
            e.preventDefault();
            var index = $(this).index() * s.params.slidesPerGroup;
            if (s.params.loop) index = index + s.loopedSlides;
            s.slideTo(index);
        };

        /*=========================
          Handle Touches
          ===========================*/
        function findElementInEvent(e, selector) {
            var el = $(e.target);
            if (!el.is(selector)) {
                if (typeof selector === 'string') {
                    el = el.parents(selector);
                } else if (selector.nodeType) {
                    var found;
                    el.parents().each(function (index, _el) {
                        if (_el === selector) found = selector;
                    });
                    if (!found) return undefined;else return selector;
                }
            }
            if (el.length === 0) {
                return undefined;
            }
            return el[0];
        }
        s.updateClickedSlide = function (e) {
            var slide = findElementInEvent(e, '.' + s.params.slideClass);
            var slideFound = false;
            if (slide) {
                for (var i = 0; i < s.slides.length; i++) {
                    if (s.slides[i] === slide) slideFound = true;
                }
            }

            if (slide && slideFound) {
                s.clickedSlide = slide;
                s.clickedIndex = $(slide).index();
            } else {
                s.clickedSlide = undefined;
                s.clickedIndex = undefined;
                return;
            }
            if (s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex) {
                var slideToIndex = s.clickedIndex,
                    realIndex,
                    duplicatedSlides,
                    slidesPerView = s.params.slidesPerView === 'auto' ? s.currentSlidesPerView() : s.params.slidesPerView;
                if (s.params.loop) {
                    if (s.animating) return;
                    realIndex = parseInt($(s.clickedSlide).attr('data-swiper-slide-index'), 10);
                    if (s.params.centeredSlides) {
                        if (slideToIndex < s.loopedSlides - slidesPerView / 2 || slideToIndex > s.slides.length - s.loopedSlides + slidesPerView / 2) {
                            s.fixLoop();
                            slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + s.params.slideDuplicateClass + ')').eq(0).index();
                            setTimeout(function () {
                                s.slideTo(slideToIndex);
                            }, 0);
                        } else {
                            s.slideTo(slideToIndex);
                        }
                    } else {
                        if (slideToIndex > s.slides.length - slidesPerView) {
                            s.fixLoop();
                            slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + s.params.slideDuplicateClass + ')').eq(0).index();
                            setTimeout(function () {
                                s.slideTo(slideToIndex);
                            }, 0);
                        } else {
                            s.slideTo(slideToIndex);
                        }
                    }
                } else {
                    s.slideTo(slideToIndex);
                }
            }
        };

        var isTouched,
            isMoved,
            allowTouchCallbacks,
            touchStartTime,
            isScrolling,
            currentTranslate,
            startTranslate,
            allowThresholdMove,

        // Form elements to match
        formElements = 'input, select, textarea, button, video',

        // Last click time
        lastClickTime = Date.now(),
            clickTimeout,

        //Velocities
        velocities = [],
            allowMomentumBounce;

        // Animating Flag
        s.animating = false;

        // Touches information
        s.touches = {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
        };

        // Touch handlers
        var isTouchEvent, startMoving;
        s.onTouchStart = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            isTouchEvent = e.type === 'touchstart';
            if (!isTouchEvent && 'which' in e && e.which === 3) return;
            if (s.params.noSwiping && findElementInEvent(e, '.' + s.params.noSwipingClass)) {
                s.allowClick = true;
                return;
            }
            if (s.params.swipeHandler) {
                if (!findElementInEvent(e, s.params.swipeHandler)) return;
            }

            var startX = s.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            var startY = s.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;

            // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
            if (s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold) {
                return;
            }

            isTouched = true;
            isMoved = false;
            allowTouchCallbacks = true;
            isScrolling = undefined;
            startMoving = undefined;
            s.touches.startX = startX;
            s.touches.startY = startY;
            touchStartTime = Date.now();
            s.allowClick = true;
            s.updateContainerSize();
            s.swipeDirection = undefined;
            if (s.params.threshold > 0) allowThresholdMove = false;
            if (e.type !== 'touchstart') {
                var preventDefault = true;
                if ($(e.target).is(formElements)) preventDefault = false;
                if (document.activeElement && $(document.activeElement).is(formElements)) {
                    document.activeElement.blur();
                }
                if (preventDefault) {
                    e.preventDefault();
                }
            }
            s.emit('onTouchStart', s, e);
        };

        s.onTouchMove = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            if (isTouchEvent && e.type === 'mousemove') return;
            if (e.preventedByNestedSwiper) {
                s.touches.startX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                s.touches.startY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
                return;
            }
            if (s.params.onlyExternal) {
                // isMoved = true;
                s.allowClick = false;
                if (isTouched) {
                    s.touches.startX = s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                    s.touches.startY = s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
                    touchStartTime = Date.now();
                }
                return;
            }
            if (isTouchEvent && s.params.touchReleaseOnEdges && !s.params.loop) {
                if (!s.isHorizontal()) {
                    // Vertical
                    if (s.touches.currentY < s.touches.startY && s.translate <= s.maxTranslate() || s.touches.currentY > s.touches.startY && s.translate >= s.minTranslate()) {
                        return;
                    }
                } else {
                    if (s.touches.currentX < s.touches.startX && s.translate <= s.maxTranslate() || s.touches.currentX > s.touches.startX && s.translate >= s.minTranslate()) {
                        return;
                    }
                }
            }
            if (isTouchEvent && document.activeElement) {
                if (e.target === document.activeElement && $(e.target).is(formElements)) {
                    isMoved = true;
                    s.allowClick = false;
                    return;
                }
            }
            if (allowTouchCallbacks) {
                s.emit('onTouchMove', s, e);
            }
            if (e.targetTouches && e.targetTouches.length > 1) return;

            s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

            if (typeof isScrolling === 'undefined') {
                var touchAngle;
                if (s.isHorizontal() && s.touches.currentY === s.touches.startY || !s.isHorizontal() && s.touches.currentX === s.touches.startX) {
                    isScrolling = false;
                } else {
                    touchAngle = Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;
                    isScrolling = s.isHorizontal() ? touchAngle > s.params.touchAngle : 90 - touchAngle > s.params.touchAngle;
                }
            }
            if (isScrolling) {
                s.emit('onTouchMoveOpposite', s, e);
            }
            if (typeof startMoving === 'undefined') {
                if (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) {
                    startMoving = true;
                }
            }
            if (!isTouched) return;
            if (isScrolling) {
                isTouched = false;
                return;
            }
            if (!startMoving) {
                return;
            }
            s.allowClick = false;
            s.emit('onSliderMove', s, e);
            e.preventDefault();
            if (s.params.touchMoveStopPropagation && !s.params.nested) {
                e.stopPropagation();
            }

            if (!isMoved) {
                if (params.loop) {
                    s.fixLoop();
                }
                startTranslate = s.getWrapperTranslate();
                s.setWrapperTransition(0);
                if (s.animating) {
                    s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');
                }
                if (s.params.autoplay && s.autoplaying) {
                    if (s.params.autoplayDisableOnInteraction) {
                        s.stopAutoplay();
                    } else {
                        s.pauseAutoplay();
                    }
                }
                allowMomentumBounce = false;
                //Grab Cursor
                if (s.params.grabCursor && (s.params.allowSwipeToNext === true || s.params.allowSwipeToPrev === true)) {
                    s.setGrabCursor(true);
                }
            }
            isMoved = true;

            var diff = s.touches.diff = s.isHorizontal() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;

            diff = diff * s.params.touchRatio;
            if (s.rtl) diff = -diff;

            s.swipeDirection = diff > 0 ? 'prev' : 'next';
            currentTranslate = diff + startTranslate;

            var disableParentSwiper = true;
            if (diff > 0 && currentTranslate > s.minTranslate()) {
                disableParentSwiper = false;
                if (s.params.resistance) currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio);
            } else if (diff < 0 && currentTranslate < s.maxTranslate()) {
                disableParentSwiper = false;
                if (s.params.resistance) currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio);
            }

            if (disableParentSwiper) {
                e.preventedByNestedSwiper = true;
            }

            // Directions locks
            if (!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate) {
                currentTranslate = startTranslate;
            }
            if (!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate) {
                currentTranslate = startTranslate;
            }

            // Threshold
            if (s.params.threshold > 0) {
                if (Math.abs(diff) > s.params.threshold || allowThresholdMove) {
                    if (!allowThresholdMove) {
                        allowThresholdMove = true;
                        s.touches.startX = s.touches.currentX;
                        s.touches.startY = s.touches.currentY;
                        currentTranslate = startTranslate;
                        s.touches.diff = s.isHorizontal() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
                        return;
                    }
                } else {
                    currentTranslate = startTranslate;
                    return;
                }
            }

            if (!s.params.followFinger) return;

            // Update active index in free mode
            if (s.params.freeMode || s.params.watchSlidesProgress) {
                s.updateActiveIndex();
            }
            if (s.params.freeMode) {
                //Velocity
                if (velocities.length === 0) {
                    velocities.push({
                        position: s.touches[s.isHorizontal() ? 'startX' : 'startY'],
                        time: touchStartTime
                    });
                }
                velocities.push({
                    position: s.touches[s.isHorizontal() ? 'currentX' : 'currentY'],
                    time: new window.Date().getTime()
                });
            }
            // Update progress
            s.updateProgress(currentTranslate);
            // Update translate
            s.setWrapperTranslate(currentTranslate);
        };
        s.onTouchEnd = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            if (allowTouchCallbacks) {
                s.emit('onTouchEnd', s, e);
            }
            allowTouchCallbacks = false;
            if (!isTouched) return;
            //Return Grab Cursor
            if (s.params.grabCursor && isMoved && isTouched && (s.params.allowSwipeToNext === true || s.params.allowSwipeToPrev === true)) {
                s.setGrabCursor(false);
            }

            // Time diff
            var touchEndTime = Date.now();
            var timeDiff = touchEndTime - touchStartTime;

            // Tap, doubleTap, Click
            if (s.allowClick) {
                s.updateClickedSlide(e);
                s.emit('onTap', s, e);
                if (timeDiff < 300 && touchEndTime - lastClickTime > 300) {
                    if (clickTimeout) clearTimeout(clickTimeout);
                    clickTimeout = setTimeout(function () {
                        if (!s) return;
                        if (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)) {
                            s.paginationContainer.toggleClass(s.params.paginationHiddenClass);
                        }
                        s.emit('onClick', s, e);
                    }, 300);
                }
                if (timeDiff < 300 && touchEndTime - lastClickTime < 300) {
                    if (clickTimeout) clearTimeout(clickTimeout);
                    s.emit('onDoubleTap', s, e);
                }
            }

            lastClickTime = Date.now();
            setTimeout(function () {
                if (s) s.allowClick = true;
            }, 0);

            if (!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate) {
                isTouched = isMoved = false;
                return;
            }
            isTouched = isMoved = false;

            var currentPos;
            if (s.params.followFinger) {
                currentPos = s.rtl ? s.translate : -s.translate;
            } else {
                currentPos = -currentTranslate;
            }
            if (s.params.freeMode) {
                if (currentPos < -s.minTranslate()) {
                    s.slideTo(s.activeIndex);
                    return;
                } else if (currentPos > -s.maxTranslate()) {
                    if (s.slides.length < s.snapGrid.length) {
                        s.slideTo(s.snapGrid.length - 1);
                    } else {
                        s.slideTo(s.slides.length - 1);
                    }
                    return;
                }

                if (s.params.freeModeMomentum) {
                    if (velocities.length > 1) {
                        var lastMoveEvent = velocities.pop(),
                            velocityEvent = velocities.pop();

                        var distance = lastMoveEvent.position - velocityEvent.position;
                        var time = lastMoveEvent.time - velocityEvent.time;
                        s.velocity = distance / time;
                        s.velocity = s.velocity / 2;
                        if (Math.abs(s.velocity) < s.params.freeModeMinimumVelocity) {
                            s.velocity = 0;
                        }
                        // this implies that the user stopped moving a finger then released.
                        // There would be no events with distance zero, so the last event is stale.
                        if (time > 150 || new window.Date().getTime() - lastMoveEvent.time > 300) {
                            s.velocity = 0;
                        }
                    } else {
                        s.velocity = 0;
                    }
                    s.velocity = s.velocity * s.params.freeModeMomentumVelocityRatio;

                    velocities.length = 0;
                    var momentumDuration = 1000 * s.params.freeModeMomentumRatio;
                    var momentumDistance = s.velocity * momentumDuration;

                    var newPosition = s.translate + momentumDistance;
                    if (s.rtl) newPosition = -newPosition;
                    var doBounce = false;
                    var afterBouncePosition;
                    var bounceAmount = Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;
                    if (newPosition < s.maxTranslate()) {
                        if (s.params.freeModeMomentumBounce) {
                            if (newPosition + s.maxTranslate() < -bounceAmount) {
                                newPosition = s.maxTranslate() - bounceAmount;
                            }
                            afterBouncePosition = s.maxTranslate();
                            doBounce = true;
                            allowMomentumBounce = true;
                        } else {
                            newPosition = s.maxTranslate();
                        }
                    } else if (newPosition > s.minTranslate()) {
                        if (s.params.freeModeMomentumBounce) {
                            if (newPosition - s.minTranslate() > bounceAmount) {
                                newPosition = s.minTranslate() + bounceAmount;
                            }
                            afterBouncePosition = s.minTranslate();
                            doBounce = true;
                            allowMomentumBounce = true;
                        } else {
                            newPosition = s.minTranslate();
                        }
                    } else if (s.params.freeModeSticky) {
                        var j = 0,
                            nextSlide;
                        for (j = 0; j < s.snapGrid.length; j += 1) {
                            if (s.snapGrid[j] > -newPosition) {
                                nextSlide = j;
                                break;
                            }
                        }
                        if (Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next') {
                            newPosition = s.snapGrid[nextSlide];
                        } else {
                            newPosition = s.snapGrid[nextSlide - 1];
                        }
                        if (!s.rtl) newPosition = -newPosition;
                    }
                    //Fix duration
                    if (s.velocity !== 0) {
                        if (s.rtl) {
                            momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);
                        } else {
                            momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);
                        }
                    } else if (s.params.freeModeSticky) {
                        s.slideReset();
                        return;
                    }

                    if (s.params.freeModeMomentumBounce && doBounce) {
                        s.updateProgress(afterBouncePosition);
                        s.setWrapperTransition(momentumDuration);
                        s.setWrapperTranslate(newPosition);
                        s.onTransitionStart();
                        s.animating = true;
                        s.wrapper.transitionEnd(function () {
                            if (!s || !allowMomentumBounce) return;
                            s.emit('onMomentumBounce', s);

                            s.setWrapperTransition(s.params.speed);
                            s.setWrapperTranslate(afterBouncePosition);
                            s.wrapper.transitionEnd(function () {
                                if (!s) return;
                                s.onTransitionEnd();
                            });
                        });
                    } else if (s.velocity) {
                        s.updateProgress(newPosition);
                        s.setWrapperTransition(momentumDuration);
                        s.setWrapperTranslate(newPosition);
                        s.onTransitionStart();
                        if (!s.animating) {
                            s.animating = true;
                            s.wrapper.transitionEnd(function () {
                                if (!s) return;
                                s.onTransitionEnd();
                            });
                        }
                    } else {
                        s.updateProgress(newPosition);
                    }

                    s.updateActiveIndex();
                }
                if (!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) {
                    s.updateProgress();
                    s.updateActiveIndex();
                }
                return;
            }

            // Find current slide
            var i,
                stopIndex = 0,
                groupSize = s.slidesSizesGrid[0];
            for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup) {
                if (typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined') {
                    if (currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]) {
                        stopIndex = i;
                        groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];
                    }
                } else {
                    if (currentPos >= s.slidesGrid[i]) {
                        stopIndex = i;
                        groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];
                    }
                }
            }

            // Find current slide size
            var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;

            if (timeDiff > s.params.longSwipesMs) {
                // Long touches
                if (!s.params.longSwipes) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                if (s.swipeDirection === 'next') {
                    if (ratio >= s.params.longSwipesRatio) s.slideTo(stopIndex + s.params.slidesPerGroup);else s.slideTo(stopIndex);
                }
                if (s.swipeDirection === 'prev') {
                    if (ratio > 1 - s.params.longSwipesRatio) s.slideTo(stopIndex + s.params.slidesPerGroup);else s.slideTo(stopIndex);
                }
            } else {
                // Short swipes
                if (!s.params.shortSwipes) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                if (s.swipeDirection === 'next') {
                    s.slideTo(stopIndex + s.params.slidesPerGroup);
                }
                if (s.swipeDirection === 'prev') {
                    s.slideTo(stopIndex);
                }
            }
        };
        /*=========================
          Transitions
          ===========================*/
        s._slideTo = function (slideIndex, speed) {
            return s.slideTo(slideIndex, speed, true, true);
        };
        s.slideTo = function (slideIndex, speed, runCallbacks, internal) {
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (typeof slideIndex === 'undefined') slideIndex = 0;
            if (slideIndex < 0) slideIndex = 0;
            s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);
            if (s.snapIndex >= s.snapGrid.length) s.snapIndex = s.snapGrid.length - 1;

            var translate = -s.snapGrid[s.snapIndex];
            // Stop autoplay
            if (s.params.autoplay && s.autoplaying) {
                if (internal || !s.params.autoplayDisableOnInteraction) {
                    s.pauseAutoplay(speed);
                } else {
                    s.stopAutoplay();
                }
            }
            // Update progress
            s.updateProgress(translate);

            // Normalize slideIndex
            if (s.params.normalizeSlideIndex) {
                for (var i = 0; i < s.slidesGrid.length; i++) {
                    if (-Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)) {
                        slideIndex = i;
                    }
                }
            }

            // Directions locks
            if (!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()) {
                return false;
            }
            if (!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()) {
                if ((s.activeIndex || 0) !== slideIndex) return false;
            }

            // Update Index
            if (typeof speed === 'undefined') speed = s.params.speed;
            s.previousIndex = s.activeIndex || 0;
            s.activeIndex = slideIndex;
            s.updateRealIndex();
            if (s.rtl && -translate === s.translate || !s.rtl && translate === s.translate) {
                // Update Height
                if (s.params.autoHeight) {
                    s.updateAutoHeight();
                }
                s.updateClasses();
                if (s.params.effect !== 'slide') {
                    s.setWrapperTranslate(translate);
                }
                return false;
            }
            s.updateClasses();
            s.onTransitionStart(runCallbacks);

            if (speed === 0 || s.browser.lteIE9) {
                s.setWrapperTranslate(translate);
                s.setWrapperTransition(0);
                s.onTransitionEnd(runCallbacks);
            } else {
                s.setWrapperTranslate(translate);
                s.setWrapperTransition(speed);
                if (!s.animating) {
                    s.animating = true;
                    s.wrapper.transitionEnd(function () {
                        if (!s) return;
                        s.onTransitionEnd(runCallbacks);
                    });
                }
            }

            return true;
        };

        s.onTransitionStart = function (runCallbacks) {
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (s.params.autoHeight) {
                s.updateAutoHeight();
            }
            if (s.lazy) s.lazy.onTransitionStart();
            if (runCallbacks) {
                s.emit('onTransitionStart', s);
                if (s.activeIndex !== s.previousIndex) {
                    s.emit('onSlideChangeStart', s);
                    if (s.activeIndex > s.previousIndex) {
                        s.emit('onSlideNextStart', s);
                    } else {
                        s.emit('onSlidePrevStart', s);
                    }
                }
            }
        };
        s.onTransitionEnd = function (runCallbacks) {
            s.animating = false;
            s.setWrapperTransition(0);
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (s.lazy) s.lazy.onTransitionEnd();
            if (runCallbacks) {
                s.emit('onTransitionEnd', s);
                if (s.activeIndex !== s.previousIndex) {
                    s.emit('onSlideChangeEnd', s);
                    if (s.activeIndex > s.previousIndex) {
                        s.emit('onSlideNextEnd', s);
                    } else {
                        s.emit('onSlidePrevEnd', s);
                    }
                }
            }
            if (s.params.history && s.history) {
                s.history.setHistory(s.params.history, s.activeIndex);
            }
            if (s.params.hashnav && s.hashnav) {
                s.hashnav.setHash();
            }
        };
        s.slideNext = function (runCallbacks, speed, internal) {
            if (s.params.loop) {
                if (s.animating) return false;
                s.fixLoop();
                var clientLeft = s.container[0].clientLeft;
                return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
            } else return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
        };
        s._slideNext = function (speed) {
            return s.slideNext(true, speed, true);
        };
        s.slidePrev = function (runCallbacks, speed, internal) {
            if (s.params.loop) {
                if (s.animating) return false;
                s.fixLoop();
                var clientLeft = s.container[0].clientLeft;
                return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
            } else return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
        };
        s._slidePrev = function (speed) {
            return s.slidePrev(true, speed, true);
        };
        s.slideReset = function (runCallbacks, speed, internal) {
            return s.slideTo(s.activeIndex, speed, runCallbacks);
        };

        s.disableTouchControl = function () {
            s.params.onlyExternal = true;
            return true;
        };
        s.enableTouchControl = function () {
            s.params.onlyExternal = false;
            return true;
        };

        /*=========================
          Translate/transition helpers
          ===========================*/
        s.setWrapperTransition = function (duration, byController) {
            s.wrapper.transition(duration);
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                s.effects[s.params.effect].setTransition(duration);
            }
            if (s.params.parallax && s.parallax) {
                s.parallax.setTransition(duration);
            }
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.setTransition(duration);
            }
            if (s.params.control && s.controller) {
                s.controller.setTransition(duration, byController);
            }
            s.emit('onSetTransition', s, duration);
        };
        s.setWrapperTranslate = function (translate, updateActiveIndex, byController) {
            var x = 0,
                y = 0,
                z = 0;
            if (s.isHorizontal()) {
                x = s.rtl ? -translate : translate;
            } else {
                y = translate;
            }

            if (s.params.roundLengths) {
                x = round(x);
                y = round(y);
            }

            if (!s.params.virtualTranslate) {
                if (s.support.transforms3d) s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');else s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');
            }

            s.translate = s.isHorizontal() ? x : y;

            // Check if we need to update progress
            var progress;
            var translatesDiff = s.maxTranslate() - s.minTranslate();
            if (translatesDiff === 0) {
                progress = 0;
            } else {
                progress = (translate - s.minTranslate()) / translatesDiff;
            }
            if (progress !== s.progress) {
                s.updateProgress(translate);
            }

            if (updateActiveIndex) s.updateActiveIndex();
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                s.effects[s.params.effect].setTranslate(s.translate);
            }
            if (s.params.parallax && s.parallax) {
                s.parallax.setTranslate(s.translate);
            }
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.setTranslate(s.translate);
            }
            if (s.params.control && s.controller) {
                s.controller.setTranslate(s.translate, byController);
            }
            s.emit('onSetTranslate', s, s.translate);
        };

        s.getTranslate = function (el, axis) {
            var matrix, curTransform, curStyle, transformMatrix;

            // automatic axis detection
            if (typeof axis === 'undefined') {
                axis = 'x';
            }

            if (s.params.virtualTranslate) {
                return s.rtl ? -s.translate : s.translate;
            }

            curStyle = window.getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(',').length > 6) {
                    curTransform = curTransform.split(', ').map(function (a) {
                        return a.replace(',', '.');
                    }).join(', ');
                }
                // Some old versions of Webkit choke when 'none' is passed; pass
                // empty string instead in this case
                transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
                matrix = transformMatrix.toString().split(',');
            }

            if (axis === 'x') {
                //Latest Chrome and webkits Fix
                if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
                //Crazy IE10 Matrix
                else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
                    //Normal Browsers
                    else curTransform = parseFloat(matrix[4]);
            }
            if (axis === 'y') {
                //Latest Chrome and webkits Fix
                if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
                //Crazy IE10 Matrix
                else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
                    //Normal Browsers
                    else curTransform = parseFloat(matrix[5]);
            }
            if (s.rtl && curTransform) curTransform = -curTransform;
            return curTransform || 0;
        };
        s.getWrapperTranslate = function (axis) {
            if (typeof axis === 'undefined') {
                axis = s.isHorizontal() ? 'x' : 'y';
            }
            return s.getTranslate(s.wrapper[0], axis);
        };

        /*=========================
          Observer
          ===========================*/
        s.observers = [];
        function initObserver(target, options) {
            options = options || {};
            // create an observer instance
            var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
            var observer = new ObserverFunc(function (mutations) {
                mutations.forEach(function (mutation) {
                    s.onResize(true);
                    s.emit('onObserverUpdate', s, mutation);
                });
            });

            observer.observe(target, {
                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
                childList: typeof options.childList === 'undefined' ? true : options.childList,
                characterData: typeof options.characterData === 'undefined' ? true : options.characterData
            });

            s.observers.push(observer);
        }
        s.initObservers = function () {
            if (s.params.observeParents) {
                var containerParents = s.container.parents();
                for (var i = 0; i < containerParents.length; i++) {
                    initObserver(containerParents[i]);
                }
            }

            // Observe container
            initObserver(s.container[0], { childList: false });

            // Observe wrapper
            initObserver(s.wrapper[0], { attributes: false });
        };
        s.disconnectObservers = function () {
            for (var i = 0; i < s.observers.length; i++) {
                s.observers[i].disconnect();
            }
            s.observers = [];
        };
        /*=========================
          Loop
          ===========================*/
        // Create looped slides
        s.createLoop = function () {
            // Remove duplicated slides
            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();

            var slides = s.wrapper.children('.' + s.params.slideClass);

            if (s.params.slidesPerView === 'auto' && !s.params.loopedSlides) s.params.loopedSlides = slides.length;

            s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10);
            s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;
            if (s.loopedSlides > slides.length) {
                s.loopedSlides = slides.length;
            }

            var prependSlides = [],
                appendSlides = [],
                i;
            slides.each(function (index, el) {
                var slide = $(this);
                if (index < s.loopedSlides) appendSlides.push(el);
                if (index < slides.length && index >= slides.length - s.loopedSlides) prependSlides.push(el);
                slide.attr('data-swiper-slide-index', index);
            });
            for (i = 0; i < appendSlides.length; i++) {
                s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
            }
            for (i = prependSlides.length - 1; i >= 0; i--) {
                s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
            }
        };
        s.destroyLoop = function () {
            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
            s.slides.removeAttr('data-swiper-slide-index');
        };
        s.reLoop = function (updatePosition) {
            var oldIndex = s.activeIndex - s.loopedSlides;
            s.destroyLoop();
            s.createLoop();
            s.updateSlidesSize();
            if (updatePosition) {
                s.slideTo(oldIndex + s.loopedSlides, 0, false);
            }
        };
        s.fixLoop = function () {
            var newIndex;
            //Fix For Negative Oversliding
            if (s.activeIndex < s.loopedSlides) {
                newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;
                newIndex = newIndex + s.loopedSlides;
                s.slideTo(newIndex, 0, false, true);
            }
            //Fix For Positive Oversliding
            else if (s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2 || s.activeIndex > s.slides.length - s.params.slidesPerView * 2) {
                    newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;
                    newIndex = newIndex + s.loopedSlides;
                    s.slideTo(newIndex, 0, false, true);
                }
        };
        /*=========================
          Append/Prepend/Remove Slides
          ===========================*/
        s.appendSlide = function (slides) {
            if (s.params.loop) {
                s.destroyLoop();
            }
            if (typeof slides === 'object' && slides.length) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i]) s.wrapper.append(slides[i]);
                }
            } else {
                s.wrapper.append(slides);
            }
            if (s.params.loop) {
                s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
        };
        s.prependSlide = function (slides) {
            if (s.params.loop) {
                s.destroyLoop();
            }
            var newActiveIndex = s.activeIndex + 1;
            if (typeof slides === 'object' && slides.length) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i]) s.wrapper.prepend(slides[i]);
                }
                newActiveIndex = s.activeIndex + slides.length;
            } else {
                s.wrapper.prepend(slides);
            }
            if (s.params.loop) {
                s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
            s.slideTo(newActiveIndex, 0, false);
        };
        s.removeSlide = function (slidesIndexes) {
            if (s.params.loop) {
                s.destroyLoop();
                s.slides = s.wrapper.children('.' + s.params.slideClass);
            }
            var newActiveIndex = s.activeIndex,
                indexToRemove;
            if (typeof slidesIndexes === 'object' && slidesIndexes.length) {
                for (var i = 0; i < slidesIndexes.length; i++) {
                    indexToRemove = slidesIndexes[i];
                    if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
                    if (indexToRemove < newActiveIndex) newActiveIndex--;
                }
                newActiveIndex = Math.max(newActiveIndex, 0);
            } else {
                indexToRemove = slidesIndexes;
                if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
                if (indexToRemove < newActiveIndex) newActiveIndex--;
                newActiveIndex = Math.max(newActiveIndex, 0);
            }

            if (s.params.loop) {
                s.createLoop();
            }

            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
            if (s.params.loop) {
                s.slideTo(newActiveIndex + s.loopedSlides, 0, false);
            } else {
                s.slideTo(newActiveIndex, 0, false);
            }
        };
        s.removeAllSlides = function () {
            var slidesIndexes = [];
            for (var i = 0; i < s.slides.length; i++) {
                slidesIndexes.push(i);
            }
            s.removeSlide(slidesIndexes);
        };

        /*=========================
          Effects
          ===========================*/
        s.effects = {
            fade: {
                setTranslate: function () {
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var offset = slide[0].swiperSlideOffset;
                        var tx = -offset;
                        if (!s.params.virtualTranslate) tx = tx - s.translate;
                        var ty = 0;
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                        }
                        var slideOpacity = s.params.fade.crossFade ? Math.max(1 - Math.abs(slide[0].progress), 0) : 1 + Math.min(Math.max(slide[0].progress, -1), 0);
                        slide.css({
                            opacity: slideOpacity
                        }).transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');
                    }
                },
                setTransition: function (duration) {
                    s.slides.transition(duration);
                    if (s.params.virtualTranslate && duration !== 0) {
                        var eventTriggered = false;
                        s.slides.transitionEnd(function () {
                            if (eventTriggered) return;
                            if (!s) return;
                            eventTriggered = true;
                            s.animating = false;
                            var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
                            for (var i = 0; i < triggerEvents.length; i++) {
                                s.wrapper.trigger(triggerEvents[i]);
                            }
                        });
                    }
                }
            },
            flip: {
                setTranslate: function () {
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var progress = slide[0].progress;
                        if (s.params.flip.limitRotation) {
                            progress = Math.max(Math.min(slide[0].progress, 1), -1);
                        }
                        var offset = slide[0].swiperSlideOffset;
                        var rotate = -180 * progress,
                            rotateY = rotate,
                            rotateX = 0,
                            tx = -offset,
                            ty = 0;
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                            rotateX = -rotateY;
                            rotateY = 0;
                        } else if (s.rtl) {
                            rotateY = -rotateY;
                        }

                        slide[0].style.zIndex = -Math.abs(Math.round(progress)) + s.slides.length;

                        if (s.params.flip.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
                        }

                        slide.transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px) rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)');
                    }
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                    if (s.params.virtualTranslate && duration !== 0) {
                        var eventTriggered = false;
                        s.slides.eq(s.activeIndex).transitionEnd(function () {
                            if (eventTriggered) return;
                            if (!s) return;
                            if (!$(this).hasClass(s.params.slideActiveClass)) return;
                            eventTriggered = true;
                            s.animating = false;
                            var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
                            for (var i = 0; i < triggerEvents.length; i++) {
                                s.wrapper.trigger(triggerEvents[i]);
                            }
                        });
                    }
                }
            },
            cube: {
                setTranslate: function () {
                    var wrapperRotate = 0,
                        cubeShadow;
                    if (s.params.cube.shadow) {
                        if (s.isHorizontal()) {
                            cubeShadow = s.wrapper.find('.swiper-cube-shadow');
                            if (cubeShadow.length === 0) {
                                cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                                s.wrapper.append(cubeShadow);
                            }
                            cubeShadow.css({ height: s.width + 'px' });
                        } else {
                            cubeShadow = s.container.find('.swiper-cube-shadow');
                            if (cubeShadow.length === 0) {
                                cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                                s.container.append(cubeShadow);
                            }
                        }
                    }
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var slideAngle = i * 90;
                        var round = Math.floor(slideAngle / 360);
                        if (s.rtl) {
                            slideAngle = -slideAngle;
                            round = Math.floor(-slideAngle / 360);
                        }
                        var progress = Math.max(Math.min(slide[0].progress, 1), -1);
                        var tx = 0,
                            ty = 0,
                            tz = 0;
                        if (i % 4 === 0) {
                            tx = -round * 4 * s.size;
                            tz = 0;
                        } else if ((i - 1) % 4 === 0) {
                            tx = 0;
                            tz = -round * 4 * s.size;
                        } else if ((i - 2) % 4 === 0) {
                            tx = s.size + round * 4 * s.size;
                            tz = s.size;
                        } else if ((i - 3) % 4 === 0) {
                            tx = -s.size;
                            tz = 3 * s.size + s.size * 4 * round;
                        }
                        if (s.rtl) {
                            tx = -tx;
                        }

                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                        }

                        var transform = 'rotateX(' + (s.isHorizontal() ? 0 : -slideAngle) + 'deg) rotateY(' + (s.isHorizontal() ? slideAngle : 0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';
                        if (progress <= 1 && progress > -1) {
                            wrapperRotate = i * 90 + progress * 90;
                            if (s.rtl) wrapperRotate = -i * 90 - progress * 90;
                        }
                        slide.transform(transform);
                        if (s.params.cube.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
                        }
                    }
                    s.wrapper.css({
                        '-webkit-transform-origin': '50% 50% -' + s.size / 2 + 'px',
                        '-moz-transform-origin': '50% 50% -' + s.size / 2 + 'px',
                        '-ms-transform-origin': '50% 50% -' + s.size / 2 + 'px',
                        'transform-origin': '50% 50% -' + s.size / 2 + 'px'
                    });

                    if (s.params.cube.shadow) {
                        if (s.isHorizontal()) {
                            cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + -s.width / 2 + 'px) rotateX(90deg) rotateZ(0deg) scale(' + s.params.cube.shadowScale + ')');
                        } else {
                            var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                            var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                            var scale1 = s.params.cube.shadowScale,
                                scale2 = s.params.cube.shadowScale / multiplier,
                                offset = s.params.cube.shadowOffset;
                            cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + -s.height / 2 / scale2 + 'px) rotateX(-90deg)');
                        }
                    }
                    var zFactor = s.isSafari || s.isUiWebView ? -s.size / 2 : 0;
                    s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (s.isHorizontal() ? 0 : wrapperRotate) + 'deg) rotateY(' + (s.isHorizontal() ? -wrapperRotate : 0) + 'deg)');
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                    if (s.params.cube.shadow && !s.isHorizontal()) {
                        s.container.find('.swiper-cube-shadow').transition(duration);
                    }
                }
            },
            coverflow: {
                setTranslate: function () {
                    var transform = s.translate;
                    var center = s.isHorizontal() ? -transform + s.width / 2 : -transform + s.height / 2;
                    var rotate = s.isHorizontal() ? s.params.coverflow.rotate : -s.params.coverflow.rotate;
                    var translate = s.params.coverflow.depth;
                    //Each slide offset from center
                    for (var i = 0, length = s.slides.length; i < length; i++) {
                        var slide = s.slides.eq(i);
                        var slideSize = s.slidesSizesGrid[i];
                        var slideOffset = slide[0].swiperSlideOffset;
                        var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;

                        var rotateY = s.isHorizontal() ? rotate * offsetMultiplier : 0;
                        var rotateX = s.isHorizontal() ? 0 : rotate * offsetMultiplier;
                        // var rotateZ = 0
                        var translateZ = -translate * Math.abs(offsetMultiplier);

                        var translateY = s.isHorizontal() ? 0 : s.params.coverflow.stretch * offsetMultiplier;
                        var translateX = s.isHorizontal() ? s.params.coverflow.stretch * offsetMultiplier : 0;

                        //Fix for ultra small values
                        if (Math.abs(translateX) < 0.001) translateX = 0;
                        if (Math.abs(translateY) < 0.001) translateY = 0;
                        if (Math.abs(translateZ) < 0.001) translateZ = 0;
                        if (Math.abs(rotateY) < 0.001) rotateY = 0;
                        if (Math.abs(rotateX) < 0.001) rotateX = 0;

                        var slideTransform = 'translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';

                        slide.transform(slideTransform);
                        slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                        if (s.params.coverflow.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                            if (shadowAfter.length) shadowAfter[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
                        }
                    }

                    //Set correct perspective for IE10
                    if (s.browser.ie) {
                        var ws = s.wrapper[0].style;
                        ws.perspectiveOrigin = center + 'px 50%';
                    }
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                }
            }
        };

        /*=========================
          Images Lazy Loading
          ===========================*/
        s.lazy = {
            initialImageLoaded: false,
            loadImageInSlide: function (index, loadInDuplicate) {
                if (typeof index === 'undefined') return;
                if (typeof loadInDuplicate === 'undefined') loadInDuplicate = true;
                if (s.slides.length === 0) return;

                var slide = s.slides.eq(index);
                var img = slide.find('.' + s.params.lazyLoadingClass + ':not(.' + s.params.lazyStatusLoadedClass + '):not(.' + s.params.lazyStatusLoadingClass + ')');
                if (slide.hasClass(s.params.lazyLoadingClass) && !slide.hasClass(s.params.lazyStatusLoadedClass) && !slide.hasClass(s.params.lazyStatusLoadingClass)) {
                    img = img.add(slide[0]);
                }
                if (img.length === 0) return;

                img.each(function () {
                    var _img = $(this);
                    _img.addClass(s.params.lazyStatusLoadingClass);
                    var background = _img.attr('data-background');
                    var src = _img.attr('data-src'),
                        srcset = _img.attr('data-srcset'),
                        sizes = _img.attr('data-sizes');
                    s.loadImage(_img[0], src || background, srcset, sizes, false, function () {
                        if (typeof s === 'undefined' || s === null || !s) return;
                        if (background) {
                            _img.css('background-image', 'url("' + background + '")');
                            _img.removeAttr('data-background');
                        } else {
                            if (srcset) {
                                _img.attr('srcset', srcset);
                                _img.removeAttr('data-srcset');
                            }
                            if (sizes) {
                                _img.attr('sizes', sizes);
                                _img.removeAttr('data-sizes');
                            }
                            if (src) {
                                _img.attr('src', src);
                                _img.removeAttr('data-src');
                            }
                        }

                        _img.addClass(s.params.lazyStatusLoadedClass).removeClass(s.params.lazyStatusLoadingClass);
                        slide.find('.' + s.params.lazyPreloaderClass + ', .' + s.params.preloaderClass).remove();
                        if (s.params.loop && loadInDuplicate) {
                            var slideOriginalIndex = slide.attr('data-swiper-slide-index');
                            if (slide.hasClass(s.params.slideDuplicateClass)) {
                                var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');
                                s.lazy.loadImageInSlide(originalSlide.index(), false);
                            } else {
                                var duplicatedSlide = s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                                s.lazy.loadImageInSlide(duplicatedSlide.index(), false);
                            }
                        }
                        s.emit('onLazyImageReady', s, slide[0], _img[0]);
                    });

                    s.emit('onLazyImageLoad', s, slide[0], _img[0]);
                });
            },
            load: function () {
                var i;
                var slidesPerView = s.params.slidesPerView;
                if (slidesPerView === 'auto') {
                    slidesPerView = 0;
                }
                if (!s.lazy.initialImageLoaded) s.lazy.initialImageLoaded = true;
                if (s.params.watchSlidesVisibility) {
                    s.wrapper.children('.' + s.params.slideVisibleClass).each(function () {
                        s.lazy.loadImageInSlide($(this).index());
                    });
                } else {
                    if (slidesPerView > 1) {
                        for (i = s.activeIndex; i < s.activeIndex + slidesPerView; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                    } else {
                        s.lazy.loadImageInSlide(s.activeIndex);
                    }
                }
                if (s.params.lazyLoadingInPrevNext) {
                    if (slidesPerView > 1 || s.params.lazyLoadingInPrevNextAmount && s.params.lazyLoadingInPrevNextAmount > 1) {
                        var amount = s.params.lazyLoadingInPrevNextAmount;
                        var spv = slidesPerView;
                        var maxIndex = Math.min(s.activeIndex + spv + Math.max(amount, spv), s.slides.length);
                        var minIndex = Math.max(s.activeIndex - Math.max(spv, amount), 0);
                        // Next Slides
                        for (i = s.activeIndex + slidesPerView; i < maxIndex; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                        // Prev Slides
                        for (i = minIndex; i < s.activeIndex; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                    } else {
                        var nextSlide = s.wrapper.children('.' + s.params.slideNextClass);
                        if (nextSlide.length > 0) s.lazy.loadImageInSlide(nextSlide.index());

                        var prevSlide = s.wrapper.children('.' + s.params.slidePrevClass);
                        if (prevSlide.length > 0) s.lazy.loadImageInSlide(prevSlide.index());
                    }
                }
            },
            onTransitionStart: function () {
                if (s.params.lazyLoading) {
                    if (s.params.lazyLoadingOnTransitionStart || !s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded) {
                        s.lazy.load();
                    }
                }
            },
            onTransitionEnd: function () {
                if (s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart) {
                    s.lazy.load();
                }
            }
        };

        /*=========================
          Scrollbar
          ===========================*/
        s.scrollbar = {
            isTouched: false,
            setDragPosition: function (e) {
                var sb = s.scrollbar;
                var x = 0,
                    y = 0;
                var translate;
                var pointerPosition = s.isHorizontal() ? e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX || e.clientX : e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY || e.clientY;
                var position = pointerPosition - sb.track.offset()[s.isHorizontal() ? 'left' : 'top'] - sb.dragSize / 2;
                var positionMin = -s.minTranslate() * sb.moveDivider;
                var positionMax = -s.maxTranslate() * sb.moveDivider;
                if (position < positionMin) {
                    position = positionMin;
                } else if (position > positionMax) {
                    position = positionMax;
                }
                position = -position / sb.moveDivider;
                s.updateProgress(position);
                s.setWrapperTranslate(position, true);
            },
            dragStart: function (e) {
                var sb = s.scrollbar;
                sb.isTouched = true;
                e.preventDefault();
                e.stopPropagation();

                sb.setDragPosition(e);
                clearTimeout(sb.dragTimeout);

                sb.track.transition(0);
                if (s.params.scrollbarHide) {
                    sb.track.css('opacity', 1);
                }
                s.wrapper.transition(100);
                sb.drag.transition(100);
                s.emit('onScrollbarDragStart', s);
            },
            dragMove: function (e) {
                var sb = s.scrollbar;
                if (!sb.isTouched) return;
                if (e.preventDefault) e.preventDefault();else e.returnValue = false;
                sb.setDragPosition(e);
                s.wrapper.transition(0);
                sb.track.transition(0);
                sb.drag.transition(0);
                s.emit('onScrollbarDragMove', s);
            },
            dragEnd: function (e) {
                var sb = s.scrollbar;
                if (!sb.isTouched) return;
                sb.isTouched = false;
                if (s.params.scrollbarHide) {
                    clearTimeout(sb.dragTimeout);
                    sb.dragTimeout = setTimeout(function () {
                        sb.track.css('opacity', 0);
                        sb.track.transition(400);
                    }, 1000);
                }
                s.emit('onScrollbarDragEnd', s);
                if (s.params.scrollbarSnapOnRelease) {
                    s.slideReset();
                }
            },
            draggableEvents: function () {
                if (s.params.simulateTouch === false && !s.support.touch) return s.touchEventsDesktop;else return s.touchEvents;
            }(),
            enableDraggable: function () {
                var sb = s.scrollbar;
                var target = s.support.touch ? sb.track : document;
                $(sb.track).on(sb.draggableEvents.start, sb.dragStart);
                $(target).on(sb.draggableEvents.move, sb.dragMove);
                $(target).on(sb.draggableEvents.end, sb.dragEnd);
            },
            disableDraggable: function () {
                var sb = s.scrollbar;
                var target = s.support.touch ? sb.track : document;
                $(sb.track).off(sb.draggableEvents.start, sb.dragStart);
                $(target).off(sb.draggableEvents.move, sb.dragMove);
                $(target).off(sb.draggableEvents.end, sb.dragEnd);
            },
            set: function () {
                if (!s.params.scrollbar) return;
                var sb = s.scrollbar;
                sb.track = $(s.params.scrollbar);
                if (s.params.uniqueNavElements && typeof s.params.scrollbar === 'string' && sb.track.length > 1 && s.container.find(s.params.scrollbar).length === 1) {
                    sb.track = s.container.find(s.params.scrollbar);
                }
                sb.drag = sb.track.find('.swiper-scrollbar-drag');
                if (sb.drag.length === 0) {
                    sb.drag = $('<div class="swiper-scrollbar-drag"></div>');
                    sb.track.append(sb.drag);
                }
                sb.drag[0].style.width = '';
                sb.drag[0].style.height = '';
                sb.trackSize = s.isHorizontal() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight;

                sb.divider = s.size / s.virtualSize;
                sb.moveDivider = sb.divider * (sb.trackSize / s.size);
                sb.dragSize = sb.trackSize * sb.divider;

                if (s.isHorizontal()) {
                    sb.drag[0].style.width = sb.dragSize + 'px';
                } else {
                    sb.drag[0].style.height = sb.dragSize + 'px';
                }

                if (sb.divider >= 1) {
                    sb.track[0].style.display = 'none';
                } else {
                    sb.track[0].style.display = '';
                }
                if (s.params.scrollbarHide) {
                    sb.track[0].style.opacity = 0;
                }
            },
            setTranslate: function () {
                if (!s.params.scrollbar) return;
                var diff;
                var sb = s.scrollbar;
                var translate = s.translate || 0;
                var newPos;

                var newSize = sb.dragSize;
                newPos = (sb.trackSize - sb.dragSize) * s.progress;
                if (s.rtl && s.isHorizontal()) {
                    newPos = -newPos;
                    if (newPos > 0) {
                        newSize = sb.dragSize - newPos;
                        newPos = 0;
                    } else if (-newPos + sb.dragSize > sb.trackSize) {
                        newSize = sb.trackSize + newPos;
                    }
                } else {
                    if (newPos < 0) {
                        newSize = sb.dragSize + newPos;
                        newPos = 0;
                    } else if (newPos + sb.dragSize > sb.trackSize) {
                        newSize = sb.trackSize - newPos;
                    }
                }
                if (s.isHorizontal()) {
                    if (s.support.transforms3d) {
                        sb.drag.transform('translate3d(' + newPos + 'px, 0, 0)');
                    } else {
                        sb.drag.transform('translateX(' + newPos + 'px)');
                    }
                    sb.drag[0].style.width = newSize + 'px';
                } else {
                    if (s.support.transforms3d) {
                        sb.drag.transform('translate3d(0px, ' + newPos + 'px, 0)');
                    } else {
                        sb.drag.transform('translateY(' + newPos + 'px)');
                    }
                    sb.drag[0].style.height = newSize + 'px';
                }
                if (s.params.scrollbarHide) {
                    clearTimeout(sb.timeout);
                    sb.track[0].style.opacity = 1;
                    sb.timeout = setTimeout(function () {
                        sb.track[0].style.opacity = 0;
                        sb.track.transition(400);
                    }, 1000);
                }
            },
            setTransition: function (duration) {
                if (!s.params.scrollbar) return;
                s.scrollbar.drag.transition(duration);
            }
        };

        /*=========================
          Controller
          ===========================*/
        s.controller = {
            LinearSpline: function (x, y) {
                var binarySearch = function () {
                    var maxIndex, minIndex, guess;
                    return function (array, val) {
                        minIndex = -1;
                        maxIndex = array.length;
                        while (maxIndex - minIndex > 1) if (array[guess = maxIndex + minIndex >> 1] <= val) {
                            minIndex = guess;
                        } else {
                            maxIndex = guess;
                        }
                        return maxIndex;
                    };
                }();
                this.x = x;
                this.y = y;
                this.lastIndex = x.length - 1;
                // Given an x value (x2), return the expected y2 value:
                // (x1,y1) is the known point before given value,
                // (x3,y3) is the known point after given value.
                var i1, i3;
                var l = this.x.length;

                this.interpolate = function (x2) {
                    if (!x2) return 0;

                    // Get the indexes of x1 and x3 (the array indexes before and after given x2):
                    i3 = binarySearch(this.x, x2);
                    i1 = i3 - 1;

                    // We have our indexes i1 & i3, so we can calculate already:
                    // y2 := ((x2x1)  (y3y1))  (x3x1) + y1
                    return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
                };
            },
            //xxx: for now i will just save one spline function to to
            getInterpolateFunction: function (c) {
                if (!s.controller.spline) s.controller.spline = s.params.loop ? new s.controller.LinearSpline(s.slidesGrid, c.slidesGrid) : new s.controller.LinearSpline(s.snapGrid, c.snapGrid);
            },
            setTranslate: function (translate, byController) {
                var controlled = s.params.control;
                var multiplier, controlledTranslate;
                function setControlledTranslate(c) {
                    // this will create an Interpolate function based on the snapGrids
                    // x is the Grid of the scrolled scroller and y will be the controlled scroller
                    // it makes sense to create this only once and recall it for the interpolation
                    // the function does a lot of value caching for performance
                    translate = c.rtl && c.params.direction === 'horizontal' ? -s.translate : s.translate;
                    if (s.params.controlBy === 'slide') {
                        s.controller.getInterpolateFunction(c);
                        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
                        // but it did not work out
                        controlledTranslate = -s.controller.spline.interpolate(-translate);
                    }

                    if (!controlledTranslate || s.params.controlBy === 'container') {
                        multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());
                        controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();
                    }

                    if (s.params.controlInverse) {
                        controlledTranslate = c.maxTranslate() - controlledTranslate;
                    }
                    c.updateProgress(controlledTranslate);
                    c.setWrapperTranslate(controlledTranslate, false, s);
                    c.updateActiveIndex();
                }
                if (Array.isArray(controlled)) {
                    for (var i = 0; i < controlled.length; i++) {
                        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                            setControlledTranslate(controlled[i]);
                        }
                    }
                } else if (controlled instanceof Swiper && byController !== controlled) {

                    setControlledTranslate(controlled);
                }
            },
            setTransition: function (duration, byController) {
                var controlled = s.params.control;
                var i;
                function setControlledTransition(c) {
                    c.setWrapperTransition(duration, s);
                    if (duration !== 0) {
                        c.onTransitionStart();
                        c.wrapper.transitionEnd(function () {
                            if (!controlled) return;
                            if (c.params.loop && s.params.controlBy === 'slide') {
                                c.fixLoop();
                            }
                            c.onTransitionEnd();
                        });
                    }
                }
                if (Array.isArray(controlled)) {
                    for (i = 0; i < controlled.length; i++) {
                        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                            setControlledTransition(controlled[i]);
                        }
                    }
                } else if (controlled instanceof Swiper && byController !== controlled) {
                    setControlledTransition(controlled);
                }
            }
        };

        /*=========================
          Hash Navigation
          ===========================*/
        s.hashnav = {
            onHashCange: function (e, a) {
                var newHash = document.location.hash.replace('#', '');
                var activeSlideHash = s.slides.eq(s.activeIndex).attr('data-hash');
                if (newHash !== activeSlideHash) {
                    s.slideTo(s.wrapper.children('.' + s.params.slideClass + '[data-hash="' + newHash + '"]').index());
                }
            },
            attachEvents: function (detach) {
                var action = detach ? 'off' : 'on';
                $(window)[action]('hashchange', s.hashnav.onHashCange);
            },
            setHash: function () {
                if (!s.hashnav.initialized || !s.params.hashnav) return;
                if (s.params.replaceState && window.history && window.history.replaceState) {
                    window.history.replaceState(null, null, '#' + s.slides.eq(s.activeIndex).attr('data-hash') || '');
                } else {
                    var slide = s.slides.eq(s.activeIndex);
                    var hash = slide.attr('data-hash') || slide.attr('data-history');
                    document.location.hash = hash || '';
                }
            },
            init: function () {
                if (!s.params.hashnav || s.params.history) return;
                s.hashnav.initialized = true;
                var hash = document.location.hash.replace('#', '');
                if (hash) {
                    var speed = 0;
                    for (var i = 0, length = s.slides.length; i < length; i++) {
                        var slide = s.slides.eq(i);
                        var slideHash = slide.attr('data-hash') || slide.attr('data-history');
                        if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
                            var index = slide.index();
                            s.slideTo(index, speed, s.params.runCallbacksOnInit, true);
                        }
                    }
                }
                if (s.params.hashnavWatchState) s.hashnav.attachEvents();
            },
            destroy: function () {
                if (s.params.hashnavWatchState) s.hashnav.attachEvents(true);
            }
        };

        /*=========================
          History Api with fallback to Hashnav
          ===========================*/
        s.history = {
            init: function () {
                if (!s.params.history) return;
                if (!window.history || !window.history.pushState) {
                    s.params.history = false;
                    s.params.hashnav = true;
                    return;
                }
                s.history.initialized = true;
                this.paths = this.getPathValues();
                if (!this.paths.key && !this.paths.value) return;
                this.scrollToSlide(0, this.paths.value, s.params.runCallbacksOnInit);
                if (!s.params.replaceState) {
                    window.addEventListener('popstate', this.setHistoryPopState);
                }
            },
            setHistoryPopState: function () {
                s.history.paths = s.history.getPathValues();
                s.history.scrollToSlide(s.params.speed, s.history.paths.value, false);
            },
            getPathValues: function () {
                var pathArray = window.location.pathname.slice(1).split('/');
                var total = pathArray.length;
                var key = pathArray[total - 2];
                var value = pathArray[total - 1];
                return { key: key, value: value };
            },
            setHistory: function (key, index) {
                if (!s.history.initialized || !s.params.history) return;
                var slide = s.slides.eq(index);
                var value = this.slugify(slide.attr('data-history'));
                if (!window.location.pathname.includes(key)) {
                    value = key + '/' + value;
                }
                if (s.params.replaceState) {
                    window.history.replaceState(null, null, value);
                } else {
                    window.history.pushState(null, null, value);
                }
            },
            slugify: function (text) {
                return text.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
            },
            scrollToSlide: function (speed, value, runCallbacks) {
                if (value) {
                    for (var i = 0, length = s.slides.length; i < length; i++) {
                        var slide = s.slides.eq(i);
                        var slideHistory = this.slugify(slide.attr('data-history'));
                        if (slideHistory === value && !slide.hasClass(s.params.slideDuplicateClass)) {
                            var index = slide.index();
                            s.slideTo(index, speed, runCallbacks);
                        }
                    }
                } else {
                    s.slideTo(0, speed, runCallbacks);
                }
            }
        };

        /*=========================
          Keyboard Control
          ===========================*/
        function handleKeyboard(e) {
            if (e.originalEvent) e = e.originalEvent; //jquery fix
            var kc = e.keyCode || e.charCode;
            // Directions locks
            if (!s.params.allowSwipeToNext && (s.isHorizontal() && kc === 39 || !s.isHorizontal() && kc === 40)) {
                return false;
            }
            if (!s.params.allowSwipeToPrev && (s.isHorizontal() && kc === 37 || !s.isHorizontal() && kc === 38)) {
                return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return;
            }
            if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
                return;
            }
            if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
                var inView = false;
                //Check that swiper should be inside of visible area of window
                if (s.container.parents('.' + s.params.slideClass).length > 0 && s.container.parents('.' + s.params.slideActiveClass).length === 0) {
                    return;
                }
                var windowScroll = {
                    left: window.pageXOffset,
                    top: window.pageYOffset
                };
                var windowWidth = window.innerWidth;
                var windowHeight = window.innerHeight;
                var swiperOffset = s.container.offset();
                if (s.rtl) swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;
                var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + s.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + s.height], [swiperOffset.left + s.width, swiperOffset.top + s.height]];
                for (var i = 0; i < swiperCoord.length; i++) {
                    var point = swiperCoord[i];
                    if (point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth && point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight) {
                        inView = true;
                    }
                }
                if (!inView) return;
            }
            if (s.isHorizontal()) {
                if (kc === 37 || kc === 39) {
                    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
                }
                if (kc === 39 && !s.rtl || kc === 37 && s.rtl) s.slideNext();
                if (kc === 37 && !s.rtl || kc === 39 && s.rtl) s.slidePrev();
            } else {
                if (kc === 38 || kc === 40) {
                    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
                }
                if (kc === 40) s.slideNext();
                if (kc === 38) s.slidePrev();
            }
            s.emit('onKeyPress', s, kc);
        }
        s.disableKeyboardControl = function () {
            s.params.keyboardControl = false;
            $(document).off('keydown', handleKeyboard);
        };
        s.enableKeyboardControl = function () {
            s.params.keyboardControl = true;
            $(document).on('keydown', handleKeyboard);
        };

        /*=========================
          Mousewheel Control
          ===========================*/
        s.mousewheel = {
            event: false,
            lastScrollTime: new window.Date().getTime()
        };
        function isEventSupported() {
            var eventName = 'onwheel';
            var isSupported = eventName in document;

            if (!isSupported) {
                var element = document.createElement('div');
                element.setAttribute(eventName, 'return;');
                isSupported = typeof element[eventName] === 'function';
            }

            if (!isSupported && document.implementation && document.implementation.hasFeature &&
            // always returns true in newer browsers as per the standard.
            // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
            document.implementation.hasFeature('', '') !== true) {
                // This is the only way to test support for the `wheel` event in IE9+.
                isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
            }

            return isSupported;
        }
        /**
         * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
         * complicated, thus this doc is long and (hopefully) detailed enough to answer
         * your questions.
         *
         * If you need to react to the mouse wheel in a predictable way, this code is
         * like your bestest friend. * hugs *
         *
         * As of today, there are 4 DOM event types you can listen to:
         *
         *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
         *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
         *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
         *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
         *
         * So what to do?  The is the best:
         *
         *   normalizeWheel.getEventType();
         *
         * In your event callback, use this code to get sane interpretation of the
         * deltas.  This code will return an object with properties:
         *
         *   spinX   -- normalized spin speed (use for zoom) - x plane
         *   spinY   -- " - y plane
         *   pixelX  -- normalized distance (to pixels) - x plane
         *   pixelY  -- " - y plane
         *
         * Wheel values are provided by the browser assuming you are using the wheel to
         * scroll a web page by a number of lines or pixels (or pages).  Values can vary
         * significantly on different platforms and browsers, forgetting that you can
         * scroll at different speeds.  Some devices (like trackpads) emit more events
         * at smaller increments with fine granularity, and some emit massive jumps with
         * linear speed or acceleration.
         *
         * This code does its best to normalize the deltas for you:
         *
         *   - spin is trying to normalize how far the wheel was spun (or trackpad
         *     dragged).  This is super useful for zoom support where you want to
         *     throw away the chunky scroll steps on the PC and make those equal to
         *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
         *     resolve a single slow step on a wheel to 1.
         *
         *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
         *     get the crazy differences between browsers, but at least it'll be in
         *     pixels!
         *
         *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
         *     should translate to positive value zooming IN, negative zooming OUT.
         *     This matches the newer 'wheel' event.
         *
         * Why are there spinX, spinY (or pixels)?
         *
         *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
         *     with a mouse.  It results in side-scrolling in the browser by default.
         *
         *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
         *
         *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
         *     probably is by browsers in conjunction with fancy 3D controllers .. but
         *     you know.
         *
         * Implementation info:
         *
         * Examples of 'wheel' event if you scroll slowly (down) by one step with an
         * average mouse:
         *
         *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
         *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
         *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
         *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
         *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
         *
         * On the trackpad:
         *
         *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
         *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
         *
         * On other/older browsers.. it's more complicated as there can be multiple and
         * also missing delta values.
         *
         * The 'wheel' event is more standard:
         *
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
         *
         * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
         * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
         * backward compatibility with older events.  Those other values help us
         * better normalize spin speed.  Example of what the browsers provide:
         *
         *                          | event.wheelDelta | event.detail
         *        ------------------+------------------+--------------
         *          Safari v5/OS X  |       -120       |       0
         *          Safari v5/Win7  |       -120       |       0
         *         Chrome v17/OS X  |       -120       |       0
         *         Chrome v17/Win7  |       -120       |       0
         *                IE9/Win7  |       -120       |   undefined
         *         Firefox v4/OS X  |     undefined    |       1
         *         Firefox v4/Win7  |     undefined    |       3
         *
         */
        function normalizeWheel( /*object*/event) /*object*/{
            // Reasonable defaults
            var PIXEL_STEP = 10;
            var LINE_HEIGHT = 40;
            var PAGE_HEIGHT = 800;

            var sX = 0,
                sY = 0,
                // spinX, spinY
            pX = 0,
                pY = 0; // pixelX, pixelY

            // Legacy
            if ('detail' in event) {
                sY = event.detail;
            }
            if ('wheelDelta' in event) {
                sY = -event.wheelDelta / 120;
            }
            if ('wheelDeltaY' in event) {
                sY = -event.wheelDeltaY / 120;
            }
            if ('wheelDeltaX' in event) {
                sX = -event.wheelDeltaX / 120;
            }

            // side scrolling on FF with DOMMouseScroll
            if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
                sX = sY;
                sY = 0;
            }

            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;

            if ('deltaY' in event) {
                pY = event.deltaY;
            }
            if ('deltaX' in event) {
                pX = event.deltaX;
            }

            if ((pX || pY) && event.deltaMode) {
                if (event.deltaMode === 1) {
                    // delta in LINE units
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {
                    // delta in PAGE units
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            }

            // Fall-back if spin cannot be determined
            if (pX && !sX) {
                sX = pX < 1 ? -1 : 1;
            }
            if (pY && !sY) {
                sY = pY < 1 ? -1 : 1;
            }

            return {
                spinX: sX,
                spinY: sY,
                pixelX: pX,
                pixelY: pY
            };
        }
        if (s.params.mousewheelControl) {
            /**
             * The best combination if you prefer spinX + spinY normalization.  It favors
             * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
             * 'wheel' event, making spin speed determination impossible.
             */
            s.mousewheel.event = navigator.userAgent.indexOf('firefox') > -1 ? 'DOMMouseScroll' : isEventSupported() ? 'wheel' : 'mousewheel';
        }
        function handleMousewheel(e) {
            if (e.originalEvent) e = e.originalEvent; //jquery fix
            var delta = 0;
            var rtlFactor = s.rtl ? -1 : 1;

            var data = normalizeWheel(e);

            if (s.params.mousewheelForceToAxis) {
                if (s.isHorizontal()) {
                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;else return;
                } else {
                    if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;else return;
                }
            } else {
                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
            }

            if (delta === 0) return;

            if (s.params.mousewheelInvert) delta = -delta;

            if (!s.params.freeMode) {
                if (new window.Date().getTime() - s.mousewheel.lastScrollTime > 60) {
                    if (delta < 0) {
                        if ((!s.isEnd || s.params.loop) && !s.animating) {
                            s.slideNext();
                            s.emit('onScroll', s, e);
                        } else if (s.params.mousewheelReleaseOnEdges) return true;
                    } else {
                        if ((!s.isBeginning || s.params.loop) && !s.animating) {
                            s.slidePrev();
                            s.emit('onScroll', s, e);
                        } else if (s.params.mousewheelReleaseOnEdges) return true;
                    }
                }
                s.mousewheel.lastScrollTime = new window.Date().getTime();
            } else {
                //Freemode or scrollContainer:
                var position = s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;
                var wasBeginning = s.isBeginning,
                    wasEnd = s.isEnd;

                if (position >= s.minTranslate()) position = s.minTranslate();
                if (position <= s.maxTranslate()) position = s.maxTranslate();

                s.setWrapperTransition(0);
                s.setWrapperTranslate(position);
                s.updateProgress();
                s.updateActiveIndex();

                if (!wasBeginning && s.isBeginning || !wasEnd && s.isEnd) {
                    s.updateClasses();
                }

                if (s.params.freeModeSticky) {
                    clearTimeout(s.mousewheel.timeout);
                    s.mousewheel.timeout = setTimeout(function () {
                        s.slideReset();
                    }, 300);
                } else {
                    if (s.params.lazyLoading && s.lazy) {
                        s.lazy.load();
                    }
                }
                // Emit event
                s.emit('onScroll', s, e);

                // Stop autoplay
                if (s.params.autoplay && s.params.autoplayDisableOnInteraction) s.stopAutoplay();

                // Return page scroll on edge positions
                if (position === 0 || position === s.maxTranslate()) return;
            }

            if (e.preventDefault) e.preventDefault();else e.returnValue = false;
            return false;
        }
        s.disableMousewheelControl = function () {
            if (!s.mousewheel.event) return false;
            var target = s.container;
            if (s.params.mousewheelEventsTarged !== 'container') {
                target = $(s.params.mousewheelEventsTarged);
            }
            target.off(s.mousewheel.event, handleMousewheel);
            s.params.mousewheelControl = false;
            return true;
        };

        s.enableMousewheelControl = function () {
            if (!s.mousewheel.event) return false;
            var target = s.container;
            if (s.params.mousewheelEventsTarged !== 'container') {
                target = $(s.params.mousewheelEventsTarged);
            }
            target.on(s.mousewheel.event, handleMousewheel);
            s.params.mousewheelControl = true;
            return true;
        };

        /*=========================
          Parallax
          ===========================*/
        function setParallaxTransform(el, progress) {
            el = $(el);
            var p, pX, pY;
            var rtlFactor = s.rtl ? -1 : 1;

            p = el.attr('data-swiper-parallax') || '0';
            pX = el.attr('data-swiper-parallax-x');
            pY = el.attr('data-swiper-parallax-y');
            if (pX || pY) {
                pX = pX || '0';
                pY = pY || '0';
            } else {
                if (s.isHorizontal()) {
                    pX = p;
                    pY = '0';
                } else {
                    pY = p;
                    pX = '0';
                }
            }

            if (pX.indexOf('%') >= 0) {
                pX = parseInt(pX, 10) * progress * rtlFactor + '%';
            } else {
                pX = pX * progress * rtlFactor + 'px';
            }
            if (pY.indexOf('%') >= 0) {
                pY = parseInt(pY, 10) * progress + '%';
            } else {
                pY = pY * progress + 'px';
            }

            el.transform('translate3d(' + pX + ', ' + pY + ',0px)');
        }
        s.parallax = {
            setTranslate: function () {
                s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
                    setParallaxTransform(this, s.progress);
                });
                s.slides.each(function () {
                    var slide = $(this);
                    slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
                        var progress = Math.min(Math.max(slide[0].progress, -1), 1);
                        setParallaxTransform(this, progress);
                    });
                });
            },
            setTransition: function (duration) {
                if (typeof duration === 'undefined') duration = s.params.speed;
                s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
                    var el = $(this);
                    var parallaxDuration = parseInt(el.attr('data-swiper-parallax-duration'), 10) || duration;
                    if (duration === 0) parallaxDuration = 0;
                    el.transition(parallaxDuration);
                });
            }
        };

        /*=========================
          Zoom
          ===========================*/
        s.zoom = {
            // "Global" Props
            scale: 1,
            currentScale: 1,
            isScaling: false,
            gesture: {
                slide: undefined,
                slideWidth: undefined,
                slideHeight: undefined,
                image: undefined,
                imageWrap: undefined,
                zoomMax: s.params.zoomMax
            },
            image: {
                isTouched: undefined,
                isMoved: undefined,
                currentX: undefined,
                currentY: undefined,
                minX: undefined,
                minY: undefined,
                maxX: undefined,
                maxY: undefined,
                width: undefined,
                height: undefined,
                startX: undefined,
                startY: undefined,
                touchesStart: {},
                touchesCurrent: {}
            },
            velocity: {
                x: undefined,
                y: undefined,
                prevPositionX: undefined,
                prevPositionY: undefined,
                prevTime: undefined
            },
            // Calc Scale From Multi-touches
            getDistanceBetweenTouches: function (e) {
                if (e.targetTouches.length < 2) return 1;
                var x1 = e.targetTouches[0].pageX,
                    y1 = e.targetTouches[0].pageY,
                    x2 = e.targetTouches[1].pageX,
                    y2 = e.targetTouches[1].pageY;
                var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                return distance;
            },
            // Events
            onGestureStart: function (e) {
                var z = s.zoom;
                if (!s.support.gestures) {
                    if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
                        return;
                    }
                    z.gesture.scaleStart = z.getDistanceBetweenTouches(e);
                }
                if (!z.gesture.slide || !z.gesture.slide.length) {
                    z.gesture.slide = $(this);
                    if (z.gesture.slide.length === 0) z.gesture.slide = s.slides.eq(s.activeIndex);
                    z.gesture.image = z.gesture.slide.find('img, svg, canvas');
                    z.gesture.imageWrap = z.gesture.image.parent('.' + s.params.zoomContainerClass);
                    z.gesture.zoomMax = z.gesture.imageWrap.attr('data-swiper-zoom') || s.params.zoomMax;
                    if (z.gesture.imageWrap.length === 0) {
                        z.gesture.image = undefined;
                        return;
                    }
                }
                z.gesture.image.transition(0);
                z.isScaling = true;
            },
            onGestureChange: function (e) {
                var z = s.zoom;
                if (!s.support.gestures) {
                    if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
                        return;
                    }
                    z.gesture.scaleMove = z.getDistanceBetweenTouches(e);
                }
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                if (s.support.gestures) {
                    z.scale = e.scale * z.currentScale;
                } else {
                    z.scale = z.gesture.scaleMove / z.gesture.scaleStart * z.currentScale;
                }
                if (z.scale > z.gesture.zoomMax) {
                    z.scale = z.gesture.zoomMax - 1 + Math.pow(z.scale - z.gesture.zoomMax + 1, 0.5);
                }
                if (z.scale < s.params.zoomMin) {
                    z.scale = s.params.zoomMin + 1 - Math.pow(s.params.zoomMin - z.scale + 1, 0.5);
                }
                z.gesture.image.transform('translate3d(0,0,0) scale(' + z.scale + ')');
            },
            onGestureEnd: function (e) {
                var z = s.zoom;
                if (!s.support.gestures) {
                    if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2) {
                        return;
                    }
                }
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                z.scale = Math.max(Math.min(z.scale, z.gesture.zoomMax), s.params.zoomMin);
                z.gesture.image.transition(s.params.speed).transform('translate3d(0,0,0) scale(' + z.scale + ')');
                z.currentScale = z.scale;
                z.isScaling = false;
                if (z.scale === 1) z.gesture.slide = undefined;
            },
            onTouchStart: function (s, e) {
                var z = s.zoom;
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                if (z.image.isTouched) return;
                if (s.device.os === 'android') e.preventDefault();
                z.image.isTouched = true;
                z.image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
                z.image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
            },
            onTouchMove: function (e) {
                var z = s.zoom;
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                s.allowClick = false;
                if (!z.image.isTouched || !z.gesture.slide) return;

                if (!z.image.isMoved) {
                    z.image.width = z.gesture.image[0].offsetWidth;
                    z.image.height = z.gesture.image[0].offsetHeight;
                    z.image.startX = s.getTranslate(z.gesture.imageWrap[0], 'x') || 0;
                    z.image.startY = s.getTranslate(z.gesture.imageWrap[0], 'y') || 0;
                    z.gesture.slideWidth = z.gesture.slide[0].offsetWidth;
                    z.gesture.slideHeight = z.gesture.slide[0].offsetHeight;
                    z.gesture.imageWrap.transition(0);
                    if (s.rtl) z.image.startX = -z.image.startX;
                    if (s.rtl) z.image.startY = -z.image.startY;
                }
                // Define if we need image drag
                var scaledWidth = z.image.width * z.scale;
                var scaledHeight = z.image.height * z.scale;

                if (scaledWidth < z.gesture.slideWidth && scaledHeight < z.gesture.slideHeight) return;

                z.image.minX = Math.min(z.gesture.slideWidth / 2 - scaledWidth / 2, 0);
                z.image.maxX = -z.image.minX;
                z.image.minY = Math.min(z.gesture.slideHeight / 2 - scaledHeight / 2, 0);
                z.image.maxY = -z.image.minY;

                z.image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                z.image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

                if (!z.image.isMoved && !z.isScaling) {
                    if (s.isHorizontal() && Math.floor(z.image.minX) === Math.floor(z.image.startX) && z.image.touchesCurrent.x < z.image.touchesStart.x || Math.floor(z.image.maxX) === Math.floor(z.image.startX) && z.image.touchesCurrent.x > z.image.touchesStart.x) {
                        z.image.isTouched = false;
                        return;
                    } else if (!s.isHorizontal() && Math.floor(z.image.minY) === Math.floor(z.image.startY) && z.image.touchesCurrent.y < z.image.touchesStart.y || Math.floor(z.image.maxY) === Math.floor(z.image.startY) && z.image.touchesCurrent.y > z.image.touchesStart.y) {
                        z.image.isTouched = false;
                        return;
                    }
                }
                e.preventDefault();
                e.stopPropagation();

                z.image.isMoved = true;
                z.image.currentX = z.image.touchesCurrent.x - z.image.touchesStart.x + z.image.startX;
                z.image.currentY = z.image.touchesCurrent.y - z.image.touchesStart.y + z.image.startY;

                if (z.image.currentX < z.image.minX) {
                    z.image.currentX = z.image.minX + 1 - Math.pow(z.image.minX - z.image.currentX + 1, 0.8);
                }
                if (z.image.currentX > z.image.maxX) {
                    z.image.currentX = z.image.maxX - 1 + Math.pow(z.image.currentX - z.image.maxX + 1, 0.8);
                }

                if (z.image.currentY < z.image.minY) {
                    z.image.currentY = z.image.minY + 1 - Math.pow(z.image.minY - z.image.currentY + 1, 0.8);
                }
                if (z.image.currentY > z.image.maxY) {
                    z.image.currentY = z.image.maxY - 1 + Math.pow(z.image.currentY - z.image.maxY + 1, 0.8);
                }

                //Velocity
                if (!z.velocity.prevPositionX) z.velocity.prevPositionX = z.image.touchesCurrent.x;
                if (!z.velocity.prevPositionY) z.velocity.prevPositionY = z.image.touchesCurrent.y;
                if (!z.velocity.prevTime) z.velocity.prevTime = Date.now();
                z.velocity.x = (z.image.touchesCurrent.x - z.velocity.prevPositionX) / (Date.now() - z.velocity.prevTime) / 2;
                z.velocity.y = (z.image.touchesCurrent.y - z.velocity.prevPositionY) / (Date.now() - z.velocity.prevTime) / 2;
                if (Math.abs(z.image.touchesCurrent.x - z.velocity.prevPositionX) < 2) z.velocity.x = 0;
                if (Math.abs(z.image.touchesCurrent.y - z.velocity.prevPositionY) < 2) z.velocity.y = 0;
                z.velocity.prevPositionX = z.image.touchesCurrent.x;
                z.velocity.prevPositionY = z.image.touchesCurrent.y;
                z.velocity.prevTime = Date.now();

                z.gesture.imageWrap.transform('translate3d(' + z.image.currentX + 'px, ' + z.image.currentY + 'px,0)');
            },
            onTouchEnd: function (s, e) {
                var z = s.zoom;
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                if (!z.image.isTouched || !z.image.isMoved) {
                    z.image.isTouched = false;
                    z.image.isMoved = false;
                    return;
                }
                z.image.isTouched = false;
                z.image.isMoved = false;
                var momentumDurationX = 300;
                var momentumDurationY = 300;
                var momentumDistanceX = z.velocity.x * momentumDurationX;
                var newPositionX = z.image.currentX + momentumDistanceX;
                var momentumDistanceY = z.velocity.y * momentumDurationY;
                var newPositionY = z.image.currentY + momentumDistanceY;

                //Fix duration
                if (z.velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - z.image.currentX) / z.velocity.x);
                if (z.velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - z.image.currentY) / z.velocity.y);
                var momentumDuration = Math.max(momentumDurationX, momentumDurationY);

                z.image.currentX = newPositionX;
                z.image.currentY = newPositionY;

                // Define if we need image drag
                var scaledWidth = z.image.width * z.scale;
                var scaledHeight = z.image.height * z.scale;
                z.image.minX = Math.min(z.gesture.slideWidth / 2 - scaledWidth / 2, 0);
                z.image.maxX = -z.image.minX;
                z.image.minY = Math.min(z.gesture.slideHeight / 2 - scaledHeight / 2, 0);
                z.image.maxY = -z.image.minY;
                z.image.currentX = Math.max(Math.min(z.image.currentX, z.image.maxX), z.image.minX);
                z.image.currentY = Math.max(Math.min(z.image.currentY, z.image.maxY), z.image.minY);

                z.gesture.imageWrap.transition(momentumDuration).transform('translate3d(' + z.image.currentX + 'px, ' + z.image.currentY + 'px,0)');
            },
            onTransitionEnd: function (s) {
                var z = s.zoom;
                if (z.gesture.slide && s.previousIndex !== s.activeIndex) {
                    z.gesture.image.transform('translate3d(0,0,0) scale(1)');
                    z.gesture.imageWrap.transform('translate3d(0,0,0)');
                    z.gesture.slide = z.gesture.image = z.gesture.imageWrap = undefined;
                    z.scale = z.currentScale = 1;
                }
            },
            // Toggle Zoom
            toggleZoom: function (s, e) {
                var z = s.zoom;
                if (!z.gesture.slide) {
                    z.gesture.slide = s.clickedSlide ? $(s.clickedSlide) : s.slides.eq(s.activeIndex);
                    z.gesture.image = z.gesture.slide.find('img, svg, canvas');
                    z.gesture.imageWrap = z.gesture.image.parent('.' + s.params.zoomContainerClass);
                }
                if (!z.gesture.image || z.gesture.image.length === 0) return;

                var touchX, touchY, offsetX, offsetY, diffX, diffY, translateX, translateY, imageWidth, imageHeight, scaledWidth, scaledHeight, translateMinX, translateMinY, translateMaxX, translateMaxY, slideWidth, slideHeight;

                if (typeof z.image.touchesStart.x === 'undefined' && e) {
                    touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
                    touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
                } else {
                    touchX = z.image.touchesStart.x;
                    touchY = z.image.touchesStart.y;
                }

                if (z.scale && z.scale !== 1) {
                    // Zoom Out
                    z.scale = z.currentScale = 1;
                    z.gesture.imageWrap.transition(300).transform('translate3d(0,0,0)');
                    z.gesture.image.transition(300).transform('translate3d(0,0,0) scale(1)');
                    z.gesture.slide = undefined;
                } else {
                    // Zoom In
                    z.scale = z.currentScale = z.gesture.imageWrap.attr('data-swiper-zoom') || s.params.zoomMax;
                    if (e) {
                        slideWidth = z.gesture.slide[0].offsetWidth;
                        slideHeight = z.gesture.slide[0].offsetHeight;
                        offsetX = z.gesture.slide.offset().left;
                        offsetY = z.gesture.slide.offset().top;
                        diffX = offsetX + slideWidth / 2 - touchX;
                        diffY = offsetY + slideHeight / 2 - touchY;

                        imageWidth = z.gesture.image[0].offsetWidth;
                        imageHeight = z.gesture.image[0].offsetHeight;
                        scaledWidth = imageWidth * z.scale;
                        scaledHeight = imageHeight * z.scale;

                        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
                        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
                        translateMaxX = -translateMinX;
                        translateMaxY = -translateMinY;

                        translateX = diffX * z.scale;
                        translateY = diffY * z.scale;

                        if (translateX < translateMinX) {
                            translateX = translateMinX;
                        }
                        if (translateX > translateMaxX) {
                            translateX = translateMaxX;
                        }

                        if (translateY < translateMinY) {
                            translateY = translateMinY;
                        }
                        if (translateY > translateMaxY) {
                            translateY = translateMaxY;
                        }
                    } else {
                        translateX = 0;
                        translateY = 0;
                    }
                    z.gesture.imageWrap.transition(300).transform('translate3d(' + translateX + 'px, ' + translateY + 'px,0)');
                    z.gesture.image.transition(300).transform('translate3d(0,0,0) scale(' + z.scale + ')');
                }
            },
            // Attach/Detach Events
            attachEvents: function (detach) {
                var action = detach ? 'off' : 'on';

                if (s.params.zoom) {
                    var target = s.slides;
                    var passiveListener = s.touchEvents.start === 'touchstart' && s.support.passiveListener && s.params.passiveListeners ? { passive: true, capture: false } : false;
                    // Scale image
                    if (s.support.gestures) {
                        s.slides[action]('gesturestart', s.zoom.onGestureStart, passiveListener);
                        s.slides[action]('gesturechange', s.zoom.onGestureChange, passiveListener);
                        s.slides[action]('gestureend', s.zoom.onGestureEnd, passiveListener);
                    } else if (s.touchEvents.start === 'touchstart') {
                        s.slides[action](s.touchEvents.start, s.zoom.onGestureStart, passiveListener);
                        s.slides[action](s.touchEvents.move, s.zoom.onGestureChange, passiveListener);
                        s.slides[action](s.touchEvents.end, s.zoom.onGestureEnd, passiveListener);
                    }

                    // Move image
                    s[action]('touchStart', s.zoom.onTouchStart);
                    s.slides.each(function (index, slide) {
                        if ($(slide).find('.' + s.params.zoomContainerClass).length > 0) {
                            $(slide)[action](s.touchEvents.move, s.zoom.onTouchMove);
                        }
                    });
                    s[action]('touchEnd', s.zoom.onTouchEnd);

                    // Scale Out
                    s[action]('transitionEnd', s.zoom.onTransitionEnd);
                    if (s.params.zoomToggle) {
                        s.on('doubleTap', s.zoom.toggleZoom);
                    }
                }
            },
            init: function () {
                s.zoom.attachEvents();
            },
            destroy: function () {
                s.zoom.attachEvents(true);
            }
        };

        /*=========================
          Plugins API. Collect all and init all plugins
          ===========================*/
        s._plugins = [];
        for (var plugin in s.plugins) {
            var p = s.plugins[plugin](s, s.params[plugin]);
            if (p) s._plugins.push(p);
        }
        // Method to call all plugins event/method
        s.callPlugins = function (eventName) {
            for (var i = 0; i < s._plugins.length; i++) {
                if (eventName in s._plugins[i]) {
                    s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }
            }
        };

        /*=========================
          Events/Callbacks/Plugins Emitter
          ===========================*/
        function normalizeEventName(eventName) {
            if (eventName.indexOf('on') !== 0) {
                if (eventName[0] !== eventName[0].toUpperCase()) {
                    eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);
                } else {
                    eventName = 'on' + eventName;
                }
            }
            return eventName;
        }
        s.emitterEventListeners = {};
        s.emit = function (eventName) {
            // Trigger callbacks
            if (s.params[eventName]) {
                s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
            }
            var i;
            // Trigger events
            if (s.emitterEventListeners[eventName]) {
                for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
                    s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }
            }
            // Trigger plugins
            if (s.callPlugins) s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        };
        s.on = function (eventName, handler) {
            eventName = normalizeEventName(eventName);
            if (!s.emitterEventListeners[eventName]) s.emitterEventListeners[eventName] = [];
            s.emitterEventListeners[eventName].push(handler);
            return s;
        };
        s.off = function (eventName, handler) {
            var i;
            eventName = normalizeEventName(eventName);
            if (typeof handler === 'undefined') {
                // Remove all handlers for such event
                s.emitterEventListeners[eventName] = [];
                return s;
            }
            if (!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0) return;
            for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
                if (s.emitterEventListeners[eventName][i] === handler) s.emitterEventListeners[eventName].splice(i, 1);
            }
            return s;
        };
        s.once = function (eventName, handler) {
            eventName = normalizeEventName(eventName);
            var _handler = function () {
                handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                s.off(eventName, _handler);
            };
            s.on(eventName, _handler);
            return s;
        };

        // Accessibility tools
        s.a11y = {
            makeFocusable: function ($el) {
                $el.attr('tabIndex', '0');
                return $el;
            },
            addRole: function ($el, role) {
                $el.attr('role', role);
                return $el;
            },

            addLabel: function ($el, label) {
                $el.attr('aria-label', label);
                return $el;
            },

            disable: function ($el) {
                $el.attr('aria-disabled', true);
                return $el;
            },

            enable: function ($el) {
                $el.attr('aria-disabled', false);
                return $el;
            },

            onEnterKey: function (event) {
                if (event.keyCode !== 13) return;
                if ($(event.target).is(s.params.nextButton)) {
                    s.onClickNext(event);
                    if (s.isEnd) {
                        s.a11y.notify(s.params.lastSlideMessage);
                    } else {
                        s.a11y.notify(s.params.nextSlideMessage);
                    }
                } else if ($(event.target).is(s.params.prevButton)) {
                    s.onClickPrev(event);
                    if (s.isBeginning) {
                        s.a11y.notify(s.params.firstSlideMessage);
                    } else {
                        s.a11y.notify(s.params.prevSlideMessage);
                    }
                }
                if ($(event.target).is('.' + s.params.bulletClass)) {
                    $(event.target)[0].click();
                }
            },

            liveRegion: $('<span class="' + s.params.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>'),

            notify: function (message) {
                var notification = s.a11y.liveRegion;
                if (notification.length === 0) return;
                notification.html('');
                notification.html(message);
            },
            init: function () {
                // Setup accessibility
                if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                    s.a11y.makeFocusable(s.nextButton);
                    s.a11y.addRole(s.nextButton, 'button');
                    s.a11y.addLabel(s.nextButton, s.params.nextSlideMessage);
                }
                if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                    s.a11y.makeFocusable(s.prevButton);
                    s.a11y.addRole(s.prevButton, 'button');
                    s.a11y.addLabel(s.prevButton, s.params.prevSlideMessage);
                }

                $(s.container).append(s.a11y.liveRegion);
            },
            initPagination: function () {
                if (s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length) {
                    s.bullets.each(function () {
                        var bullet = $(this);
                        s.a11y.makeFocusable(bullet);
                        s.a11y.addRole(bullet, 'button');
                        s.a11y.addLabel(bullet, s.params.paginationBulletMessage.replace(/{{index}}/, bullet.index() + 1));
                    });
                }
            },
            destroy: function () {
                if (s.a11y.liveRegion && s.a11y.liveRegion.length > 0) s.a11y.liveRegion.remove();
            }
        };

        /*=========================
          Init/Destroy
          ===========================*/
        s.init = function () {
            if (s.params.loop) s.createLoop();
            s.updateContainerSize();
            s.updateSlidesSize();
            s.updatePagination();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
                if (s.params.scrollbarDraggable) {
                    s.scrollbar.enableDraggable();
                }
            }
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                if (!s.params.loop) s.updateProgress();
                s.effects[s.params.effect].setTranslate();
            }
            if (s.params.loop) {
                s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit);
            } else {
                s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit);
                if (s.params.initialSlide === 0) {
                    if (s.parallax && s.params.parallax) s.parallax.setTranslate();
                    if (s.lazy && s.params.lazyLoading) {
                        s.lazy.load();
                        s.lazy.initialImageLoaded = true;
                    }
                }
            }
            s.attachEvents();
            if (s.params.observer && s.support.observer) {
                s.initObservers();
            }
            if (s.params.preloadImages && !s.params.lazyLoading) {
                s.preloadImages();
            }
            if (s.params.zoom && s.zoom) {
                s.zoom.init();
            }
            if (s.params.autoplay) {
                s.startAutoplay();
            }
            if (s.params.keyboardControl) {
                if (s.enableKeyboardControl) s.enableKeyboardControl();
            }
            if (s.params.mousewheelControl) {
                if (s.enableMousewheelControl) s.enableMousewheelControl();
            }
            // Deprecated hashnavReplaceState changed to replaceState for use in hashnav and history
            if (s.params.hashnavReplaceState) {
                s.params.replaceState = s.params.hashnavReplaceState;
            }
            if (s.params.history) {
                if (s.history) s.history.init();
            }
            if (s.params.hashnav) {
                if (s.hashnav) s.hashnav.init();
            }
            if (s.params.a11y && s.a11y) s.a11y.init();
            s.emit('onInit', s);
        };

        // Cleanup dynamic styles
        s.cleanupStyles = function () {
            // Container
            s.container.removeClass(s.classNames.join(' ')).removeAttr('style');

            // Wrapper
            s.wrapper.removeAttr('style');

            // Slides
            if (s.slides && s.slides.length) {
                s.slides.removeClass([s.params.slideVisibleClass, s.params.slideActiveClass, s.params.slideNextClass, s.params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-column').removeAttr('data-swiper-row');
            }

            // Pagination/Bullets
            if (s.paginationContainer && s.paginationContainer.length) {
                s.paginationContainer.removeClass(s.params.paginationHiddenClass);
            }
            if (s.bullets && s.bullets.length) {
                s.bullets.removeClass(s.params.bulletActiveClass);
            }

            // Buttons
            if (s.params.prevButton) $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
            if (s.params.nextButton) $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);

            // Scrollbar
            if (s.params.scrollbar && s.scrollbar) {
                if (s.scrollbar.track && s.scrollbar.track.length) s.scrollbar.track.removeAttr('style');
                if (s.scrollbar.drag && s.scrollbar.drag.length) s.scrollbar.drag.removeAttr('style');
            }
        };

        // Destroy
        s.destroy = function (deleteInstance, cleanupStyles) {
            // Detach evebts
            s.detachEvents();
            // Stop autoplay
            s.stopAutoplay();
            // Disable draggable
            if (s.params.scrollbar && s.scrollbar) {
                if (s.params.scrollbarDraggable) {
                    s.scrollbar.disableDraggable();
                }
            }
            // Destroy loop
            if (s.params.loop) {
                s.destroyLoop();
            }
            // Cleanup styles
            if (cleanupStyles) {
                s.cleanupStyles();
            }
            // Disconnect observer
            s.disconnectObservers();

            // Destroy zoom
            if (s.params.zoom && s.zoom) {
                s.zoom.destroy();
            }
            // Disable keyboard/mousewheel
            if (s.params.keyboardControl) {
                if (s.disableKeyboardControl) s.disableKeyboardControl();
            }
            if (s.params.mousewheelControl) {
                if (s.disableMousewheelControl) s.disableMousewheelControl();
            }
            // Disable a11y
            if (s.params.a11y && s.a11y) s.a11y.destroy();
            // Delete history popstate
            if (s.params.history && !s.params.replaceState) {
                window.removeEventListener('popstate', s.history.setHistoryPopState);
            }
            if (s.params.hashnav && s.hashnav) {
                s.hashnav.destroy();
            }
            // Destroy callback
            s.emit('onDestroy');
            // Delete instance
            if (deleteInstance !== false) s = null;
        };

        s.init();

        // Return swiper instance
        return s;
    };

    /*==================================================
        Prototype
    ====================================================*/
    Swiper.prototype = {
        isSafari: function () {
            var ua = window.navigator.userAgent.toLowerCase();
            return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
        }(),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),
        isArray: function (arr) {
            return Object.prototype.toString.apply(arr) === '[object Array]';
        },
        /*==================================================
        Browser
        ====================================================*/
        browser: {
            ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
            ieTouch: window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1,
            lteIE9: function () {
                // create temporary DIV
                var div = document.createElement('div');
                // add content to tmp DIV which is wrapped into the IE HTML conditional statement
                div.innerHTML = '<!--[if lte IE 9]><i></i><![endif]-->';
                // return true / false value based on what will browser render
                return div.getElementsByTagName('i').length === 1;
            }()
        },
        /*==================================================
        Devices
        ====================================================*/
        device: function () {
            var ua = window.navigator.userAgent;
            var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            return {
                ios: ipad || iphone || ipod,
                android: android
            };
        }(),
        /*==================================================
        Feature Detection
        ====================================================*/
        support: {
            touch: window.Modernizr && Modernizr.touch === true || function () {
                return !!('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch);
            }(),

            transforms3d: window.Modernizr && Modernizr.csstransforms3d === true || function () {
                var div = document.createElement('div').style;
                return 'webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div;
            }(),

            flexbox: function () {
                var div = document.createElement('div').style;
                var styles = 'alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient'.split(' ');
                for (var i = 0; i < styles.length; i++) {
                    if (styles[i] in div) return true;
                }
            }(),

            observer: function () {
                return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
            }(),

            passiveListener: function () {
                var supportsPassive = false;
                try {
                    var opts = Object.defineProperty({}, 'passive', {
                        get: function () {
                            supportsPassive = true;
                        }
                    });
                    window.addEventListener('testPassiveListener', null, opts);
                } catch (e) {}
                return supportsPassive;
            }(),

            gestures: function () {
                return 'ongesturestart' in window;
            }()
        },
        /*==================================================
        Plugins
        ====================================================*/
        plugins: {}
    };

    /*===========================
    Dom7 Library
    ===========================*/
    var Dom7 = function () {
        var Dom7 = function (arr) {
            var _this = this,
                i = 0;
            // Create array-like object
            for (i = 0; i < arr.length; i++) {
                _this[i] = arr[i];
            }
            _this.length = arr.length;
            // Return collection with methods
            return this;
        };
        var $ = function (selector, context) {
            var arr = [],
                i = 0;
            if (selector && !context) {
                if (selector instanceof Dom7) {
                    return selector;
                }
            }
            if (selector) {
                // String
                if (typeof selector === 'string') {
                    var els,
                        tempParent,
                        html = selector.trim();
                    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                        var toCreate = 'div';
                        if (html.indexOf('<li') === 0) toCreate = 'ul';
                        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
                        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
                        if (html.indexOf('<tbody') === 0) toCreate = 'table';
                        if (html.indexOf('<option') === 0) toCreate = 'select';
                        tempParent = document.createElement(toCreate);
                        tempParent.innerHTML = selector;
                        for (i = 0; i < tempParent.childNodes.length; i++) {
                            arr.push(tempParent.childNodes[i]);
                        }
                    } else {
                        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                            // Pure ID selector
                            els = [document.getElementById(selector.split('#')[1])];
                        } else {
                            // Other selectors
                            els = (context || document).querySelectorAll(selector);
                        }
                        for (i = 0; i < els.length; i++) {
                            if (els[i]) arr.push(els[i]);
                        }
                    }
                }
                // Node/element
                else if (selector.nodeType || selector === window || selector === document) {
                        arr.push(selector);
                    }
                    //Array of elements or instance of Dom
                    else if (selector.length > 0 && selector[0].nodeType) {
                            for (i = 0; i < selector.length; i++) {
                                arr.push(selector[i]);
                            }
                        }
            }
            return new Dom7(arr);
        };
        Dom7.prototype = {
            // Classes and attriutes
            addClass: function (className) {
                if (typeof className === 'undefined') {
                    return this;
                }
                var classes = className.split(' ');
                for (var i = 0; i < classes.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        this[j].classList.add(classes[i]);
                    }
                }
                return this;
            },
            removeClass: function (className) {
                var classes = className.split(' ');
                for (var i = 0; i < classes.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        this[j].classList.remove(classes[i]);
                    }
                }
                return this;
            },
            hasClass: function (className) {
                if (!this[0]) return false;else return this[0].classList.contains(className);
            },
            toggleClass: function (className) {
                var classes = className.split(' ');
                for (var i = 0; i < classes.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        this[j].classList.toggle(classes[i]);
                    }
                }
                return this;
            },
            attr: function (attrs, value) {
                if (arguments.length === 1 && typeof attrs === 'string') {
                    // Get attr
                    if (this[0]) return this[0].getAttribute(attrs);else return undefined;
                } else {
                    // Set attrs
                    for (var i = 0; i < this.length; i++) {
                        if (arguments.length === 2) {
                            // String
                            this[i].setAttribute(attrs, value);
                        } else {
                            // Object
                            for (var attrName in attrs) {
                                this[i][attrName] = attrs[attrName];
                                this[i].setAttribute(attrName, attrs[attrName]);
                            }
                        }
                    }
                    return this;
                }
            },
            removeAttr: function (attr) {
                for (var i = 0; i < this.length; i++) {
                    this[i].removeAttribute(attr);
                }
                return this;
            },
            data: function (key, value) {
                if (typeof value === 'undefined') {
                    // Get value
                    if (this[0]) {
                        var dataKey = this[0].getAttribute('data-' + key);
                        if (dataKey) return dataKey;else if (this[0].dom7ElementDataStorage && key in this[0].dom7ElementDataStorage) return this[0].dom7ElementDataStorage[key];else return undefined;
                    } else return undefined;
                } else {
                    // Set value
                    for (var i = 0; i < this.length; i++) {
                        var el = this[i];
                        if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
                        el.dom7ElementDataStorage[key] = value;
                    }
                    return this;
                }
            },
            // Transforms
            transform: function (transform) {
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
                }
                return this;
            },
            transition: function (duration) {
                if (typeof duration !== 'string') {
                    duration = duration + 'ms';
                }
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
                }
                return this;
            },
            //Events
            on: function (eventName, targetSelector, listener, capture) {
                function handleLiveEvent(e) {
                    var target = e.target;
                    if ($(target).is(targetSelector)) listener.call(target, e);else {
                        var parents = $(target).parents();
                        for (var k = 0; k < parents.length; k++) {
                            if ($(parents[k]).is(targetSelector)) listener.call(parents[k], e);
                        }
                    }
                }
                var events = eventName.split(' ');
                var i, j;
                for (i = 0; i < this.length; i++) {
                    if (typeof targetSelector === 'function' || targetSelector === false) {
                        // Usual events
                        if (typeof targetSelector === 'function') {
                            listener = arguments[1];
                            capture = arguments[2] || false;
                        }
                        for (j = 0; j < events.length; j++) {
                            this[i].addEventListener(events[j], listener, capture);
                        }
                    } else {
                        //Live events
                        for (j = 0; j < events.length; j++) {
                            if (!this[i].dom7LiveListeners) this[i].dom7LiveListeners = [];
                            this[i].dom7LiveListeners.push({ listener: listener, liveListener: handleLiveEvent });
                            this[i].addEventListener(events[j], handleLiveEvent, capture);
                        }
                    }
                }

                return this;
            },
            off: function (eventName, targetSelector, listener, capture) {
                var events = eventName.split(' ');
                for (var i = 0; i < events.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        if (typeof targetSelector === 'function' || targetSelector === false) {
                            // Usual events
                            if (typeof targetSelector === 'function') {
                                listener = arguments[1];
                                capture = arguments[2] || false;
                            }
                            this[j].removeEventListener(events[i], listener, capture);
                        } else {
                            // Live event
                            if (this[j].dom7LiveListeners) {
                                for (var k = 0; k < this[j].dom7LiveListeners.length; k++) {
                                    if (this[j].dom7LiveListeners[k].listener === listener) {
                                        this[j].removeEventListener(events[i], this[j].dom7LiveListeners[k].liveListener, capture);
                                    }
                                }
                            }
                        }
                    }
                }
                return this;
            },
            once: function (eventName, targetSelector, listener, capture) {
                var dom = this;
                if (typeof targetSelector === 'function') {
                    targetSelector = false;
                    listener = arguments[1];
                    capture = arguments[2];
                }
                function proxy(e) {
                    listener(e);
                    dom.off(eventName, targetSelector, proxy, capture);
                }
                dom.on(eventName, targetSelector, proxy, capture);
            },
            trigger: function (eventName, eventData) {
                for (var i = 0; i < this.length; i++) {
                    var evt;
                    try {
                        evt = new window.CustomEvent(eventName, { detail: eventData, bubbles: true, cancelable: true });
                    } catch (e) {
                        evt = document.createEvent('Event');
                        evt.initEvent(eventName, true, true);
                        evt.detail = eventData;
                    }
                    this[i].dispatchEvent(evt);
                }
                return this;
            },
            transitionEnd: function (callback) {
                var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                    i,
                    j,
                    dom = this;
                function fireCallBack(e) {
                    /*jshint validthis:true */
                    if (e.target !== this) return;
                    callback.call(this, e);
                    for (i = 0; i < events.length; i++) {
                        dom.off(events[i], fireCallBack);
                    }
                }
                if (callback) {
                    for (i = 0; i < events.length; i++) {
                        dom.on(events[i], fireCallBack);
                    }
                }
                return this;
            },
            // Sizing/Styles
            width: function () {
                if (this[0] === window) {
                    return window.innerWidth;
                } else {
                    if (this.length > 0) {
                        return parseFloat(this.css('width'));
                    } else {
                        return null;
                    }
                }
            },
            outerWidth: function (includeMargins) {
                if (this.length > 0) {
                    if (includeMargins) return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));else return this[0].offsetWidth;
                } else return null;
            },
            height: function () {
                if (this[0] === window) {
                    return window.innerHeight;
                } else {
                    if (this.length > 0) {
                        return parseFloat(this.css('height'));
                    } else {
                        return null;
                    }
                }
            },
            outerHeight: function (includeMargins) {
                if (this.length > 0) {
                    if (includeMargins) return this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom'));else return this[0].offsetHeight;
                } else return null;
            },
            offset: function () {
                if (this.length > 0) {
                    var el = this[0];
                    var box = el.getBoundingClientRect();
                    var body = document.body;
                    var clientTop = el.clientTop || body.clientTop || 0;
                    var clientLeft = el.clientLeft || body.clientLeft || 0;
                    var scrollTop = window.pageYOffset || el.scrollTop;
                    var scrollLeft = window.pageXOffset || el.scrollLeft;
                    return {
                        top: box.top + scrollTop - clientTop,
                        left: box.left + scrollLeft - clientLeft
                    };
                } else {
                    return null;
                }
            },
            css: function (props, value) {
                var i;
                if (arguments.length === 1) {
                    if (typeof props === 'string') {
                        if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
                    } else {
                        for (i = 0; i < this.length; i++) {
                            for (var prop in props) {
                                this[i].style[prop] = props[prop];
                            }
                        }
                        return this;
                    }
                }
                if (arguments.length === 2 && typeof props === 'string') {
                    for (i = 0; i < this.length; i++) {
                        this[i].style[props] = value;
                    }
                    return this;
                }
                return this;
            },

            //Dom manipulation
            each: function (callback) {
                for (var i = 0; i < this.length; i++) {
                    callback.call(this[i], i, this[i]);
                }
                return this;
            },
            html: function (html) {
                if (typeof html === 'undefined') {
                    return this[0] ? this[0].innerHTML : undefined;
                } else {
                    for (var i = 0; i < this.length; i++) {
                        this[i].innerHTML = html;
                    }
                    return this;
                }
            },
            text: function (text) {
                if (typeof text === 'undefined') {
                    if (this[0]) {
                        return this[0].textContent.trim();
                    } else return null;
                } else {
                    for (var i = 0; i < this.length; i++) {
                        this[i].textContent = text;
                    }
                    return this;
                }
            },
            is: function (selector) {
                if (!this[0]) return false;
                var compareWith, i;
                if (typeof selector === 'string') {
                    var el = this[0];
                    if (el === document) return selector === document;
                    if (el === window) return selector === window;

                    if (el.matches) return el.matches(selector);else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);else if (el.mozMatchesSelector) return el.mozMatchesSelector(selector);else if (el.msMatchesSelector) return el.msMatchesSelector(selector);else {
                        compareWith = $(selector);
                        for (i = 0; i < compareWith.length; i++) {
                            if (compareWith[i] === this[0]) return true;
                        }
                        return false;
                    }
                } else if (selector === document) return this[0] === document;else if (selector === window) return this[0] === window;else {
                    if (selector.nodeType || selector instanceof Dom7) {
                        compareWith = selector.nodeType ? [selector] : selector;
                        for (i = 0; i < compareWith.length; i++) {
                            if (compareWith[i] === this[0]) return true;
                        }
                        return false;
                    }
                    return false;
                }
            },
            index: function () {
                if (this[0]) {
                    var child = this[0];
                    var i = 0;
                    while ((child = child.previousSibling) !== null) {
                        if (child.nodeType === 1) i++;
                    }
                    return i;
                } else return undefined;
            },
            eq: function (index) {
                if (typeof index === 'undefined') return this;
                var length = this.length;
                var returnIndex;
                if (index > length - 1) {
                    return new Dom7([]);
                }
                if (index < 0) {
                    returnIndex = length + index;
                    if (returnIndex < 0) return new Dom7([]);else return new Dom7([this[returnIndex]]);
                }
                return new Dom7([this[index]]);
            },
            append: function (newChild) {
                var i, j;
                for (i = 0; i < this.length; i++) {
                    if (typeof newChild === 'string') {
                        var tempDiv = document.createElement('div');
                        tempDiv.innerHTML = newChild;
                        while (tempDiv.firstChild) {
                            this[i].appendChild(tempDiv.firstChild);
                        }
                    } else if (newChild instanceof Dom7) {
                        for (j = 0; j < newChild.length; j++) {
                            this[i].appendChild(newChild[j]);
                        }
                    } else {
                        this[i].appendChild(newChild);
                    }
                }
                return this;
            },
            prepend: function (newChild) {
                var i, j;
                for (i = 0; i < this.length; i++) {
                    if (typeof newChild === 'string') {
                        var tempDiv = document.createElement('div');
                        tempDiv.innerHTML = newChild;
                        for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
                            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                        }
                        // this[i].insertAdjacentHTML('afterbegin', newChild);
                    } else if (newChild instanceof Dom7) {
                        for (j = 0; j < newChild.length; j++) {
                            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                        }
                    } else {
                        this[i].insertBefore(newChild, this[i].childNodes[0]);
                    }
                }
                return this;
            },
            insertBefore: function (selector) {
                var before = $(selector);
                for (var i = 0; i < this.length; i++) {
                    if (before.length === 1) {
                        before[0].parentNode.insertBefore(this[i], before[0]);
                    } else if (before.length > 1) {
                        for (var j = 0; j < before.length; j++) {
                            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
                        }
                    }
                }
            },
            insertAfter: function (selector) {
                var after = $(selector);
                for (var i = 0; i < this.length; i++) {
                    if (after.length === 1) {
                        after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
                    } else if (after.length > 1) {
                        for (var j = 0; j < after.length; j++) {
                            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
                        }
                    }
                }
            },
            next: function (selector) {
                if (this.length > 0) {
                    if (selector) {
                        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) return new Dom7([this[0].nextElementSibling]);else return new Dom7([]);
                    } else {
                        if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);else return new Dom7([]);
                    }
                } else return new Dom7([]);
            },
            nextAll: function (selector) {
                var nextEls = [];
                var el = this[0];
                if (!el) return new Dom7([]);
                while (el.nextElementSibling) {
                    var next = el.nextElementSibling;
                    if (selector) {
                        if ($(next).is(selector)) nextEls.push(next);
                    } else nextEls.push(next);
                    el = next;
                }
                return new Dom7(nextEls);
            },
            prev: function (selector) {
                if (this.length > 0) {
                    if (selector) {
                        if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) return new Dom7([this[0].previousElementSibling]);else return new Dom7([]);
                    } else {
                        if (this[0].previousElementSibling) return new Dom7([this[0].previousElementSibling]);else return new Dom7([]);
                    }
                } else return new Dom7([]);
            },
            prevAll: function (selector) {
                var prevEls = [];
                var el = this[0];
                if (!el) return new Dom7([]);
                while (el.previousElementSibling) {
                    var prev = el.previousElementSibling;
                    if (selector) {
                        if ($(prev).is(selector)) prevEls.push(prev);
                    } else prevEls.push(prev);
                    el = prev;
                }
                return new Dom7(prevEls);
            },
            parent: function (selector) {
                var parents = [];
                for (var i = 0; i < this.length; i++) {
                    if (selector) {
                        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
                    } else {
                        parents.push(this[i].parentNode);
                    }
                }
                return $($.unique(parents));
            },
            parents: function (selector) {
                var parents = [];
                for (var i = 0; i < this.length; i++) {
                    var parent = this[i].parentNode;
                    while (parent) {
                        if (selector) {
                            if ($(parent).is(selector)) parents.push(parent);
                        } else {
                            parents.push(parent);
                        }
                        parent = parent.parentNode;
                    }
                }
                return $($.unique(parents));
            },
            find: function (selector) {
                var foundElements = [];
                for (var i = 0; i < this.length; i++) {
                    var found = this[i].querySelectorAll(selector);
                    for (var j = 0; j < found.length; j++) {
                        foundElements.push(found[j]);
                    }
                }
                return new Dom7(foundElements);
            },
            children: function (selector) {
                var children = [];
                for (var i = 0; i < this.length; i++) {
                    var childNodes = this[i].childNodes;

                    for (var j = 0; j < childNodes.length; j++) {
                        if (!selector) {
                            if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
                        } else {
                            if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) children.push(childNodes[j]);
                        }
                    }
                }
                return new Dom7($.unique(children));
            },
            remove: function () {
                for (var i = 0; i < this.length; i++) {
                    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
                }
                return this;
            },
            add: function () {
                var dom = this;
                var i, j;
                for (i = 0; i < arguments.length; i++) {
                    var toAdd = $(arguments[i]);
                    for (j = 0; j < toAdd.length; j++) {
                        dom[dom.length] = toAdd[j];
                        dom.length++;
                    }
                }
                return dom;
            }
        };
        $.fn = Dom7.prototype;
        $.unique = function (arr) {
            var unique = [];
            for (var i = 0; i < arr.length; i++) {
                if (unique.indexOf(arr[i]) === -1) unique.push(arr[i]);
            }
            return unique;
        };

        return $;
    }();

    /*===========================
     Get Dom libraries
     ===========================*/
    var swiperDomPlugins = ['jQuery', 'Zepto', 'Dom7'];
    for (var i = 0; i < swiperDomPlugins.length; i++) {
        if (window[swiperDomPlugins[i]]) {
            addLibraryPlugin(window[swiperDomPlugins[i]]);
        }
    }
    // Required DOM Plugins
    var domLib;
    if (typeof Dom7 === 'undefined') {
        domLib = window.Dom7 || window.Zepto || window.jQuery;
    } else {
        domLib = Dom7;
    }

    /*===========================
    Add .swiper plugin from Dom libraries
    ===========================*/
    function addLibraryPlugin(lib) {
        lib.fn.swiper = function (params) {
            var firstInstance;
            lib(this).each(function () {
                var s = new Swiper(this, params);
                if (!firstInstance) firstInstance = s;
            });
            return firstInstance;
        };
    }

    if (domLib) {
        if (!('transitionEnd' in domLib.fn)) {
            domLib.fn.transitionEnd = function (callback) {
                var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                    i,
                    j,
                    dom = this;
                function fireCallBack(e) {
                    /*jshint validthis:true */
                    if (e.target !== this) return;
                    callback.call(this, e);
                    for (i = 0; i < events.length; i++) {
                        dom.off(events[i], fireCallBack);
                    }
                }
                if (callback) {
                    for (i = 0; i < events.length; i++) {
                        dom.on(events[i], fireCallBack);
                    }
                }
                return this;
            };
        }
        if (!('transform' in domLib.fn)) {
            domLib.fn.transform = function (transform) {
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
                }
                return this;
            };
        }
        if (!('transition' in domLib.fn)) {
            domLib.fn.transition = function (duration) {
                if (typeof duration !== 'string') {
                    duration = duration + 'ms';
                }
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
                }
                return this;
            };
        }
        if (!('outerWidth' in domLib.fn)) {
            domLib.fn.outerWidth = function (includeMargins) {
                if (this.length > 0) {
                    if (includeMargins) return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));else return this[0].offsetWidth;
                } else return null;
            };
        }
    }

    window.Swiper = Swiper;
})();

/*===========================
Swiper AMD Export
===========================*/
if (true) {
    module.exports = window.Swiper;
} else if (typeof define === 'function' && define.amd) {
    define([], function () {
        'use strict';

        return window.Swiper;
    });
}

//# sourceMappingURL=maps/swiper.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(45);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(55)
}
var Component = __webpack_require__(1)(
  /* script */
  null,
  /* template */
  __webpack_require__(58),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "D:\\newtest\\6.20\\bilibili-live\\app\\components\\liveheader.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] liveheader.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-620466f0", Component.options)
  } else {
    hotAPI.reload("data-v-620466f0", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_router__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vuex__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vue_resource__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_axios__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_axios__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vue_awesome_swiper__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_vue_awesome_swiper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_vue_awesome_swiper__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__css_index_css__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__css_index_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__css_index_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__js_flv_min_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__js_flv_min_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__js_flv_min_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_routes_livehome_vue__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_routes_livehome_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__components_routes_livehome_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_routes_livedetali_vue__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_routes_livedetali_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9__components_routes_livedetali_vue__);
//vue

//

//vuex


//axiosajax


__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_2_vuex__["a" /* default */]);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_1_vue_router__["a" /* default */]);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_3_vue_resource__["a" /* default */]);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_5_vue_awesome_swiper___default.a);
__WEBPACK_IMPORTED_MODULE_0_vue___default.a.prototype.$ajax = __WEBPACK_IMPORTED_MODULE_4_axios___default.a;




window.flv = __WEBPACK_IMPORTED_MODULE_7__js_flv_min_js___default.a;




var router = new __WEBPACK_IMPORTED_MODULE_1_vue_router__["a" /* default */]({
	routes: [{
		path: '/index',
		component: __WEBPACK_IMPORTED_MODULE_8__components_routes_livehome_vue___default.a
		// children:[{
		// 	path:'livedetali/:room_id',
		// 	component:livedetali
		// }]
	}, {
		path: '/livedetali/:room_id',
		component: __WEBPACK_IMPORTED_MODULE_9__components_routes_livedetali_vue___default.a
	}, {
		path: '/',
		redirect: '/index'
	}]
});

var store = new __WEBPACK_IMPORTED_MODULE_2_vuex__["a" /* default */].Store({
	state: {
		limit: 4,
		livebanner: [],
		liveentranceIcons: [],
		livepartitions: [],
		index: ""
	},
	mutations: {

		setLive(state) {
			__WEBPACK_IMPORTED_MODULE_0_vue___default.a.http.get("http://localhost:8848", {}).then(response => {
				console.log(response.body.data);
				state.livebanner = response.body.data.banner;
				state.liveentranceIcons = response.body.data.entranceIcons;
				state.livepartitions = response.body.data.partitions;
				// console.log(state.livebanner )
				// state.liverecommend_data = response.body.data.recommend_data
			}).catch(error => {
				console.log(error);
			});
		}
	},
	actions: {

		setLive(context) {
			context.commit('setLive');
		}
	}
});
new __WEBPACK_IMPORTED_MODULE_0_vue___default.a({
	el: "#demo",
	template: `
		<router-view class="app-ctnr"></router-view>
	`,
	router,
	store,
	created() {
		window.scope = this.$store.state;
	}
});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*!
 * Vue.js v2.4.2
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
(function (global, factory) {
   true ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Vue = factory();
})(this, function () {
  'use strict';

  /*  */

  // these helpers produces better vm code in JS engines due to their
  // explicitness and function inlining

  function isUndef(v) {
    return v === undefined || v === null;
  }

  function isDef(v) {
    return v !== undefined && v !== null;
  }

  function isTrue(v) {
    return v === true;
  }

  function isFalse(v) {
    return v === false;
  }

  /**
   * Check if value is primitive
   */
  function isPrimitive(value) {
    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
  }

  /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   */
  function isObject(obj) {
    return obj !== null && typeof obj === 'object';
  }

  var _toString = Object.prototype.toString;

  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   */
  function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
  }

  function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
  }

  /**
   * Check if val is a valid array index.
   */
  function isValidArrayIndex(val) {
    var n = parseFloat(val);
    return n >= 0 && Math.floor(n) === n && isFinite(val);
  }

  /**
   * Convert a value to a string that is actually rendered.
   */
  function toString(val) {
    return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);
  }

  /**
   * Convert a input value to a number for persistence.
   * If the conversion fails, return original string.
   */
  function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
  }

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   */
  function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? function (val) {
      return map[val.toLowerCase()];
    } : function (val) {
      return map[val];
    };
  }

  /**
   * Check if a tag is a built-in tag.
   */
  var isBuiltInTag = makeMap('slot,component', true);

  /**
   * Check if a attribute is a reserved attribute.
   */
  var isReservedAttribute = makeMap('key,ref,slot,is');

  /**
   * Remove an item from an array
   */
  function remove(arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);
      if (index > -1) {
        return arr.splice(index, 1);
      }
    }
  }

  /**
   * Check whether the object has the property.
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
  }

  /**
   * Create a cached version of a pure function.
   */
  function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  }

  /**
   * Camelize a hyphen-delimited string.
   */
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) {
      return c ? c.toUpperCase() : '';
    });
  });

  /**
   * Capitalize a string.
   */
  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });

  /**
   * Hyphenate a camelCase string.
   */
  var hyphenateRE = /([^-])([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
  });

  /**
   * Simple bind, faster than native
   */
  function bind(fn, ctx) {
    function boundFn(a) {
      var l = arguments.length;
      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
    }
    // record original fn length
    boundFn._length = fn.length;
    return boundFn;
  }

  /**
   * Convert an Array-like object to a real Array.
   */
  function toArray(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret;
  }

  /**
   * Mix properties into target object.
   */
  function extend(to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to;
  }

  /**
   * Merge an Array of Objects into a single Object.
   */
  function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res;
  }

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
   */
  function noop(a, b, c) {}

  /**
   * Always return false.
   */
  var no = function (a, b, c) {
    return false;
  };

  /**
   * Return same value
   */
  var identity = function (_) {
    return _;
  };

  /**
   * Generate a static keys string from compiler modules.
   */
  function genStaticKeys(modules) {
    return modules.reduce(function (keys, m) {
      return keys.concat(m.staticKeys || []);
    }, []).join(',');
  }

  /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   */
  function looseEqual(a, b) {
    if (a === b) {
      return true;
    }
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i]);
          });
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key]);
          });
        } else {
          /* istanbul ignore next */
          return false;
        }
      } catch (e) {
        /* istanbul ignore next */
        return false;
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b);
    } else {
      return false;
    }
  }

  function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Ensure a function is called only once.
   */
  function once(fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    };
  }

  var SSR_ATTR = 'data-server-rendered';

  var ASSET_TYPES = ['component', 'directive', 'filter'];

  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];

  /*  */

  var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: false,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',

    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  };

  /*  */

  var emptyObject = Object.freeze({});

  /**
   * Check if a string starts with $ or _
   */
  function isReserved(str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F;
  }

  /**
   * Define a property.
   */
  function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }

  /**
   * Parse simple path.
   */
  var bailRE = /[^\w.$]/;
  function parsePath(path) {
    if (bailRE.test(path)) {
      return;
    }
    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) {
          return;
        }
        obj = obj[segments[i]];
      }
      return obj;
    };
  }

  /*  */

  var warn = noop;
  var tip = noop;
  var formatComponentName = null; // work around flow check

  {
    var hasConsole = typeof console !== 'undefined';
    var classifyRE = /(?:^|[-_])(\w)/g;
    var classify = function (str) {
      return str.replace(classifyRE, function (c) {
        return c.toUpperCase();
      }).replace(/[-_]/g, '');
    };

    warn = function (msg, vm) {
      var trace = vm ? generateComponentTrace(vm) : '';

      if (config.warnHandler) {
        config.warnHandler.call(null, msg, vm, trace);
      } else if (hasConsole && !config.silent) {
        console.error("[Vue warn]: " + msg + trace);
      }
    };

    tip = function (msg, vm) {
      if (hasConsole && !config.silent) {
        console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
      }
    };

    formatComponentName = function (vm, includeFile) {
      if (vm.$root === vm) {
        return '<Root>';
      }
      var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;

      var file = vm._isVue && vm.$options.__file;
      if (!name && file) {
        var match = file.match(/([^/\\]+)\.vue$/);
        name = match && match[1];
      }

      return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
    };

    var repeat = function (str, n) {
      var res = '';
      while (n) {
        if (n % 2 === 1) {
          res += str;
        }
        if (n > 1) {
          str += str;
        }
        n >>= 1;
      }
      return res;
    };

    var generateComponentTrace = function (vm) {
      if (vm._isVue && vm.$parent) {
        var tree = [];
        var currentRecursiveSequence = 0;
        while (vm) {
          if (tree.length > 0) {
            var last = tree[tree.length - 1];
            if (last.constructor === vm.constructor) {
              currentRecursiveSequence++;
              vm = vm.$parent;
              continue;
            } else if (currentRecursiveSequence > 0) {
              tree[tree.length - 1] = [last, currentRecursiveSequence];
              currentRecursiveSequence = 0;
            }
          }
          tree.push(vm);
          vm = vm.$parent;
        }
        return '\n\nfound in\n\n' + tree.map(function (vm, i) {
          return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
        }).join('\n');
      } else {
        return "\n\n(found in " + formatComponentName(vm) + ")";
      }
    };
  }

  /*  */

  function handleError(err, vm, info) {
    if (config.errorHandler) {
      config.errorHandler.call(null, err, vm, info);
    } else {
      {
        warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
      }
      /* istanbul ignore else */
      if (inBrowser && typeof console !== 'undefined') {
        console.error(err);
      } else {
        throw err;
      }
    }
  }

  /*  */
  /* globals MutationObserver */

  // can we use __proto__?
  var hasProto = '__proto__' in {};

  // Browser environment sniffing
  var inBrowser = typeof window !== 'undefined';
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  var isAndroid = UA && UA.indexOf('android') > 0;
  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

  // Firefix has a "watch" function on Object.prototype...
  var nativeWatch = {}.watch;

  var supportsPassive = false;
  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', {
        get: function get() {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      }); // https://github.com/facebook/flow/issues/285
      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  }

  // this needs to be lazy-evaled because vue may be required before
  // vue-server-renderer can set VUE_ENV
  var _isServer;
  var isServerRendering = function () {
    if (_isServer === undefined) {
      /* istanbul ignore if */
      if (!inBrowser && typeof global !== 'undefined') {
        // detect presence of vue-server-renderer and avoid
        // Webpack shimming the process
        _isServer = global['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }
    return _isServer;
  };

  // detect devtools
  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  /* istanbul ignore next */
  function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
  }

  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  /**
   * Defer a task to execute it asynchronously.
   */
  var nextTick = function () {
    var callbacks = [];
    var pending = false;
    var timerFunc;

    function nextTickHandler() {
      pending = false;
      var copies = callbacks.slice(0);
      callbacks.length = 0;
      for (var i = 0; i < copies.length; i++) {
        copies[i]();
      }
    }

    // the nextTick behavior leverages the microtask queue, which can be accessed
    // via either native Promise.then or MutationObserver.
    // MutationObserver has wider support, however it is seriously bugged in
    // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
    // completely stops working after triggering a few times... so, if native
    // Promise is available, we will use it:
    /* istanbul ignore if */
    if (typeof Promise !== 'undefined' && isNative(Promise)) {
      var p = Promise.resolve();
      var logError = function (err) {
        console.error(err);
      };
      timerFunc = function () {
        p.then(nextTickHandler).catch(logError);
        // in problematic UIWebViews, Promise.then doesn't completely break, but
        // it can get stuck in a weird state where callbacks are pushed into the
        // microtask queue but the queue isn't being flushed, until the browser
        // needs to do some other work, e.g. handle a timer. Therefore we can
        // "force" the microtask queue to be flushed by adding an empty timer.
        if (isIOS) {
          setTimeout(noop);
        }
      };
    } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]')) {
      // use MutationObserver where native Promise is not available,
      // e.g. PhantomJS IE11, iOS7, Android 4.4
      var counter = 1;
      var observer = new MutationObserver(nextTickHandler);
      var textNode = document.createTextNode(String(counter));
      observer.observe(textNode, {
        characterData: true
      });
      timerFunc = function () {
        counter = (counter + 1) % 2;
        textNode.data = String(counter);
      };
    } else {
      // fallback to setTimeout
      /* istanbul ignore next */
      timerFunc = function () {
        setTimeout(nextTickHandler, 0);
      };
    }

    return function queueNextTick(cb, ctx) {
      var _resolve;
      callbacks.push(function () {
        if (cb) {
          try {
            cb.call(ctx);
          } catch (e) {
            handleError(e, ctx, 'nextTick');
          }
        } else if (_resolve) {
          _resolve(ctx);
        }
      });
      if (!pending) {
        pending = true;
        timerFunc();
      }
      if (!cb && typeof Promise !== 'undefined') {
        return new Promise(function (resolve, reject) {
          _resolve = resolve;
        });
      }
    };
  }();

  var _Set;
  /* istanbul ignore if */
  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = function () {
      function Set() {
        this.set = Object.create(null);
      }
      Set.prototype.has = function has(key) {
        return this.set[key] === true;
      };
      Set.prototype.add = function add(key) {
        this.set[key] = true;
      };
      Set.prototype.clear = function clear() {
        this.set = Object.create(null);
      };

      return Set;
    }();
  }

  /*  */

  var uid = 0;

  /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   */
  var Dep = function Dep() {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub(sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub(sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify() {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  // the current target watcher being evaluated.
  // this is globally unique because there could be only one
  // watcher being evaluated at any time.
  Dep.target = null;
  var targetStack = [];

  function pushTarget(_target) {
    if (Dep.target) {
      targetStack.push(Dep.target);
    }
    Dep.target = _target;
  }

  function popTarget() {
    Dep.target = targetStack.pop();
  }

  /*
   * not type checking this file because flow doesn't play well with
   * dynamically accessing methods on Array prototype
   */

  var arrayProto = Array.prototype;
  var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
      var args = [],
          len = arguments.length;
      while (len--) args[len] = arguments[len];

      var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break;
        case 'splice':
          inserted = args.slice(2);
          break;
      }
      if (inserted) {
        ob.observeArray(inserted);
      }
      // notify change
      ob.dep.notify();
      return result;
    });
  });

  /*  */

  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

  /**
   * By default, when a reactive property is set, the new value is
   * also converted to become reactive. However when passing down props,
   * we don't want to force conversion because the value may be a nested value
   * under a frozen data structure. Converting it would defeat the optimization.
   */
  var observerState = {
    shouldConvert: true
  };

  /**
   * Observer class that are attached to each observed
   * object. Once attached, the observer converts target
   * object's property keys into getter/setters that
   * collect dependencies and dispatches updates.
   */
  var Observer = function Observer(value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
      var augment = hasProto ? protoAugment : copyAugment;
      augment(value, arrayMethods, arrayKeys);
      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  Observer.prototype.walk = function walk(obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive$$1(obj, keys[i], obj[keys[i]]);
    }
  };

  /**
   * Observe a list of Array items.
   */
  Observer.prototype.observeArray = function observeArray(items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };

  // helpers

  /**
   * Augment an target Object or Array by intercepting
   * the prototype chain using __proto__
   */
  function protoAugment(target, src, keys) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }

  /**
   * Augment an target Object or Array by defining
   * hidden properties.
   */
  /* istanbul ignore next */
  function copyAugment(target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }

  /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   */
  function observe(value, asRootData) {
    if (!isObject(value)) {
      return;
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob;
  }

  /**
   * Define a reactive property on an Object.
   */
  function defineReactive$$1(obj, key, val, customSetter, shallow) {
    var dep = new Dep();

    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return;
    }

    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter() {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
          }
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
        return value;
      },
      set: function reactiveSetter(newVal) {
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        /* eslint-enable no-self-compare */
        if ("development" !== 'production' && customSetter) {
          customSetter();
        }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }

  /**
   * Set a property on an object. Adds the new property and
   * triggers change notification if the property doesn't
   * already exist.
   */
  function set(target, key, val) {
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    if (hasOwn(target, key)) {
      target[key] = val;
      return val;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      "development" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
      return val;
    }
    if (!ob) {
      target[key] = val;
      return val;
    }
    defineReactive$$1(ob.value, key, val);
    ob.dep.notify();
    return val;
  }

  /**
   * Delete a property and trigger change if necessary.
   */
  function del(target, key) {
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.splice(key, 1);
      return;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      "development" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
      return;
    }
    if (!hasOwn(target, key)) {
      return;
    }
    delete target[key];
    if (!ob) {
      return;
    }
    ob.dep.notify();
  }

  /**
   * Collect dependencies on array elements when the array is touched, since
   * we cannot intercept array element access like property getters.
   */
  function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }

  /*  */

  /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   */
  var strats = config.optionMergeStrategies;

  /**
   * Options with restrictions
   */
  {
    strats.el = strats.propsData = function (parent, child, vm, key) {
      if (!vm) {
        warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
      }
      return defaultStrat(parent, child);
    };
  }

  /**
   * Helper that recursively merges two data objects together.
   */
  function mergeData(to, from) {
    if (!from) {
      return to;
    }
    var key, toVal, fromVal;
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
        mergeData(toVal, fromVal);
      }
    }
    return to;
  }

  /**
   * Data
   */
  function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
      // in a Vue.extend merge, both should be functions
      if (!childVal) {
        return parentVal;
      }
      if (!parentVal) {
        return childVal;
      }
      // when parentVal & childVal are both present,
      // we need to return a function that returns the
      // merged result of both functions... no need to
      // check if parentVal is a function here because
      // it has to be a function to pass previous merges.
      return function mergedDataFn() {
        return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);
      };
    } else if (parentVal || childVal) {
      return function mergedInstanceDataFn() {
        // instance merge
        var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
        if (instanceData) {
          return mergeData(instanceData, defaultData);
        } else {
          return defaultData;
        }
      };
    }
  }

  strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {
        "development" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

        return parentVal;
      }
      return mergeDataOrFn.call(this, parentVal, childVal);
    }

    return mergeDataOrFn(parentVal, childVal, vm);
  };

  /**
   * Hooks and props are merged as arrays.
   */
  function mergeHook(parentVal, childVal) {
    return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  }

  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });

  /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */
  function mergeAssets(parentVal, childVal) {
    var res = Object.create(parentVal || null);
    return childVal ? extend(res, childVal) : res;
  }

  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });

  /**
   * Watchers.
   *
   * Watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */
  strats.watch = function (parentVal, childVal) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) {
      parentVal = undefined;
    }
    if (childVal === nativeWatch) {
      childVal = undefined;
    }
    /* istanbul ignore if */
    if (!childVal) {
      return Object.create(parentVal || null);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = {};
    extend(ret, parentVal);
    for (var key in childVal) {
      var parent = ret[key];
      var child = childVal[key];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
    }
    return ret;
  };

  /**
   * Other object hashes.
   */
  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal) {
    if (!parentVal) {
      return childVal;
    }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) {
      extend(ret, childVal);
    }
    return ret;
  };
  strats.provide = mergeDataOrFn;

  /**
   * Default strategy.
   */
  var defaultStrat = function (parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
  };

  /**
   * Validate component names
   */
  function checkComponents(options) {
    for (var key in options.components) {
      var lower = key.toLowerCase();
      if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
        warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
      }
    }
  }

  /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   */
  function normalizeProps(options) {
    var props = options.props;
    if (!props) {
      return;
    }
    var res = {};
    var i, val, name;
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null };
        } else {
          warn('props must be strings when using array syntax.');
        }
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val) ? val : { type: val };
      }
    }
    options.props = res;
  }

  /**
   * Normalize all injections into Object-based format
   */
  function normalizeInject(options) {
    var inject = options.inject;
    if (Array.isArray(inject)) {
      var normalized = options.inject = {};
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = inject[i];
      }
    }
  }

  /**
   * Normalize raw function directives into object format.
   */
  function normalizeDirectives(options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def = dirs[key];
        if (typeof def === 'function') {
          dirs[key] = { bind: def, update: def };
        }
      }
    }
  }

  /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   */
  function mergeOptions(parent, child, vm) {
    {
      checkComponents(child);
    }

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child);
    normalizeInject(child);
    normalizeDirectives(child);
    var extendsFrom = child.extends;
    if (extendsFrom) {
      parent = mergeOptions(parent, extendsFrom, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField(key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
  }

  /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   */
  function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
      return;
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id)) {
      return assets[id];
    }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) {
      return assets[camelizedId];
    }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) {
      return assets[PascalCaseId];
    }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if ("development" !== 'production' && warnMissing && !res) {
      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
    }
    return res;
  }

  /*  */

  function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // handle boolean props
    if (isType(Boolean, prop.type)) {
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
      } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
        value = true;
      }
    }
    // check default value
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      // since the default value is a fresh copy,
      // make sure to observe it.
      var prevShouldConvert = observerState.shouldConvert;
      observerState.shouldConvert = true;
      observe(value);
      observerState.shouldConvert = prevShouldConvert;
    }
    {
      assertProp(prop, key, value, vm, absent);
    }
    return value;
  }

  /**
   * Get the default value of a prop.
   */
  function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
      return undefined;
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if ("development" !== 'production' && isObject(def)) {
      warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
      return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
  }

  /**
   * Assert whether a prop is valid.
   */
  function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
      warn('Missing required prop: "' + name + '"', vm);
      return;
    }
    if (value == null && !prop.required) {
      return;
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }
      for (var i = 0; i < type.length && !valid; i++) {
        var assertedType = assertType(value, type[i]);
        expectedTypes.push(assertedType.expectedType || '');
        valid = assertedType.valid;
      }
    }
    if (!valid) {
      warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
      return;
    }
    var validator = prop.validator;
    if (validator) {
      if (!validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
      }
    }
  }

  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

  function assertType(value, type) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
      valid = typeof value === expectedType.toLowerCase();
    } else if (expectedType === 'Object') {
      valid = isPlainObject(value);
    } else if (expectedType === 'Array') {
      valid = Array.isArray(value);
    } else {
      valid = value instanceof type;
    }
    return {
      valid: valid,
      expectedType: expectedType
    };
  }

  /**
   * Use function string name to check built-in types,
   * because a simple equality check will fail when running
   * across different vms / iframes.
   */
  function getType(fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
  }

  function isType(type, fn) {
    if (!Array.isArray(fn)) {
      return getType(fn) === getType(type);
    }
    for (var i = 0, len = fn.length; i < len; i++) {
      if (getType(fn[i]) === getType(type)) {
        return true;
      }
    }
    /* istanbul ignore next */
    return false;
  }

  /*  */

  var mark;
  var measure;

  {
    var perf = inBrowser && window.performance;
    /* istanbul ignore if */
    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
      mark = function (tag) {
        return perf.mark(tag);
      };
      measure = function (name, startTag, endTag) {
        perf.measure(name, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
        perf.clearMeasures(name);
      };
    }
  }

  /* not type checking this file because flow doesn't play well with Proxy */

  var initProxy;

  {
    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
    );

    var warnNonPresent = function (target, key) {
      warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
    };

    var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

    if (hasProxy) {
      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
      config.keyCodes = new Proxy(config.keyCodes, {
        set: function set(target, key, value) {
          if (isBuiltInModifier(key)) {
            warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
            return false;
          } else {
            target[key] = value;
            return true;
          }
        }
      });
    }

    var hasHandler = {
      has: function has(target, key) {
        var has = key in target;
        var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
        if (!has && !isAllowed) {
          warnNonPresent(target, key);
        }
        return has || !isAllowed;
      }
    };

    var getHandler = {
      get: function get(target, key) {
        if (typeof key === 'string' && !(key in target)) {
          warnNonPresent(target, key);
        }
        return target[key];
      }
    };

    initProxy = function initProxy(vm) {
      if (hasProxy) {
        // determine which proxy handler to use
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
        vm._renderProxy = new Proxy(vm, handlers);
      } else {
        vm._renderProxy = vm;
      }
    };
  }

  /*  */

  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.functionalContext = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  };

  var prototypeAccessors = { child: {} };

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  prototypeAccessors.child.get = function () {
    return this.componentInstance;
  };

  Object.defineProperties(VNode.prototype, prototypeAccessors);

  var createEmptyVNode = function (text) {
    if (text === void 0) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
  };

  function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
  }

  // optimized shallow clone
  // used for static nodes and slot nodes because they may be reused across
  // multiple renders, cloning them avoids errors when DOM manipulations rely
  // on their elm reference.
  function cloneVNode(vnode) {
    var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.isCloned = true;
    return cloned;
  }

  function cloneVNodes(vnodes) {
    var len = vnodes.length;
    var res = new Array(len);
    for (var i = 0; i < len; i++) {
      res[i] = cloneVNode(vnodes[i]);
    }
    return res;
  }

  /*  */

  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    };
  });

  function createFnInvoker(fns) {
    function invoker() {
      var arguments$1 = arguments;

      var fns = invoker.fns;
      if (Array.isArray(fns)) {
        var cloned = fns.slice();
        for (var i = 0; i < cloned.length; i++) {
          cloned[i].apply(null, arguments$1);
        }
      } else {
        // return handler return value for single handlers
        return fns.apply(null, arguments);
      }
    }
    invoker.fns = fns;
    return invoker;
  }

  function updateListeners(on, oldOn, add, remove$$1, vm) {
    var name, cur, old, event;
    for (name in on) {
      cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);
      if (isUndef(cur)) {
        "development" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur);
        }
        add(event.name, cur, event.once, event.capture, event.passive);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }
    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }

  /*  */

  function mergeVNodeHook(def, hookKey, hook) {
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook() {
      hook.apply(this, arguments);
      // important: remove merged hook to ensure it's called only once
      // and prevent memory leak
      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // no existing hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      /* istanbul ignore if */
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // already a merged invoker
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        // existing plain hook
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }

  /*  */

  function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return;
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        {
          var keyInLowerCase = key.toLowerCase();
          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
            tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
          }
        }
        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
      }
    }
    return res;
  }

  function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];
        if (!preserve) {
          delete hash[key];
        }
        return true;
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];
        if (!preserve) {
          delete hash[altKey];
        }
        return true;
      }
    }
    return false;
  }

  /*  */

  // The template compiler attempts to minimize the need for normalization by
  // statically analyzing the template at compile time.
  //
  // For plain HTML markup, normalization can be completely skipped because the
  // generated render function is guaranteed to return Array<VNode>. There are
  // two cases where extra normalization is needed:

  // 1. When the children contains components - because a functional component
  // may return an Array instead of a single root. In this case, just a simple
  // normalization is needed - if any child is an Array, we flatten the whole
  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
  // because functional components already normalize their own children.
  function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children);
      }
    }
    return children;
  }

  // 2. When the children contains constructs that always generated nested Arrays,
  // e.g. <template>, <slot>, v-for, or when the children is provided by user
  // with hand-written render functions / JSX. In such cases a full normalization
  // is needed to cater to all possible types of children values.
  function normalizeChildren(children) {
    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
  }

  function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
  }

  function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, last;
    for (i = 0; i < children.length; i++) {
      c = children[i];
      if (isUndef(c) || typeof c === 'boolean') {
        continue;
      }
      last = res[res.length - 1];
      //  nested
      if (Array.isArray(c)) {
        res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          // merge adjacent text nodes
          // this is necessary for SSR hydration because text nodes are
          // essentially merged when rendered to HTML strings
          last.text += String(c);
        } else if (c !== '') {
          // convert primitive to vnode
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          // merge adjacent text nodes
          res[res.length - 1] = createTextVNode(last.text + c.text);
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res;
  }

  /*  */

  function ensureCtor(comp, base) {
    if (comp.__esModule && comp.default) {
      comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
  }

  function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node;
  }

  function resolveAsyncComponent(factory, baseCtor, context) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp;
    }

    if (isDef(factory.resolved)) {
      return factory.resolved;
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp;
    }

    if (isDef(factory.contexts)) {
      // already pending
      factory.contexts.push(context);
    } else {
      var contexts = factory.contexts = [context];
      var sync = true;

      var forceRender = function () {
        for (var i = 0, l = contexts.length; i < l; i++) {
          contexts[i].$forceUpdate();
        }
      };

      var resolve = once(function (res) {
        // cache resolved
        factory.resolved = ensureCtor(res, baseCtor);
        // invoke callbacks only if this is not a synchronous resolve
        // (async resolves are shimmed as synchronous during SSR)
        if (!sync) {
          forceRender();
        }
      });

      var reject = once(function (reason) {
        "development" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender();
        }
      });

      var res = factory(resolve, reject);

      if (isObject(res)) {
        if (typeof res.then === 'function') {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isDef(res.component) && typeof res.component.then === 'function') {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              setTimeout(function () {
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender();
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            setTimeout(function () {
              if (isUndef(factory.resolved)) {
                reject("timeout (" + res.timeout + "ms)");
              }
            }, res.timeout);
          }
        }
      }

      sync = false;
      // return in case resolved synchronously
      return factory.loading ? factory.loadingComp : factory.resolved;
    }
  }

  /*  */

  function getFirstComponentChild(children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && isDef(c.componentOptions)) {
          return c;
        }
      }
    }
  }

  /*  */

  /*  */

  function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }

  var target;

  function add(event, fn, once$$1) {
    if (once$$1) {
      target.$once(event, fn);
    } else {
      target.$on(event, fn);
    }
  }

  function remove$1(event, fn) {
    target.$off(event, fn);
  }

  function updateComponentListeners(vm, listeners, oldListeners) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  }

  function eventsMixin(Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
      var this$1 = this;

      var vm = this;
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          this$1.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        // optimize hook:event cost by using a boolean flag marked at registration
        // instead of a hash lookup
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm;
    };

    Vue.prototype.$once = function (event, fn) {
      var vm = this;
      function on() {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }
      on.fn = fn;
      vm.$on(event, on);
      return vm;
    };

    Vue.prototype.$off = function (event, fn) {
      var this$1 = this;

      var vm = this;
      // all
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm;
      }
      // array of events
      if (Array.isArray(event)) {
        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
          this$1.$off(event[i$1], fn);
        }
        return vm;
      }
      // specific event
      var cbs = vm._events[event];
      if (!cbs) {
        return vm;
      }
      if (arguments.length === 1) {
        vm._events[event] = null;
        return vm;
      }
      // specific handler
      var cb;
      var i = cbs.length;
      while (i--) {
        cb = cbs[i];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i, 1);
          break;
        }
      }
      return vm;
    };

    Vue.prototype.$emit = function (event) {
      var vm = this;
      {
        var lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
          tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
        }
      }
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
        var args = toArray(arguments, 1);
        for (var i = 0, l = cbs.length; i < l; i++) {
          try {
            cbs[i].apply(vm, args);
          } catch (e) {
            handleError(e, vm, "event handler for \"" + event + "\"");
          }
        }
      }
      return vm;
    };
  }

  /*  */

  /**
   * Runtime helper for resolving raw children VNodes into a slot object.
   */
  function resolveSlots(children, context) {
    var slots = {};
    if (!children) {
      return slots;
    }
    var defaultSlot = [];
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      // named slots should only be respected if the vnode was rendered in the
      // same context.
      if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {
        var name = child.data.slot;
        var slot = slots[name] || (slots[name] = []);
        if (child.tag === 'template') {
          slot.push.apply(slot, child.children);
        } else {
          slot.push(child);
        }
      } else {
        defaultSlot.push(child);
      }
    }
    // ignore whitespace
    if (!defaultSlot.every(isWhitespace)) {
      slots.default = defaultSlot;
    }
    return slots;
  }

  function isWhitespace(node) {
    return node.isComment || node.text === ' ';
  }

  function resolveScopedSlots(fns, // see flow/vnode
  res) {
    res = res || {};
    for (var i = 0; i < fns.length; i++) {
      if (Array.isArray(fns[i])) {
        resolveScopedSlots(fns[i], res);
      } else {
        res[fns[i].key] = fns[i].fn;
      }
    }
    return res;
  }

  /*  */

  var activeInstance = null;
  var isUpdatingChildComponent = false;

  function initLifecycle(vm) {
    var options = vm.$options;

    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }

  function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      var vm = this;
      if (vm._isMounted) {
        callHook(vm, 'beforeUpdate');
      }
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var prevActiveInstance = activeInstance;
      activeInstance = vm;
      vm._vnode = vnode;
      // Vue.prototype.__patch__ is injected in entry points
      // based on the rendering backend used.
      if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
        , vm.$options._parentElm, vm.$options._refElm);
        // no need for the ref nodes after initial patch
        // this prevents keeping a detached DOM tree in memory (#5851)
        vm.$options._parentElm = vm.$options._refElm = null;
      } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      activeInstance = prevActiveInstance;
      // update __vue__ reference
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      // if parent is an HOC, update its $el as well
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
      // updated hook is called by the scheduler to ensure that children are
      // updated in a parent's updated hook.
    };

    Vue.prototype.$forceUpdate = function () {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };

    Vue.prototype.$destroy = function () {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return;
      }
      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true;
      // remove self from parent
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      // teardown watchers
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      // remove reference from data ob
      // frozen object may not have observer.
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      // call the last hook...
      vm._isDestroyed = true;
      // invoke destroy hooks on current rendered tree
      vm.__patch__(vm._vnode, null);
      // fire destroyed hook
      callHook(vm, 'destroyed');
      // turn off all instance listeners.
      vm.$off();
      // remove __vue__ reference
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
    };
  }

  function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
      {
        /* istanbul ignore if */
        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
        } else {
          warn('Failed to mount component: template or render function not defined.', vm);
        }
      }
    }
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      updateComponent = function () {
        var name = vm._name;
        var id = vm._uid;
        var startTag = "vue-perf-start:" + id;
        var endTag = "vue-perf-end:" + id;

        mark(startTag);
        var vnode = vm._render();
        mark(endTag);
        measure(name + " render", startTag, endTag);

        mark(startTag);
        vm._update(vnode, hydrating);
        mark(endTag);
        measure(name + " patch", startTag, endTag);
      };
    } else {
      updateComponent = function () {
        vm._update(vm._render(), hydrating);
      };
    }

    vm._watcher = new Watcher(vm, updateComponent, noop);
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }
    return vm;
  }

  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    {
      isUpdatingChildComponent = true;
    }

    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren
    var hasChildren = !!(renderChildren || // has new static slots
    vm.$options._renderChildren || // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
    );

    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) {
      // update child tree's parent
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // update $attrs and $listensers hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    vm.$attrs = parentVnode.data && parentVnode.data.attrs;
    vm.$listeners = listeners;

    // update props
    if (propsData && vm.$options.props) {
      observerState.shouldConvert = false;
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        props[key] = validateProp(key, vm.$options.props, propsData, vm);
      }
      observerState.shouldConvert = true;
      // keep a copy of raw propsData
      vm.$options.propsData = propsData;
    }

    // update listeners
    if (listeners) {
      var oldListeners = vm.$options._parentListeners;
      vm.$options._parentListeners = listeners;
      updateComponentListeners(vm, listeners, oldListeners);
    }
    // resolve slots + force update if has children
    if (hasChildren) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }

    {
      isUpdatingChildComponent = false;
    }
  }

  function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) {
        return true;
      }
    }
    return false;
  }

  function activateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = false;
      if (isInInactiveTree(vm)) {
        return;
      }
    } else if (vm._directInactive) {
      return;
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'activated');
    }
  }

  function deactivateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return;
      }
    }
    if (!vm._inactive) {
      vm._inactive = true;
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'deactivated');
    }
  }

  function callHook(vm, hook) {
    var handlers = vm.$options[hook];
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        try {
          handlers[i].call(vm);
        } catch (e) {
          handleError(e, vm, hook + " hook");
        }
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
  }

  /*  */

  var MAX_UPDATE_COUNT = 100;

  var queue = [];
  var activatedChildren = [];
  var has = {};
  var circular = {};
  var waiting = false;
  var flushing = false;
  var index = 0;

  /**
   * Reset the scheduler's state.
   */
  function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
      circular = {};
    }
    waiting = flushing = false;
  }

  /**
   * Flush both queues and run the watchers.
   */
  function flushSchedulerQueue() {
    flushing = true;
    var watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(function (a, b) {
      return a.id - b.id;
    });

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      id = watcher.id;
      has[id] = null;
      watcher.run();
      // in dev build, check and stop circular updates.
      if ("development" !== 'production' && has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;
        if (circular[id] > MAX_UPDATE_COUNT) {
          warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
          break;
        }
      }
    }

    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }

  function callUpdatedHooks(queue) {
    var i = queue.length;
    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted) {
        callHook(vm, 'updated');
      }
    }
  }

  /**
   * Queue a kept-alive component that was activated during patch.
   * The queue will be processed after the entire tree has been patched.
   */
  function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks(queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true /* true */);
    }
  }

  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */
  function queueWatcher(watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      // queue the flush
      if (!waiting) {
        waiting = true;
        nextTick(flushSchedulerQueue);
      }
    }
  }

  /*  */

  var uid$2 = 0;

  /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   */
  var Watcher = function Watcher(vm, expOrFn, cb, options) {
    this.vm = vm;
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = function () {};
        "development" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
      }
    }
    this.value = this.lazy ? undefined : this.get();
  };

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  Watcher.prototype.get = function get() {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
      } else {
        throw e;
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value;
  };

  /**
   * Add a dependency to this directive.
   */
  Watcher.prototype.addDep = function addDep(dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };

  /**
   * Clean up for dependency collection.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps() {
    var this$1 = this;

    var i = this.deps.length;
    while (i--) {
      var dep = this$1.deps[i];
      if (!this$1.newDepIds.has(dep.id)) {
        dep.removeSub(this$1);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  Watcher.prototype.update = function update() {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  Watcher.prototype.run = function run() {
    if (this.active) {
      var value = this.get();
      if (value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) || this.deep) {
        // set new value
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  Watcher.prototype.evaluate = function evaluate() {
    this.value = this.get();
    this.dirty = false;
  };

  /**
   * Depend on all deps collected by this watcher.
   */
  Watcher.prototype.depend = function depend() {
    var this$1 = this;

    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].depend();
    }
  };

  /**
   * Remove self from all dependencies' subscriber list.
   */
  Watcher.prototype.teardown = function teardown() {
    var this$1 = this;

    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this$1.deps[i].removeSub(this$1);
      }
      this.active = false;
    }
  };

  /**
   * Recursively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   */
  var seenObjects = new _Set();
  function traverse(val) {
    seenObjects.clear();
    _traverse(val, seenObjects);
  }

  function _traverse(val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if (!isA && !isObject(val) || !Object.isExtensible(val)) {
      return;
    }
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;
      if (seen.has(depId)) {
        return;
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      while (i--) {
        _traverse(val[i], seen);
      }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      while (i--) {
        _traverse(val[keys[i]], seen);
      }
    }
  }

  /*  */

  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };

  function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
      return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
      this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function initState(vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) {
      initProps(vm, opts.props);
    }
    if (opts.methods) {
      initMethods(vm, opts.methods);
    }
    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) {
      initComputed(vm, opts.computed);
    }
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }

  function checkOptionType(vm, name) {
    var option = vm.$options[name];
    if (!isPlainObject(option)) {
      warn("component option \"" + name + "\" should be an object.", vm);
    }
  }

  function initProps(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // root instance props should be converted
    observerState.shouldConvert = isRoot;
    var loop = function (key) {
      keys.push(key);
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */
      {
        if (isReservedAttribute(key) || config.isReservedAttr(key)) {
          warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
        }
        defineReactive$$1(props, key, value, function () {
          if (vm.$parent && !isUpdatingChildComponent) {
            warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
          }
        });
      }
      // static props are already proxied on the component's prototype
      // during Vue.extend(). We only need to proxy props defined at
      // instantiation here.
      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) loop(key);
    observerState.shouldConvert = true;
  }

  function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
      data = {};
      "development" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      {
        if (methods && hasOwn(methods, key)) {
          warn("method \"" + key + "\" has already been defined as a data property.", vm);
        }
      }
      if (props && hasOwn(props, key)) {
        "development" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    // observe data
    observe(data, true /* asRootData */);
  }

  function getData(data, vm) {
    try {
      return data.call(vm);
    } catch (e) {
      handleError(e, vm, "data()");
      return {};
    }
  }

  var computedWatcherOptions = { lazy: true };

  function initComputed(vm, computed) {
    "development" !== 'production' && checkOptionType(vm, 'computed');
    var watchers = vm._computedWatchers = Object.create(null);

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      if ("development" !== 'production' && getter == null) {
        warn("Getter is missing for computed property \"" + key + "\".", vm);
      }
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);

      // component-defined computed properties are already defined on the
      // component prototype. We only need to define computed properties defined
      // at instantiation here.
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {
        if (key in vm.$data) {
          warn("The computed property \"" + key + "\" is already defined in data.", vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
        }
      }
    }
  }

  function defineComputed(target, key, userDef) {
    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = createComputedGetter(key);
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
      sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
    }
    if ("development" !== 'production' && sharedPropertyDefinition.set === noop) {
      sharedPropertyDefinition.set = function () {
        warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
      };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function createComputedGetter(key) {
    return function computedGetter() {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value;
      }
    };
  }

  function initMethods(vm, methods) {
    "development" !== 'production' && checkOptionType(vm, 'methods');
    var props = vm.$options.props;
    for (var key in methods) {
      vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
      {
        if (methods[key] == null) {
          warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
        }
        if (props && hasOwn(props, key)) {
          warn("method \"" + key + "\" has already been defined as a prop.", vm);
        }
      }
    }
  }

  function initWatch(vm, watch) {
    "development" !== 'production' && checkOptionType(vm, 'watch');
    for (var key in watch) {
      var handler = watch[key];
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }

  function createWatcher(vm, keyOrFn, handler, options) {
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(keyOrFn, handler, options);
  }

  function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () {
      return this._data;
    };
    var propsDef = {};
    propsDef.get = function () {
      return this._props;
    };
    {
      dataDef.set = function (newData) {
        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
      };
      propsDef.set = function () {
        warn("$props is readonly.", this);
      };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (expOrFn, cb, options) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options);
      }
      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        cb.call(vm, watcher.value);
      }
      return function unwatchFn() {
        watcher.teardown();
      };
    };
  }

  /*  */

  function initProvide(vm) {
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
    }
  }

  function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      observerState.shouldConvert = false;
      Object.keys(result).forEach(function (key) {
        /* istanbul ignore else */
        {
          defineReactive$$1(vm, key, result[key], function () {
            warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
          });
        }
      });
      observerState.shouldConvert = true;
    }
  }

  function resolveInject(inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var provideKey = inject[key];
        var source = vm;
        while (source) {
          if (source._provided && provideKey in source._provided) {
            result[key] = source._provided[provideKey];
            break;
          }
          source = source.$parent;
        }
        if ("development" !== 'production' && !source) {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
      return result;
    }
  }

  /*  */

  function createFunctionalComponent(Ctor, propsData, data, context, children) {
    var props = {};
    var propOptions = Ctor.options.props;
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props[key] = validateProp(key, propOptions, propsData || {});
      }
    } else {
      if (isDef(data.attrs)) {
        mergeProps(props, data.attrs);
      }
      if (isDef(data.props)) {
        mergeProps(props, data.props);
      }
    }
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var _context = Object.create(context);
    var h = function (a, b, c, d) {
      return createElement(_context, a, b, c, d, true);
    };
    var vnode = Ctor.options.render.call(null, h, {
      data: data,
      props: props,
      children: children,
      parent: context,
      listeners: data.on || {},
      injections: resolveInject(Ctor.options.inject, context),
      slots: function () {
        return resolveSlots(children, context);
      }
    });
    if (vnode instanceof VNode) {
      vnode.functionalContext = context;
      vnode.functionalOptions = Ctor.options;
      if (data.slot) {
        (vnode.data || (vnode.data = {})).slot = data.slot;
      }
    }
    return vnode;
  }

  function mergeProps(to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }

  /*  */

  // hooks to be invoked on component VNodes during patch
  var componentVNodeHooks = {
    init: function init(vnode, hydrating, parentElm, refElm) {
      if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      } else if (vnode.data.keepAlive) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      }
    },

    prepatch: function prepatch(oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(child, options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
      );
    },

    insert: function insert(vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },

    destroy: function destroy(vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true /* direct */);
        }
      }
    }
  };

  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
      return;
    }

    var baseCtor = context.$options._base;

    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }

    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
      {
        warn("Invalid Component definition: " + String(Ctor), context);
      }
      return;
    }

    // async component
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
      if (Ctor === undefined) {
        // return a placeholder node for async component, which is rendered
        // as a comment node but preserves all the raw information for the node.
        // the information will be used for async server-rendering and hydration.
        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
      }
    }

    data = data || {};

    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);

    // transform component v-model data into props & events
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }

    // extract props
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);

    // functional component
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children);
    }

    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // abstract components do not keep anything
      // other than props & listeners & slot

      // work around flow
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }

    // merge component management hooks onto the placeholder node
    mergeHooks(data);

    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
    return vnode;
  }

  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm, refElm) {
    var vnodeComponentOptions = vnode.componentOptions;
    var options = {
      _isComponent: true,
      parent: parent,
      propsData: vnodeComponentOptions.propsData,
      _componentTag: vnodeComponentOptions.tag,
      _parentVnode: vnode,
      _parentListeners: vnodeComponentOptions.listeners,
      _renderChildren: vnodeComponentOptions.children,
      _parentElm: parentElm || null,
      _refElm: refElm || null
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnodeComponentOptions.Ctor(options);
  }

  function mergeHooks(data) {
    if (!data.hook) {
      data.hook = {};
    }
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      var fromParent = data.hook[key];
      var ours = componentVNodeHooks[key];
      data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
    }
  }

  function mergeHook$1(one, two) {
    return function (a, b, c, d) {
      one(a, b, c, d);
      two(a, b, c, d);
    };
  }

  // transform component v-model info (value and callback) into
  // prop and event handler respectively.
  function transformModel(options, data) {
    var prop = options.model && options.model.prop || 'value';
    var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    if (isDef(on[event])) {
      on[event] = [data.model.callback].concat(on[event]);
    } else {
      on[event] = data.model.callback;
    }
  }

  /*  */

  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;

  // wrapper function for providing a more flexible interface
  // without getting yelled at by flow
  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
  }

  function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
      "development" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
      return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      // in case of component :is set to falsy value
      return createEmptyVNode();
    }
    // warn against non-primitive key
    if ("development" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
    // support single function children as default scoped slot
    if (Array.isArray(children) && typeof children[0] === 'function') {
      data = data || {};
      data.scopedSlots = { default: children[0] };
      children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
      var Ctor;
      ns = config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        // platform built-in elements
        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
      } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        // component
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // unknown or unlisted namespaced elements
        // check at runtime because it may get assigned a namespace when its
        // parent normalizes children
        vnode = new VNode(tag, data, children, undefined, undefined, context);
      }
    } else {
      // direct component options / constructor
      vnode = createComponent(tag, data, context, children);
    }
    if (isDef(vnode)) {
      if (ns) {
        applyNS(vnode, ns);
      }
      return vnode;
    } else {
      return createEmptyVNode();
    }
  }

  function applyNS(vnode, ns) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
      // use default namespace inside foreignObject
      return;
    }
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && isUndef(child.ns)) {
          applyNS(child, ns);
        }
      }
    }
  }

  /*  */

  /**
   * Runtime helper for rendering v-for lists.
   */
  function renderList(val, render) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === 'number') {
      ret = new Array(val);
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject(val)) {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
    if (isDef(ret)) {
      ret._isVList = true;
    }
    return ret;
  }

  /*  */

  /**
   * Runtime helper for rendering <slot>
   */
  function renderSlot(name, fallback, props, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name];
    if (scopedSlotFn) {
      // scoped slot
      props = props || {};
      if (bindObject) {
        props = extend(extend({}, bindObject), props);
      }
      return scopedSlotFn(props) || fallback;
    } else {
      var slotNodes = this.$slots[name];
      // warn duplicate slot usage
      if (slotNodes && "development" !== 'production') {
        slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
        slotNodes._rendered = true;
      }
      return slotNodes || fallback;
    }
  }

  /*  */

  /**
   * Runtime helper for resolving filters
   */
  function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
  }

  /*  */

  /**
   * Runtime helper for checking keyCodes from config.
   */
  function checkKeyCodes(eventKeyCode, key, builtInAlias) {
    var keyCodes = config.keyCodes[key] || builtInAlias;
    if (Array.isArray(keyCodes)) {
      return keyCodes.indexOf(eventKeyCode) === -1;
    } else {
      return keyCodes !== eventKeyCode;
    }
  }

  /*  */

  /**
   * Runtime helper for merging v-bind="object" into a VNode's data.
   */
  function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
      if (!isObject(value)) {
        "development" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function (key) {
          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
          }
          if (!(key in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});
              on["update:" + key] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) loop(key);
      }
    }
    return data;
  }

  /*  */

  /**
   * Runtime helper for rendering static trees.
   */
  function renderStatic(index, isInFor) {
    var tree = this._staticTrees[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree by doing a shallow clone.
    if (tree && !isInFor) {
      return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
    }
    // otherwise, render a fresh tree.
    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
    markStatic(tree, "__static__" + index, false);
    return tree;
  }

  /**
   * Runtime helper for v-once.
   * Effectively it means marking the node as static with a unique key.
   */
  function markOnce(tree, index, key) {
    markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
    return tree;
  }

  function markStatic(tree, key, isOnce) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], key + "_" + i, isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }

  function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }

  /*  */

  function bindObjectListeners(data, value) {
    if (value) {
      if (!isPlainObject(value)) {
        "development" !== 'production' && warn('v-on without argument expects an Object value', this);
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(ours, existing) : ours;
        }
      }
    }
    return data;
  }

  /*  */

  function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null;
    var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    vm._c = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, false);
    };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    vm.$createElement = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, true);
    };

    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;
    /* istanbul ignore else */
    {
      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {
        !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
      }, true);
      defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {
        !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
      }, true);
    }
  }

  function renderMixin(Vue) {
    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this);
    };

    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      var _parentVnode = ref._parentVnode;

      if (vm._isMounted) {
        // clone slot nodes on re-renders
        for (var key in vm.$slots) {
          vm.$slots[key] = cloneVNodes(vm.$slots[key]);
        }
      }

      vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

      if (staticRenderFns && !vm._staticTrees) {
        vm._staticTrees = [];
      }
      // set parent vnode. this allows render functions to have access
      // to the data on the placeholder node.
      vm.$vnode = _parentVnode;
      // render self
      var vnode;
      try {
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render function");
        // return error render result,
        // or previous vnode to prevent render error causing blank component
        /* istanbul ignore else */
        {
          vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
        }
      }
      // return empty vnode in case the render function errored out
      if (!(vnode instanceof VNode)) {
        if ("development" !== 'production' && Array.isArray(vnode)) {
          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
        }
        vnode = createEmptyVNode();
      }
      // set parent
      vnode.parent = _parentVnode;
      return vnode;
    };

    // internal render helpers.
    // these are exposed on the instance prototype to reduce generated render
    // code size.
    Vue.prototype._o = markOnce;
    Vue.prototype._n = toNumber;
    Vue.prototype._s = toString;
    Vue.prototype._l = renderList;
    Vue.prototype._t = renderSlot;
    Vue.prototype._q = looseEqual;
    Vue.prototype._i = looseIndexOf;
    Vue.prototype._m = renderStatic;
    Vue.prototype._f = resolveFilter;
    Vue.prototype._k = checkKeyCodes;
    Vue.prototype._b = bindObjectProps;
    Vue.prototype._v = createTextVNode;
    Vue.prototype._e = createEmptyVNode;
    Vue.prototype._u = resolveScopedSlots;
    Vue.prototype._g = bindObjectListeners;
  }

  /*  */

  var uid$1 = 0;

  function initMixin(Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      vm._uid = uid$1++;

      var startTag, endTag;
      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        startTag = "vue-perf-init:" + vm._uid;
        endTag = "vue-perf-end:" + vm._uid;
        mark(startTag);
      }

      // a flag to avoid this being observed
      vm._isVue = true;
      // merge options
      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
      }
      /* istanbul ignore else */
      {
        initProxy(vm);
      }
      // expose real self
      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, 'beforeCreate');
      initInjections(vm); // resolve injections before data/props
      initState(vm);
      initProvide(vm); // resolve provide after data/props
      callHook(vm, 'created');

      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        vm._name = formatComponentName(vm, false);
        mark(endTag);
        measure(vm._name + " init", startTag, endTag);
      }

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }

  function initInternalComponent(vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // doing this because it's faster than dynamic enumeration.
    opts.parent = options.parent;
    opts.propsData = options.propsData;
    opts._parentVnode = options._parentVnode;
    opts._parentListeners = options._parentListeners;
    opts._renderChildren = options._renderChildren;
    opts._componentTag = options._componentTag;
    opts._parentElm = options._parentElm;
    opts._refElm = options._refElm;
    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
      if (superOptions !== cachedSuperOptions) {
        // super option changed,
        // need to resolve new options.
        Ctor.superOptions = superOptions;
        // check if there are any late-modified/attached options (#4976)
        var modifiedOptions = resolveModifiedOptions(Ctor);
        // update base extend options
        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options;
  }

  function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var extended = Ctor.extendOptions;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) {
          modified = {};
        }
        modified[key] = dedupe(latest[key], extended[key], sealed[key]);
      }
    }
    return modified;
  }

  function dedupe(latest, extended, sealed) {
    // compare latest and sealed to ensure lifecycle hooks won't be duplicated
    // between merges
    if (Array.isArray(latest)) {
      var res = [];
      sealed = Array.isArray(sealed) ? sealed : [sealed];
      extended = Array.isArray(extended) ? extended : [extended];
      for (var i = 0; i < latest.length; i++) {
        // push original options and not sealed options to exclude duplicated options
        if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
          res.push(latest[i]);
        }
      }
      return res;
    } else {
      return latest;
    }
  }

  function Vue$3(options) {
    if ("development" !== 'production' && !(this instanceof Vue$3)) {
      warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
  }

  initMixin(Vue$3);
  stateMixin(Vue$3);
  eventsMixin(Vue$3);
  lifecycleMixin(Vue$3);
  renderMixin(Vue$3);

  /*  */

  function initUse(Vue) {
    Vue.use = function (plugin) {
      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
      if (installedPlugins.indexOf(plugin) > -1) {
        return this;
      }

      // additional parameters
      var args = toArray(arguments, 1);
      args.unshift(this);
      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this;
    };
  }

  /*  */

  function initMixin$1(Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this;
    };
  }

  /*  */

  function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;

    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId];
      }

      var name = extendOptions.name || Super.options.name;
      {
        if (!/^[a-zA-Z][\w-]*$/.test(name)) {
          warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
        }
      }

      var Sub = function VueComponent(options) {
        this._init(options);
      };
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(Super.options, extendOptions);
      Sub['super'] = Super;

      // For props and computed properties, we define the proxy getters on
      // the Vue instances at extension time, on the extended prototype. This
      // avoids Object.defineProperty calls for each instance created.
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }

      // allow further extension/mixin/plugin usage
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;

      // create asset registers, so extended classes
      // can have their private assets too.
      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      });
      // enable recursive self-lookup
      if (name) {
        Sub.options.components[name] = Sub;
      }

      // keep a reference to the super options at extension time.
      // later at instantiation we can check if Super's options have
      // been updated.
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);

      // cache constructor
      cachedCtors[SuperId] = Sub;
      return Sub;
    };
  }

  function initProps$1(Comp) {
    var props = Comp.options.props;
    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }

  function initComputed$1(Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }

  /*  */

  function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (id, definition) {
        if (!definition) {
          return this.options[type + 's'][id];
        } else {
          /* istanbul ignore if */
          {
            if (type === 'component' && config.isReservedTag(id)) {
              warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
            }
          }
          if (type === 'component' && isPlainObject(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }
          if (type === 'directive' && typeof definition === 'function') {
            definition = { bind: definition, update: definition };
          }
          this.options[type + 's'][id] = definition;
          return definition;
        }
      };
    });
  }

  /*  */

  var patternTypes = [String, RegExp, Array];

  function getComponentName(opts) {
    return opts && (opts.Ctor.options.name || opts.tag);
  }

  function matches(pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1;
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1;
    } else if (isRegExp(pattern)) {
      return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
  }

  function pruneCache(cache, current, filter) {
    for (var key in cache) {
      var cachedNode = cache[key];
      if (cachedNode) {
        var name = getComponentName(cachedNode.componentOptions);
        if (name && !filter(name)) {
          if (cachedNode !== current) {
            pruneCacheEntry(cachedNode);
          }
          cache[key] = null;
        }
      }
    }
  }

  function pruneCacheEntry(vnode) {
    if (vnode) {
      vnode.componentInstance.$destroy();
    }
  }

  var KeepAlive = {
    name: 'keep-alive',
    abstract: true,

    props: {
      include: patternTypes,
      exclude: patternTypes
    },

    created: function created() {
      this.cache = Object.create(null);
    },

    destroyed: function destroyed() {
      var this$1 = this;

      for (var key in this$1.cache) {
        pruneCacheEntry(this$1.cache[key]);
      }
    },

    watch: {
      include: function include(val) {
        pruneCache(this.cache, this._vnode, function (name) {
          return matches(val, name);
        });
      },
      exclude: function exclude(val) {
        pruneCache(this.cache, this._vnode, function (name) {
          return !matches(val, name);
        });
      }
    },

    render: function render() {
      var vnode = getFirstComponentChild(this.$slots.default);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        // check pattern
        var name = getComponentName(componentOptions);
        if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
          return vnode;
        }
        var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
        if (this.cache[key]) {
          vnode.componentInstance = this.cache[key].componentInstance;
        } else {
          this.cache[key] = vnode;
        }
        vnode.data.keepAlive = true;
      }
      return vnode;
    }
  };

  var builtInComponents = {
    KeepAlive: KeepAlive
  };

  /*  */

  function initGlobalAPI(Vue) {
    // config
    var configDef = {};
    configDef.get = function () {
      return config;
    };
    {
      configDef.set = function () {
        warn('Do not replace the Vue.config object, set individual fields instead.');
      };
    }
    Object.defineProperty(Vue, 'config', configDef);

    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive$$1
    };

    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    });

    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;

    extend(Vue.options.components, builtInComponents);

    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue$3);

  Object.defineProperty(Vue$3.prototype, '$isServer', {
    get: isServerRendering
  });

  Object.defineProperty(Vue$3.prototype, '$ssrContext', {
    get: function get() {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext;
    }
  });

  Vue$3.version = '2.4.2';

  /*  */

  // these are reserved for web because they are directly compiled away
  // during template compilation
  var isReservedAttr = makeMap('style,class');

  // attributes that should be using props for binding
  var acceptValue = makeMap('input,textarea,option,select');
  var mustUseProp = function (tag, type, attr) {
    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
  };

  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function (name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
  };

  var getXlinkProp = function (name) {
    return isXlink(name) ? name.slice(6, name.length) : '';
  };

  var isFalsyAttrValue = function (val) {
    return val == null || val === false;
  };

  /*  */

  function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }
    return renderClass(data.staticClass, data.class);
  }

  function mergeClassData(child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
  }

  function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
  }

  function concat(a, b) {
    return a ? b ? a + ' ' + b : a : b || '';
  }

  function stringifyClass(value) {
    if (Array.isArray(value)) {
      return stringifyArray(value);
    }
    if (isObject(value)) {
      return stringifyObject(value);
    }
    if (typeof value === 'string') {
      return value;
    }
    /* istanbul ignore next */
    return '';
  }

  function stringifyArray(value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) {
          res += ' ';
        }
        res += stringified;
      }
    }
    return res;
  }

  function stringifyObject(value) {
    var res = '';
    for (var key in value) {
      if (value[key]) {
        if (res) {
          res += ' ';
        }
        res += key;
      }
    }
    return res;
  }

  /*  */

  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };

  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

  // this map is intentionally selective, only covering SVG elements that may
  // contain child elements.
  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

  var isPreTag = function (tag) {
    return tag === 'pre';
  };

  var isReservedTag = function (tag) {
    return isHTMLTag(tag) || isSVG(tag);
  };

  function getTagNamespace(tag) {
    if (isSVG(tag)) {
      return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
      return 'math';
    }
  }

  var unknownElementCache = Object.create(null);
  function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true;
    }
    if (isReservedTag(tag)) {
      return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag];
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
    } else {
      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
    }
  }

  /*  */

  /**
   * Query an element selector if it's not an element already.
   */
  function query(el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);
      if (!selected) {
        "development" !== 'production' && warn('Cannot find element: ' + el);
        return document.createElement('div');
      }
      return selected;
    } else {
      return el;
    }
  }

  /*  */

  function createElement$1(tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
      return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }
    return elm;
  }

  function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
  }

  function createTextNode(text) {
    return document.createTextNode(text);
  }

  function createComment(text) {
    return document.createComment(text);
  }

  function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }

  function removeChild(node, child) {
    node.removeChild(child);
  }

  function appendChild(node, child) {
    node.appendChild(child);
  }

  function parentNode(node) {
    return node.parentNode;
  }

  function nextSibling(node) {
    return node.nextSibling;
  }

  function tagName(node) {
    return node.tagName;
  }

  function setTextContent(node, text) {
    node.textContent = text;
  }

  function setAttribute(node, key, val) {
    node.setAttribute(key, val);
  }

  var nodeOps = Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setAttribute: setAttribute
  });

  /*  */

  var ref = {
    create: function create(_, vnode) {
      registerRef(vnode);
    },
    update: function update(oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy(vnode) {
      registerRef(vnode, true);
    }
  };

  function registerRef(vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!key) {
      return;
    }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
      } else {
        refs[key] = ref;
      }
    }
  }

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
  
  /*
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */

  var emptyNode = new VNode('', {}, []);

  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

  function sameVnode(a, b) {
    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
  }

  // Some browsers do not support dynamically changing type for <input>
  // so they need to be treated as different nodes
  function sameInputType(a, b) {
    if (a.tag !== 'input') {
      return true;
    }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB;
  }

  function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) {
        map[key] = i;
      }
    }
    return map;
  }

  function createPatchFunction(backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }

    function emptyNodeAt(elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }

    function createRmCb(childElm, listeners) {
      function remove$$1() {
        if (--remove$$1.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove$$1.listeners = listeners;
      return remove$$1;
    }

    function removeNode(el) {
      var parent = nodeOps.parentNode(el);
      // element may have already been removed due to v-html / v-text
      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }

    var inPre = 0;
    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
      vnode.isRootInsert = !nested; // for transition enter check
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return;
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {
        {
          if (data && data.pre) {
            inPre++;
          }
          if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
          }
        }
        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }

        if ("development" !== 'production' && data && data.pre) {
          inPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */, parentElm, refElm);
        }
        // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true;
        }
      }
    }

    function initComponent(vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // empty component root.
        // skip all element-related modules except for ref (#3455)
        registerRef(vnode);
        // make sure to invoke the insert hook
        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i;
      // hack for #4339: a reactivated component with inner transition
      // does not trigger because the inner node's created hooks are not called
      // again. It's not ideal to involve module-specific logic in here but
      // there doesn't seem to be a better way to do it.
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break;
        }
      }
      // unlike a newly created component,
      // a reactivated keep-alive component doesn't insert itself
      insert(parentElm, vnode.elm, refElm);
    }

    function insert(parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (ref$$1.parentNode === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }

    function createChildren(vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; ++i) {
          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
      }
    }

    function isPatchable(vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }
      return isDef(vnode.tag);
    }

    function invokeCreateHooks(vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (isDef(i.create)) {
          i.create(emptyNode, vnode);
        }
        if (isDef(i.insert)) {
          insertedVnodeQueue.push(vnode);
        }
      }
    }

    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
      var i;
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setAttribute(vnode.elm, i, '');
        }
        ancestor = ancestor.parent;
      }
      // for slot content they should also get the scopeId from the host instance.
      if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
    }

    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
      }
    }

    function invokeDestroyHook(vnode) {
      var i, j;
      var data = vnode.data;
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.destroy)) {
          i(vnode);
        }
        for (i = 0; i < cbs.destroy.length; ++i) {
          cbs.destroy[i](vnode);
        }
      }
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }

    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];
        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else {
            // Text node
            removeNode(ch.elm);
          }
        }
      }
    }

    function removeAndInvokeRemoveHook(vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i;
        var listeners = cbs.remove.length + 1;
        if (isDef(rm)) {
          // we have a recursively passed down rm callback
          // increase the listeners count
          rm.listeners += listeners;
        } else {
          // directly removing
          rm = createRmCb(vnode.elm, listeners);
        }
        // recursively invoke hooks on child component root node
        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
          removeAndInvokeRemoveHook(i, rm);
        }
        for (i = 0; i < cbs.remove.length; ++i) {
          cbs.remove[i](vnode, rm);
        }
        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
          i(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }

    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, elmToMove, refElm;

      // removeOnly is a special flag used only by <transition-group>
      // to ensure removed elements stay in correct relative positions
      // during leaving transitions
      var canMove = !removeOnly;

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) {
          // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) {
          // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) {
            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          }
          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
          if (isUndef(idxInOld)) {
            // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            elmToMove = oldCh[idxInOld];
            /* istanbul ignore if */
            if ("development" !== 'production' && !elmToMove) {
              warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
            }
            if (sameVnode(elmToMove, newStartVnode)) {
              patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
              oldCh[idxInOld] = undefined;
              canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
              newStartVnode = newCh[++newStartIdx];
            } else {
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
              newStartVnode = newCh[++newStartIdx];
            }
          }
        }
      }
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }

    function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
      if (oldVnode === vnode) {
        return;
      }

      var elm = vnode.elm = oldVnode.elm;

      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }
        return;
      }

      // reuse element for static trees.
      // note we only do this if the vnode is cloned -
      // if the new node is not cloned it means the render functions have been
      // reset by the hot-reload-api and we need to do a proper re-render.
      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
        vnode.componentInstance = oldVnode.componentInstance;
        return;
      }

      var i;
      var data = vnode.data;
      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
      }

      var oldCh = oldVnode.children;
      var ch = vnode.children;
      if (isDef(data) && isPatchable(vnode)) {
        for (i = 0; i < cbs.update.length; ++i) {
          cbs.update[i](oldVnode, vnode);
        }
        if (isDef(i = data.hook) && isDef(i = i.update)) {
          i(oldVnode, vnode);
        }
      }
      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) {
            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
          }
        } else if (isDef(ch)) {
          if (isDef(oldVnode.text)) {
            nodeOps.setTextContent(elm, '');
          }
          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(elm, oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
          i(oldVnode, vnode);
        }
      }
    }

    function invokeInsertHook(vnode, queue, initial) {
      // delay insert hooks for component root nodes, invoke them after the
      // element is really inserted
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue;
      } else {
        for (var i = 0; i < queue.length; ++i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }

    var bailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue) {
      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.elm = elm;
        vnode.isAsyncPlaceholder = true;
        return true;
      }
      {
        if (!assertNodeMatch(elm, vnode)) {
          return false;
        }
      }
      vnode.elm = elm;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.init)) {
          i(vnode, true /* hydrating */);
        }
        if (isDef(i = vnode.componentInstance)) {
          // child component. it should have hydrated its own tree.
          initComponent(vnode, insertedVnodeQueue);
          return true;
        }
      }
      if (isDef(tag)) {
        if (isDef(children)) {
          // empty element, allow client to pick up and populate children
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              if ("development" !== 'production' && typeof console !== 'undefined' && !bailed) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false;
            }
          }
        }
        if (isDef(data)) {
          for (var key in data) {
            if (!isRenderedModule(key)) {
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break;
            }
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }
      return true;
    }

    function assertNodeMatch(node, vnode) {
      if (isDef(vnode.tag)) {
        return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
      } else {
        return node.nodeType === (vnode.isComment ? 8 : 3);
      }
    }

    return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) {
          invokeDestroyHook(oldVnode);
        }
        return;
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue, parentElm, refElm);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);
        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          // patch existing root node
          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
        } else {
          if (isRealElement) {
            // mounting to a real element
            // check if this is server-rendered content and if we can perform
            // a successful hydration.
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }
            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode;
              } else {
                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
              }
            }
            // either not server-rendered, or hydration failed.
            // create an empty node and replace it
            oldVnode = emptyNodeAt(oldVnode);
          }
          // replacing existing element
          var oldElm = oldVnode.elm;
          var parentElm$1 = nodeOps.parentNode(oldElm);
          createElm(vnode, insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

          if (isDef(vnode.parent)) {
            // component root element replaced.
            // update parent placeholder node element, recursively
            var ancestor = vnode.parent;
            while (ancestor) {
              ancestor.elm = vnode.elm;
              ancestor = ancestor.parent;
            }
            if (isPatchable(vnode)) {
              for (var i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, vnode.parent);
              }
            }
          }

          if (isDef(parentElm$1)) {
            removeVnodes(parentElm$1, [oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }

      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm;
    };
  }

  /*  */

  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };

  function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }

  function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

    var dirsWithInsert = [];
    var dirsWithPostpatch = [];

    var key, oldDir, dir;
    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];
      if (!oldDir) {
        // new directive, bind
        callHook$1(dir, 'bind', vnode, oldVnode);
        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        // existing directive, update
        dir.oldValue = oldDir.value;
        callHook$1(dir, 'update', vnode, oldVnode);
        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }

    if (dirsWithInsert.length) {
      var callInsert = function () {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
        }
      };
      if (isCreate) {
        mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
      } else {
        callInsert();
      }
    }

    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
        }
      });
    }

    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          // no longer present, unbind
          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }

  var emptyModifiers = Object.create(null);

  function normalizeDirectives$1(dirs, vm) {
    var res = Object.create(null);
    if (!dirs) {
      return res;
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];
      if (!dir.modifiers) {
        dir.modifiers = emptyModifiers;
      }
      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    return res;
  }

  function getRawDirName(dir) {
    return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
  }

  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
      }
    }
  }

  var baseModules = [ref, directives];

  /*  */

  function updateAttrs(oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
      return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return;
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__)) {
      attrs = vnode.data.attrs = extend({}, attrs);
    }

    for (key in attrs) {
      cur = attrs[key];
      old = oldAttrs[key];
      if (old !== cur) {
        setAttr(elm, key, cur);
      }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    /* istanbul ignore if */
    if (isIE9 && attrs.value !== oldAttrs.value) {
      setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
      if (isUndef(attrs[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }

  function setAttr(el, key, value) {
    if (isBooleanAttr(key)) {
      // set attribute for blank value
      // e.g. <option disabled>Select one</option>
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, key);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, value);
      }
    }
  }

  var attrs = {
    create: updateAttrs,
    update: updateAttrs
  };

  /*  */

  function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
      return;
    }

    var cls = genClassForVnode(vnode);

    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    }

    // set the class
    if (cls !== el._prevClass) {
      el.setAttribute('class', cls);
      el._prevClass = cls;
    }
  }

  var klass = {
    create: updateClass,
    update: updateClass
  };

  /*  */

  var validDivisionCharRE = /[\w).+\-_$\]]/;

  function parseFilters(exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;

    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 0x27 && prev !== 0x5C) {
          inSingle = false;
        }
      } else if (inDouble) {
        if (c === 0x22 && prev !== 0x5C) {
          inDouble = false;
        }
      } else if (inTemplateString) {
        if (c === 0x60 && prev !== 0x5C) {
          inTemplateString = false;
        }
      } else if (inRegex) {
        if (c === 0x2f && prev !== 0x5C) {
          inRegex = false;
        }
      } else if (c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
        if (expression === undefined) {
          // first filter, end of expression
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 0x22:
            inDouble = true;break; // "
          case 0x27:
            inSingle = true;break; // '
          case 0x60:
            inTemplateString = true;break; // `
          case 0x28:
            paren++;break; // (
          case 0x29:
            paren--;break; // )
          case 0x5B:
            square++;break; // [
          case 0x5D:
            square--;break; // ]
          case 0x7B:
            curly++;break; // {
          case 0x7D:
            curly--;break; // }
        }
        if (c === 0x2f) {
          // /
          var j = i - 1;
          var p = void 0;
          // find first non-whitespace prev char
          for (; j >= 0; j--) {
            p = exp.charAt(j);
            if (p !== ' ') {
              break;
            }
          }
          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }

    if (expression === undefined) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }

    function pushFilter() {
      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }

    if (filters) {
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i]);
      }
    }

    return expression;
  }

  function wrapFilter(exp, filter) {
    var i = filter.indexOf('(');
    if (i < 0) {
      // _f: resolveFilter
      return "_f(\"" + filter + "\")(" + exp + ")";
    } else {
      var name = filter.slice(0, i);
      var args = filter.slice(i + 1);
      return "_f(\"" + name + "\")(" + exp + "," + args;
    }
  }

  /*  */

  function baseWarn(msg) {
    console.error("[Vue compiler]: " + msg);
  }

  function pluckModuleFunction(modules, key) {
    return modules ? modules.map(function (m) {
      return m[key];
    }).filter(function (_) {
      return _;
    }) : [];
  }

  function addProp(el, name, value) {
    (el.props || (el.props = [])).push({ name: name, value: value });
  }

  function addAttr(el, name, value) {
    (el.attrs || (el.attrs = [])).push({ name: name, value: value });
  }

  function addDirective(el, name, rawName, value, arg, modifiers) {
    (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
  }

  function addHandler(el, name, value, modifiers, important, warn) {
    // warn prevent and passive modifier
    /* istanbul ignore if */
    if ("development" !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {
      warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
    }
    // check capture modifier
    if (modifiers && modifiers.capture) {
      delete modifiers.capture;
      name = '!' + name; // mark the event as captured
    }
    if (modifiers && modifiers.once) {
      delete modifiers.once;
      name = '~' + name; // mark the event as once
    }
    /* istanbul ignore if */
    if (modifiers && modifiers.passive) {
      delete modifiers.passive;
      name = '&' + name; // mark the event as passive
    }
    var events;
    if (modifiers && modifiers.native) {
      delete modifiers.native;
      events = el.nativeEvents || (el.nativeEvents = {});
    } else {
      events = el.events || (el.events = {});
    }
    var newHandler = { value: value, modifiers: modifiers };
    var handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
      important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    } else if (handlers) {
      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    } else {
      events[name] = newHandler;
    }
  }

  function getBindingAttr(el, name, getStatic) {
    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
    if (dynamicValue != null) {
      return parseFilters(dynamicValue);
    } else if (getStatic !== false) {
      var staticValue = getAndRemoveAttr(el, name);
      if (staticValue != null) {
        return JSON.stringify(staticValue);
      }
    }
  }

  function getAndRemoveAttr(el, name) {
    var val;
    if ((val = el.attrsMap[name]) != null) {
      var list = el.attrsList;
      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i].name === name) {
          list.splice(i, 1);
          break;
        }
      }
    }
    return val;
  }

  /*  */

  /**
   * Cross-platform code generation for component v-model
   */
  function genComponentModel(el, value, modifiers) {
    var ref = modifiers || {};
    var number = ref.number;
    var trim = ref.trim;

    var baseValueExpression = '$$v';
    var valueExpression = baseValueExpression;
    if (trim) {
      valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }
    var assignment = genAssignmentCode(value, valueExpression);

    el.model = {
      value: "(" + value + ")",
      expression: "\"" + value + "\"",
      callback: "function (" + baseValueExpression + ") {" + assignment + "}"
    };
  }

  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */
  function genAssignmentCode(value, assignment) {
    var modelRs = parseModel(value);
    if (modelRs.idx === null) {
      return value + "=" + assignment;
    } else {
      return "$set(" + modelRs.exp + ", " + modelRs.idx + ", " + assignment + ")";
    }
  }

  /**
   * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
   *
   * for loop possible cases:
   *
   * - test
   * - test[idx]
   * - test[test1[idx]]
   * - test["a"][idx]
   * - xxx.test[a[a].test1[idx]]
   * - test.xxx.a["asa"][test1[idx]]
   *
   */

  var len;
  var str;
  var chr;
  var index$1;
  var expressionPos;
  var expressionEndPos;

  function parseModel(val) {
    str = val;
    len = str.length;
    index$1 = expressionPos = expressionEndPos = 0;

    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
      return {
        exp: val,
        idx: null
      };
    }

    while (!eof()) {
      chr = next();
      /* istanbul ignore if */
      if (isStringStart(chr)) {
        parseString(chr);
      } else if (chr === 0x5B) {
        parseBracket(chr);
      }
    }

    return {
      exp: val.substring(0, expressionPos),
      idx: val.substring(expressionPos + 1, expressionEndPos)
    };
  }

  function next() {
    return str.charCodeAt(++index$1);
  }

  function eof() {
    return index$1 >= len;
  }

  function isStringStart(chr) {
    return chr === 0x22 || chr === 0x27;
  }

  function parseBracket(chr) {
    var inBracket = 1;
    expressionPos = index$1;
    while (!eof()) {
      chr = next();
      if (isStringStart(chr)) {
        parseString(chr);
        continue;
      }
      if (chr === 0x5B) {
        inBracket++;
      }
      if (chr === 0x5D) {
        inBracket--;
      }
      if (inBracket === 0) {
        expressionEndPos = index$1;
        break;
      }
    }
  }

  function parseString(chr) {
    var stringQuote = chr;
    while (!eof()) {
      chr = next();
      if (chr === stringQuote) {
        break;
      }
    }
  }

  /*  */

  var warn$1;

  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.
  var RANGE_TOKEN = '__r';
  var CHECKBOX_RADIO_TOKEN = '__c';

  function model(el, dir, _warn) {
    warn$1 = _warn;
    var value = dir.value;
    var modifiers = dir.modifiers;
    var tag = el.tag;
    var type = el.attrsMap.type;

    {
      var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
      if (tag === 'input' && dynamicType) {
        warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
      }
      // inputs with type="file" are read only and setting the input's
      // value will throw an error.
      if (tag === 'input' && type === 'file') {
        warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
      }
    }

    if (el.component) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else if (tag === 'select') {
      genSelect(el, value, modifiers);
    } else if (tag === 'input' && type === 'checkbox') {
      genCheckboxModel(el, value, modifiers);
    } else if (tag === 'input' && type === 'radio') {
      genRadioModel(el, value, modifiers);
    } else if (tag === 'input' || tag === 'textarea') {
      genDefaultModel(el, value, modifiers);
    } else if (!config.isReservedTag(tag)) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else {
      warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
    }

    // ensure runtime directive metadata
    return true;
  }

  function genCheckboxModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
    addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + value + "=$$a.concat($$v))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
  }

  function genRadioModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
    addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
    addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
  }

  function genSelect(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    var code = "var $$selectedVal = " + selectedVal + ";";
    code = code + " " + genAssignmentCode(value, assignment);
    addHandler(el, 'change', code, null, true);
  }

  function genDefaultModel(el, value, modifiers) {
    var type = el.attrsMap.type;
    var ref = modifiers || {};
    var lazy = ref.lazy;
    var number = ref.number;
    var trim = ref.trim;
    var needCompositionGuard = !lazy && type !== 'range';
    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

    var valueExpression = '$event.target.value';
    if (trim) {
      valueExpression = "$event.target.value.trim()";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }

    var code = genAssignmentCode(value, valueExpression);
    if (needCompositionGuard) {
      code = "if($event.target.composing)return;" + code;
    }

    addProp(el, 'value', "(" + value + ")");
    addHandler(el, event, code, null, true);
    if (trim || number) {
      addHandler(el, 'blur', '$forceUpdate()');
    }
  }

  /*  */

  // normalize v-model event tokens that can only be determined at runtime.
  // it's important to place the event as the first in the array because
  // the whole point is ensuring the v-model callback gets called before
  // user-attached handlers.
  function normalizeEvents(on) {
    var event;
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
      // IE input[type=range] only supports `change` event
      event = isIE ? 'change' : 'input';
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    }
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      // Chrome fires microtasks in between click/change, leads to #4521
      event = isChrome ? 'click' : 'change';
      on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }

  var target$1;

  function add$1(event, handler, once$$1, capture, passive) {
    if (once$$1) {
      var oldHandler = handler;
      var _target = target$1; // save current target element in closure
      handler = function (ev) {
        var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
        if (res !== null) {
          remove$2(event, handler, capture, _target);
        }
      };
    }
    target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
  }

  function remove$2(event, handler, capture, _target) {
    (_target || target$1).removeEventListener(event, handler, capture);
  }

  function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return;
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  }

  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners
  };

  /*  */

  function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return;
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__)) {
      props = vnode.data.domProps = extend({}, props);
    }

    for (key in oldProps) {
      if (isUndef(props[key])) {
        elm[key] = '';
      }
    }
    for (key in props) {
      cur = props[key];
      // ignore children if the node has textContent or innerHTML,
      // as these will throw away existing DOM nodes and cause removal errors
      // on subsequent patches (#3360)
      if (key === 'textContent' || key === 'innerHTML') {
        if (vnode.children) {
          vnode.children.length = 0;
        }
        if (cur === oldProps[key]) {
          continue;
        }
      }

      if (key === 'value') {
        // store value as _value as well since
        // non-string values will be stringified
        elm._value = cur;
        // avoid resetting cursor position when value is the same
        var strCur = isUndef(cur) ? '' : String(cur);
        if (shouldUpdateValue(elm, vnode, strCur)) {
          elm.value = strCur;
        }
      } else {
        elm[key] = cur;
      }
    }
  }

  // check platforms/web/util/attrs.js acceptValue


  function shouldUpdateValue(elm, vnode, checkVal) {
    return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
  }

  function isDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
      notInFocus = document.activeElement !== elm;
    } catch (e) {}
    return notInFocus && elm.value !== checkVal;
  }

  function isInputChanged(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers) && modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }
    if (isDef(modifiers) && modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
    return value !== newVal;
  }

  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
  };

  /*  */

  var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res;
  });

  // merge static and dynamic style data on the same vnode
  function normalizeStyleData(data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
  }

  // normalize possible array / string values into Object
  function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
      return parseStyleText(bindingStyle);
    }
    return bindingStyle;
  }

  /**
   * parent component style should be after child's
   * so that parent component's style could override it
   */
  function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
      var childNode = vnode;
      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;
        if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
          extend(res, styleData);
        }
      }
    }

    if (styleData = normalizeStyleData(vnode.data)) {
      extend(res, styleData);
    }

    var parentNode = vnode;
    while (parentNode = parentNode.parent) {
      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
        extend(res, styleData);
      }
    }
    return res;
  }

  /*  */

  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;
  var setProp = function (el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
      el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(name, val.replace(importantRE, ''), 'important');
    } else {
      var normalizedName = normalize(name);
      if (Array.isArray(val)) {
        // Support values array created by autoprefixer, e.g.
        // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
        // Set them one by one, and the browser will only set those it can recognize
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };

  var vendorNames = ['Webkit', 'Moz', 'ms'];

  var emptyStyle;
  var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
      return prop;
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
      var name = vendorNames[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  });

  function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
      return;
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;

    var style = normalizeStyleBinding(vnode.data.style) || {};

    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likley wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

    var newStyle = getStyle(vnode, true);

    for (name in oldStyle) {
      if (isUndef(newStyle[name])) {
        setProp(el, name, '');
      }
    }
    for (name in newStyle) {
      cur = newStyle[name];
      if (cur !== oldStyle[name]) {
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
      }
    }
  }

  var style = {
    create: updateStyle,
    update: updateStyle
  };

  /*  */

  /**
   * Add class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(/\s+/).forEach(function (c) {
          return el.classList.add(c);
        });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      if (cur.indexOf(' ' + cls + ' ') < 0) {
        el.setAttribute('class', (cur + cls).trim());
      }
    }
  }

  /**
   * Remove class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(/\s+/).forEach(function (c) {
          return el.classList.remove(c);
        });
      } else {
        el.classList.remove(cls);
      }
      if (!el.classList.length) {
        el.removeAttribute('class');
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      var tar = ' ' + cls + ' ';
      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, ' ');
      }
      cur = cur.trim();
      if (cur) {
        el.setAttribute('class', cur);
      } else {
        el.removeAttribute('class');
      }
    }
  }

  /*  */

  function resolveTransition(def$$1) {
    if (!def$$1) {
      return;
    }
    /* istanbul ignore else */
    if (typeof def$$1 === 'object') {
      var res = {};
      if (def$$1.css !== false) {
        extend(res, autoCssTransition(def$$1.name || 'v'));
      }
      extend(res, def$$1);
      return res;
    } else if (typeof def$$1 === 'string') {
      return autoCssTransition(def$$1);
    }
  }

  var autoCssTransition = cached(function (name) {
    return {
      enterClass: name + "-enter",
      enterToClass: name + "-enter-to",
      enterActiveClass: name + "-enter-active",
      leaveClass: name + "-leave",
      leaveToClass: name + "-leave-to",
      leaveActiveClass: name + "-leave-active"
    };
  });

  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = 'transition';
  var ANIMATION = 'animation';

  // Transition property/event sniffing
  var transitionProp = 'transition';
  var transitionEndEvent = 'transitionend';
  var animationProp = 'animation';
  var animationEndEvent = 'animationend';
  if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
      transitionProp = 'WebkitTransition';
      transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
      animationProp = 'WebkitAnimation';
      animationEndEvent = 'webkitAnimationEnd';
    }
  }

  // binding to window is necessary to make hot reload work in IE in strict mode
  var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;

  function nextFrame(fn) {
    raf(function () {
      raf(fn);
    });
  }

  function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }

  function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }
    removeClass(el, cls);
  }

  function whenTransitionEnds(el, expectedType, cb) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;
    if (!type) {
      return cb();
    }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function () {
      el.removeEventListener(event, onEnd);
      cb();
    };
    var onEnd = function (e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };
    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }

  var transformRE = /\b(transform|all)(,|$)/;

  function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
    var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = styles[animationProp + 'Delay'].split(', ');
    var animationDurations = styles[animationProp + 'Duration'].split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);

    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    };
  }

  function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i]);
    }));
  }

  function toMs(s) {
    return Number(s.slice(0, -1)) * 1000;
  }

  /*  */

  function enter(vnode, toggleDisplay) {
    var el = vnode.elm;

    // call leave callback now
    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;
      el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return;
    }

    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;

    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
      transitionNode = transitionNode.parent;
      context = transitionNode.context;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
      return;
    }

    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

    if ("development" !== 'production' && explicitEnterDuration != null) {
      checkDuration(explicitEnterDuration, 'enter', vnode);
    }

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);

    var cb = el._enterCb = once(function () {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }
      el._enterCb = null;
    });

    if (!vnode.data.show) {
      // remove pending leave element on enter by injecting an insert hook
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
          pendingNode.elm._leaveCb();
        }
        enterHook && enterHook(el, cb);
      });
    }

    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function () {
        addTransitionClass(el, toClass);
        removeTransitionClass(el, startClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }

    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }

  function leave(vnode, rm) {
    var el = vnode.elm;

    // call enter callback now
    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;
      el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return rm();
    }

    /* istanbul ignore if */
    if (isDef(el._leaveCb) || el.nodeType !== 1) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);

    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

    if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
      checkDuration(explicitLeaveDuration, 'leave', vnode);
    }

    var cb = el._leaveCb = once(function () {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }
      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }
        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }
      el._leaveCb = null;
    });

    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }

    function performLeave() {
      // the delayed leave may have already been cancelled
      if (cb.cancelled) {
        return;
      }
      // record leaving element
      if (!vnode.data.show) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
      }
      beforeLeave && beforeLeave(el);
      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function () {
          addTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveClass);
          if (!cb.cancelled && !userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        });
      }
      leave && leave(el, cb);
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  }

  // only used in dev mode
  function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
      warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
    } else if (isNaN(val)) {
      warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
    }
  }

  function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
  }

  /**
   * Normalize a transition hook's argument length. The hook may be:
   * - a merged hook (invoker) with the original in .fns
   * - a wrapped component method (check ._length)
   * - a plain function (.length)
   */
  function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
      return false;
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
      // invoker
      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    } else {
      return (fn._length || fn.length) > 1;
    }
  }

  function _enter(_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }

  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1(vnode, rm) {
      /* istanbul ignore else */
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};

  var platformModules = [attrs, klass, events, domProps, style, transition];

  /*  */

  // the directive module should be applied last, after all
  // built-in modules have been applied.
  var modules = platformModules.concat(baseModules);

  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

  /**
   * Not type checking this file because flow doesn't like attaching
   * properties to Elements.
   */

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

  /* istanbul ignore if */
  if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
      var el = document.activeElement;
      if (el && el.vmodel) {
        trigger(el, 'input');
      }
    });
  }

  var model$1 = {
    inserted: function inserted(el, binding, vnode) {
      if (vnode.tag === 'select') {
        var cb = function () {
          setSelected(el, binding, vnode.context);
        };
        cb();
        /* istanbul ignore if */
        if (isIE || isEdge) {
          setTimeout(cb, 0);
        }
        el._vOptions = [].map.call(el.options, getValue);
      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;
        if (!binding.modifiers.lazy) {
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          el.addEventListener('change', onCompositionEnd);
          if (!isAndroid) {
            el.addEventListener('compositionstart', onCompositionStart);
            el.addEventListener('compositionend', onCompositionEnd);
          }
          /* istanbul ignore if */
          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },
    componentUpdated: function componentUpdated(el, binding, vnode) {
      if (vnode.tag === 'select') {
        setSelected(el, binding, vnode.context);
        // in case the options rendered by v-for have changed,
        // it's possible that the value is out-of-sync with the rendered options.
        // detect such cases and filter out values that no longer has a matching
        // option in the DOM.
        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue);
        if (curOptions.some(function (o, i) {
          return !looseEqual(o, prevOptions[i]);
        })) {
          trigger(el, 'change');
        }
      }
    }
  };

  function setSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
      "development" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
      return;
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];
      if (isMultiple) {
        selected = looseIndexOf(value, getValue(option)) > -1;
        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }
          return;
        }
      }
    }
    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }

  function getValue(option) {
    return '_value' in option ? option._value : option.value;
  }

  function onCompositionStart(e) {
    e.target.composing = true;
  }

  function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) {
      return;
    }
    e.target.composing = false;
    trigger(e.target, 'input');
  }

  function trigger(el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }

  /*  */

  // recursively search for possible transition defined inside the component root
  function locateNode(vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
  }

  var show = {
    bind: function bind(el, ref, vnode) {
      var value = ref.value;

      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function () {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : 'none';
      }
    },

    update: function update(el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;

      /* istanbul ignore if */
      if (value === oldValue) {
        return;
      }
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      if (transition$$1) {
        vnode.data.show = true;
        if (value) {
          enter(vnode, function () {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function () {
            el.style.display = 'none';
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : 'none';
      }
    },

    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };

  var platformDirectives = {
    model: model$1,
    show: show
  };

  /*  */

  // Provides transition support for a single element/component.
  // supports transition mode (out-in / in-out)

  var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };

  // in case the child is also an abstract component, e.g. <keep-alive>
  // we want to recursively retrieve the real component to be rendered
  function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children));
    } else {
      return vnode;
    }
  }

  function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
      data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }
    return data;
  }

  function placeholder(h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h('keep-alive', {
        props: rawChild.componentOptions.propsData
      });
    }
  }

  function hasParentTransition(vnode) {
    while (vnode = vnode.parent) {
      if (vnode.data.transition) {
        return true;
      }
    }
  }

  function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
  }

  function isAsyncPlaceholder(node) {
    return node.isComment && node.asyncFactory;
  }

  var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,

    render: function render(h) {
      var this$1 = this;

      var children = this.$options._renderChildren;
      if (!children) {
        return;
      }

      // filter out text nodes (possible whitespaces)
      children = children.filter(function (c) {
        return c.tag || isAsyncPlaceholder(c);
      });
      /* istanbul ignore if */
      if (!children.length) {
        return;
      }

      // warn multiple elements
      if ("development" !== 'production' && children.length > 1) {
        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
      }

      var mode = this.mode;

      // warn invalid mode
      if ("development" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
        warn('invalid <transition> mode: ' + mode, this.$parent);
      }

      var rawChild = children[0];

      // if this is a component root node and the component's
      // parent container node also has transition, skip.
      if (hasParentTransition(this.$vnode)) {
        return rawChild;
      }

      // apply transition data to child
      // use getRealChild() to ignore abstract components e.g. keep-alive
      var child = getRealChild(rawChild);
      /* istanbul ignore if */
      if (!child) {
        return rawChild;
      }

      if (this._leaving) {
        return placeholder(h, rawChild);
      }

      // ensure a key that is unique to the vnode type and to this transition
      // component instance. This key will be used to remove pending leaving nodes
      // during entering.
      var id = "__transition-" + this._uid + "-";
      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild);

      // mark v-show
      // so that the transition module can hand over the control to the directive
      if (child.data.directives && child.data.directives.some(function (d) {
        return d.name === 'show';
      })) {
        child.data.show = true;
      }

      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild)) {
        // replace old child transition data with fresh one
        // important for dynamic transitions!
        var oldData = oldChild && (oldChild.data.transition = extend({}, data));
        // handle transition mode
        if (mode === 'out-in') {
          // return placeholder node and queue update when leave finishes
          this._leaving = true;
          mergeVNodeHook(oldData, 'afterLeave', function () {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild);
        } else if (mode === 'in-out') {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild;
          }
          var delayedLeave;
          var performLeave = function () {
            delayedLeave();
          };
          mergeVNodeHook(data, 'afterEnter', performLeave);
          mergeVNodeHook(data, 'enterCancelled', performLeave);
          mergeVNodeHook(oldData, 'delayLeave', function (leave) {
            delayedLeave = leave;
          });
        }
      }

      return rawChild;
    }
  };

  /*  */

  // Provides transition support for list items.
  // supports move transitions using the FLIP technique.

  // Because the vdom's children update algorithm is "unstable" - i.e.
  // it doesn't guarantee the relative positioning of removed elements,
  // we force transition-group to update its children into two passes:
  // in the first pass, we remove all nodes that need to be removed,
  // triggering their leaving transition; in the second pass, we insert/move
  // into the final desired state. This way in the second pass removed
  // nodes will remain where they should be.

  var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);

  delete props.mode;

  var TransitionGroup = {
    props: props,

    render: function render(h) {
      var tag = this.tag || this.$vnode.data.tag || 'span';
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);

      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];
        if (c.tag) {
          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
            children.push(c);
            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
          } else {
            var opts = c.componentOptions;
            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
            warn("<transition-group> children must be keyed: <" + name + ">");
          }
        }
      }

      if (prevChildren) {
        var kept = [];
        var removed = [];
        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();
          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }
        this.kept = h(tag, null, kept);
        this.removed = removed;
      }

      return h(tag, null, children);
    },

    beforeUpdate: function beforeUpdate() {
      // force removing pass
      this.__patch__(this._vnode, this.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );
      this._vnode = this.kept;
    },

    updated: function updated() {
      var children = this.prevChildren;
      var moveClass = this.moveClass || (this.name || 'v') + '-move';
      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return;
      }

      // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.
      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation);

      // force reflow to put everything in position
      var body = document.body;
      var f = body.offsetHeight; // eslint-disable-line

      children.forEach(function (c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = '';
          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },

    methods: {
      hasMove: function hasMove(el, moveClass) {
        /* istanbul ignore if */
        if (!hasTransition) {
          return false;
        }
        /* istanbul ignore if */
        if (this._hasMove) {
          return this._hasMove;
        }
        // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.
        var clone = el.cloneNode();
        if (el._transitionClasses) {
          el._transitionClasses.forEach(function (cls) {
            removeClass(clone, cls);
          });
        }
        addClass(clone, moveClass);
        clone.style.display = 'none';
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return this._hasMove = info.hasTransform;
      }
    }
  };

  function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }

  function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }

  function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = '0s';
    }
  }

  var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
  };

  /*  */

  // install platform specific utils
  Vue$3.config.mustUseProp = mustUseProp;
  Vue$3.config.isReservedTag = isReservedTag;
  Vue$3.config.isReservedAttr = isReservedAttr;
  Vue$3.config.getTagNamespace = getTagNamespace;
  Vue$3.config.isUnknownElement = isUnknownElement;

  // install platform runtime directives & components
  extend(Vue$3.options.directives, platformDirectives);
  extend(Vue$3.options.components, platformComponents);

  // install platform patch function
  Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

  // public mount method
  Vue$3.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
  };

  // devtools global hook
  /* istanbul ignore next */
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue$3);
      } else if ("development" !== 'production' && isChrome) {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }
    if ("development" !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);

  /*  */

  // check whether current browser encodes a char inside attribute values
  function shouldDecode(content, encoded) {
    var div = document.createElement('div');
    div.innerHTML = "<div a=\"" + content + "\"/>";
    return div.innerHTML.indexOf(encoded) > 0;
  }

  // #3663
  // IE encodes newlines inside attribute values while other browsers don't
  var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

  /*  */

  var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

  var buildRegex = cached(function (delimiters) {
    var open = delimiters[0].replace(regexEscapeRE, '\\$&');
    var close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
  });

  function parseText(text, delimiters) {
    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
    if (!tagRE.test(text)) {
      return;
    }
    var tokens = [];
    var lastIndex = tagRE.lastIndex = 0;
    var match, index;
    while (match = tagRE.exec(text)) {
      index = match.index;
      // push text token
      if (index > lastIndex) {
        tokens.push(JSON.stringify(text.slice(lastIndex, index)));
      }
      // tag token
      var exp = parseFilters(match[1].trim());
      tokens.push("_s(" + exp + ")");
      lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
      tokens.push(JSON.stringify(text.slice(lastIndex)));
    }
    return tokens.join('+');
  }

  /*  */

  function transformNode(el, options) {
    var warn = options.warn || baseWarn;
    var staticClass = getAndRemoveAttr(el, 'class');
    if ("development" !== 'production' && staticClass) {
      var expression = parseText(staticClass, options.delimiters);
      if (expression) {
        warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
      }
    }
    if (staticClass) {
      el.staticClass = JSON.stringify(staticClass);
    }
    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
    if (classBinding) {
      el.classBinding = classBinding;
    }
  }

  function genData(el) {
    var data = '';
    if (el.staticClass) {
      data += "staticClass:" + el.staticClass + ",";
    }
    if (el.classBinding) {
      data += "class:" + el.classBinding + ",";
    }
    return data;
  }

  var klass$1 = {
    staticKeys: ['staticClass'],
    transformNode: transformNode,
    genData: genData
  };

  /*  */

  function transformNode$1(el, options) {
    var warn = options.warn || baseWarn;
    var staticStyle = getAndRemoveAttr(el, 'style');
    if (staticStyle) {
      /* istanbul ignore if */
      {
        var expression = parseText(staticStyle, options.delimiters);
        if (expression) {
          warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
        }
      }
      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }

    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
    if (styleBinding) {
      el.styleBinding = styleBinding;
    }
  }

  function genData$1(el) {
    var data = '';
    if (el.staticStyle) {
      data += "staticStyle:" + el.staticStyle + ",";
    }
    if (el.styleBinding) {
      data += "style:(" + el.styleBinding + "),";
    }
    return data;
  }

  var style$1 = {
    staticKeys: ['staticStyle'],
    transformNode: transformNode$1,
    genData: genData$1
  };

  var modules$1 = [klass$1, style$1];

  /*  */

  function text(el, dir) {
    if (dir.value) {
      addProp(el, 'textContent', "_s(" + dir.value + ")");
    }
  }

  /*  */

  function html(el, dir) {
    if (dir.value) {
      addProp(el, 'innerHTML', "_s(" + dir.value + ")");
    }
  }

  var directives$1 = {
    model: model,
    text: text,
    html: html
  };

  /*  */

  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

  // Elements that you can, intentionally, leave open
  // (and which close themselves)
  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

  /*  */

  var baseOptions = {
    expectHTML: true,
    modules: modules$1,
    directives: directives$1,
    isPreTag: isPreTag,
    isUnaryTag: isUnaryTag,
    mustUseProp: mustUseProp,
    canBeLeftOpenTag: canBeLeftOpenTag,
    isReservedTag: isReservedTag,
    getTagNamespace: getTagNamespace,
    staticKeys: genStaticKeys(modules$1)
  };

  /*  */

  var decoder;

  var he = {
    decode: function decode(html) {
      decoder = decoder || document.createElement('div');
      decoder.innerHTML = html;
      return decoder.textContent;
    }
  };

  /**
   * Not type-checking this file because it's mostly vendor code.
   */

  /*!
   * HTML Parser By John Resig (ejohn.org)
   * Modified by Juriy "kangax" Zaytsev
   * Original code by Erik Arvidsson, Mozilla Public License
   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
   */

  // Regular Expressions for parsing tags and attributes
  var singleAttrIdentifier = /([^\s"'<>/=]+)/;
  var singleAttrAssign = /(?:=)/;
  var singleAttrValues = [
  // attr value double quotes
  /"([^"]*)"+/.source,
  // attr value, single quotes
  /'([^']*)'+/.source,
  // attr value, no quotes
  /([^\s"'=<>`]+)/.source];
  var attribute = new RegExp('^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?');

  // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
  // but for Vue templates we can enforce a simple charset
  var ncname = '[a-zA-Z_][\\w\\-\\.]*';
  var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
  var startTagOpen = new RegExp('^<' + qnameCapture);
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
  var doctype = /^<!DOCTYPE [^>]+>/i;
  var comment = /^<!--/;
  var conditionalComment = /^<!\[/;

  var IS_REGEX_CAPTURING_BROKEN = false;
  'x'.replace(/x(.)?/g, function (m, g) {
    IS_REGEX_CAPTURING_BROKEN = g === '';
  });

  // Special Elements (can contain anything)
  var isPlainTextElement = makeMap('script,style,textarea', true);
  var reCache = {};

  var decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n'
  };
  var encodedAttr = /&(?:lt|gt|quot|amp);/g;
  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;

  // #5992
  var isIgnoreNewlineTag = makeMap('pre,textarea', true);
  var shouldIgnoreFirstNewline = function (tag, html) {
    return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
  };

  function decodeAttr(value, shouldDecodeNewlines) {
    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, function (match) {
      return decodingMap[match];
    });
  }

  function parseHTML(html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag$$1 = options.isUnaryTag || no;
    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;
    while (html) {
      last = html;
      // Make sure we're not in a plaintext content element like script/style
      if (!lastTag || !isPlainTextElement(lastTag)) {
        var textEnd = html.indexOf('<');
        if (textEnd === 0) {
          // Comment:
          if (comment.test(html)) {
            var commentEnd = html.indexOf('-->');

            if (commentEnd >= 0) {
              if (options.shouldKeepComment) {
                options.comment(html.substring(4, commentEnd));
              }
              advance(commentEnd + 3);
              continue;
            }
          }

          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
          if (conditionalComment.test(html)) {
            var conditionalEnd = html.indexOf(']>');

            if (conditionalEnd >= 0) {
              advance(conditionalEnd + 2);
              continue;
            }
          }

          // Doctype:
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            advance(doctypeMatch[0].length);
            continue;
          }

          // End tag:
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            var curIndex = index;
            advance(endTagMatch[0].length);
            parseEndTag(endTagMatch[1], curIndex, index);
            continue;
          }

          // Start tag:
          var startTagMatch = parseStartTag();
          if (startTagMatch) {
            handleStartTag(startTagMatch);
            if (shouldIgnoreFirstNewline(lastTag, html)) {
              advance(1);
            }
            continue;
          }
        }

        var text = void 0,
            rest = void 0,
            next = void 0;
        if (textEnd >= 0) {
          rest = html.slice(textEnd);
          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
            // < in plain text, be forgiving and treat it as text
            next = rest.indexOf('<', 1);
            if (next < 0) {
              break;
            }
            textEnd += next;
            rest = html.slice(textEnd);
          }
          text = html.substring(0, textEnd);
          advance(textEnd);
        }

        if (textEnd < 0) {
          text = html;
          html = '';
        }

        if (options.chars && text) {
          options.chars(text);
        }
      } else {
        var endTagLength = 0;
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
          endTagLength = endTag.length;
          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
            text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }
          if (shouldIgnoreFirstNewline(stackedTag, text)) {
            text = text.slice(1);
          }
          if (options.chars) {
            options.chars(text);
          }
          return '';
        });
        index += html.length - rest$1.length;
        html = rest$1;
        parseEndTag(stackedTag, index - endTagLength, index);
      }

      if (html === last) {
        options.chars && options.chars(html);
        if ("development" !== 'production' && !stack.length && options.warn) {
          options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
        }
        break;
      }
    }

    // Clean up any remaining tags
    parseEndTag();

    function advance(n) {
      index += n;
      html = html.substring(n);
    }

    function parseStartTag() {
      var start = html.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: [],
          start: index
        };
        advance(start[0].length);
        var end, attr;
        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
          advance(attr[0].length);
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          advance(end[0].length);
          match.end = index;
          return match;
        }
      }
    }

    function handleStartTag(match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;

      if (expectHTML) {
        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
          parseEndTag(lastTag);
        }
        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
          parseEndTag(tagName);
        }
      }

      var unary = isUnaryTag$$1(tagName) || !!unarySlash;

      var l = match.attrs.length;
      var attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        var args = match.attrs[i];
        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
          if (args[3] === '') {
            delete args[3];
          }
          if (args[4] === '') {
            delete args[4];
          }
          if (args[5] === '') {
            delete args[5];
          }
        }
        var value = args[3] || args[4] || args[5] || '';
        attrs[i] = {
          name: args[1],
          value: decodeAttr(value, options.shouldDecodeNewlines)
        };
      }

      if (!unary) {
        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
        lastTag = tagName;
      }

      if (options.start) {
        options.start(tagName, attrs, unary, match.start, match.end);
      }
    }

    function parseEndTag(tagName, start, end) {
      var pos, lowerCasedTagName;
      if (start == null) {
        start = index;
      }
      if (end == null) {
        end = index;
      }

      if (tagName) {
        lowerCasedTagName = tagName.toLowerCase();
      }

      // Find the closest opened tag of the same type
      if (tagName) {
        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos].lowerCasedTag === lowerCasedTagName) {
            break;
          }
        }
      } else {
        // If no tag name is provided, clean shop
        pos = 0;
      }

      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
          if ("development" !== 'production' && (i > pos || !tagName) && options.warn) {
            options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
          }
          if (options.end) {
            options.end(stack[i].tag, start, end);
          }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (lowerCasedTagName === 'br') {
        if (options.start) {
          options.start(tagName, [], true, start, end);
        }
      } else if (lowerCasedTagName === 'p') {
        if (options.start) {
          options.start(tagName, [], false, start, end);
        }
        if (options.end) {
          options.end(tagName, start, end);
        }
      }
    }
  }

  /*  */

  var onRE = /^@|^v-on:/;
  var dirRE = /^v-|^@|^:/;
  var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
  var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

  var argRE = /:(.*)$/;
  var bindRE = /^:|^v-bind:/;
  var modifierRE = /\.[^.]+/g;

  var decodeHTMLCached = cached(he.decode);

  // configurable state
  var warn$2;
  var delimiters;
  var transforms;
  var preTransforms;
  var postTransforms;
  var platformIsPreTag;
  var platformMustUseProp;
  var platformGetTagNamespace;

  /**
   * Convert HTML string to AST.
   */
  function parse(template, options) {
    warn$2 = options.warn || baseWarn;

    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;

    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

    delimiters = options.delimiters;

    var stack = [];
    var preserveWhitespace = options.preserveWhitespace !== false;
    var root;
    var currentParent;
    var inVPre = false;
    var inPre = false;
    var warned = false;

    function warnOnce(msg) {
      if (!warned) {
        warned = true;
        warn$2(msg);
      }
    }

    function endPre(element) {
      // check pre state
      if (element.pre) {
        inVPre = false;
      }
      if (platformIsPreTag(element.tag)) {
        inPre = false;
      }
    }

    parseHTML(template, {
      warn: warn$2,
      expectHTML: options.expectHTML,
      isUnaryTag: options.isUnaryTag,
      canBeLeftOpenTag: options.canBeLeftOpenTag,
      shouldDecodeNewlines: options.shouldDecodeNewlines,
      shouldKeepComment: options.comments,
      start: function start(tag, attrs, unary) {
        // check namespace.
        // inherit parent ns if there is one
        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

        // handle IE svg bug
        /* istanbul ignore if */
        if (isIE && ns === 'svg') {
          attrs = guardIESVGBug(attrs);
        }

        var element = {
          type: 1,
          tag: tag,
          attrsList: attrs,
          attrsMap: makeAttrsMap(attrs),
          parent: currentParent,
          children: []
        };
        if (ns) {
          element.ns = ns;
        }

        if (isForbiddenTag(element) && !isServerRendering()) {
          element.forbidden = true;
          "development" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
        }

        // apply pre-transforms
        for (var i = 0; i < preTransforms.length; i++) {
          preTransforms[i](element, options);
        }

        if (!inVPre) {
          processPre(element);
          if (element.pre) {
            inVPre = true;
          }
        }
        if (platformIsPreTag(element.tag)) {
          inPre = true;
        }
        if (inVPre) {
          processRawAttrs(element);
        } else {
          processFor(element);
          processIf(element);
          processOnce(element);
          processKey(element);

          // determine whether this is a plain element after
          // removing structural attributes
          element.plain = !element.key && !attrs.length;

          processRef(element);
          processSlot(element);
          processComponent(element);
          for (var i$1 = 0; i$1 < transforms.length; i$1++) {
            transforms[i$1](element, options);
          }
          processAttrs(element);
        }

        function checkRootConstraints(el) {
          {
            if (el.tag === 'slot' || el.tag === 'template') {
              warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
            }
            if (el.attrsMap.hasOwnProperty('v-for')) {
              warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
            }
          }
        }

        // tree management
        if (!root) {
          root = element;
          checkRootConstraints(root);
        } else if (!stack.length) {
          // allow root elements with v-if, v-else-if and v-else
          if (root.if && (element.elseif || element.else)) {
            checkRootConstraints(element);
            addIfCondition(root, {
              exp: element.elseif,
              block: element
            });
          } else {
            warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
          }
        }
        if (currentParent && !element.forbidden) {
          if (element.elseif || element.else) {
            processIfConditions(element, currentParent);
          } else if (element.slotScope) {
            // scoped slot
            currentParent.plain = false;
            var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
          } else {
            currentParent.children.push(element);
            element.parent = currentParent;
          }
        }
        if (!unary) {
          currentParent = element;
          stack.push(element);
        } else {
          endPre(element);
        }
        // apply post-transforms
        for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
          postTransforms[i$2](element, options);
        }
      },

      end: function end() {
        // remove trailing whitespace
        var element = stack[stack.length - 1];
        var lastNode = element.children[element.children.length - 1];
        if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
          element.children.pop();
        }
        // pop stack
        stack.length -= 1;
        currentParent = stack[stack.length - 1];
        endPre(element);
      },

      chars: function chars(text) {
        if (!currentParent) {
          {
            if (text === template) {
              warnOnce('Component template requires a root element, rather than just text.');
            } else if (text = text.trim()) {
              warnOnce("text \"" + text + "\" outside root element will be ignored.");
            }
          }
          return;
        }
        // IE textarea placeholder bug
        /* istanbul ignore if */
        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
          return;
        }
        var children = currentParent.children;
        text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
        if (text) {
          var expression;
          if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
            children.push({
              type: 2,
              expression: expression,
              text: text
            });
          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
            children.push({
              type: 3,
              text: text
            });
          }
        }
      },
      comment: function comment(text) {
        currentParent.children.push({
          type: 3,
          text: text,
          isComment: true
        });
      }
    });
    return root;
  }

  function processPre(el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
      el.pre = true;
    }
  }

  function processRawAttrs(el) {
    var l = el.attrsList.length;
    if (l) {
      var attrs = el.attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        attrs[i] = {
          name: el.attrsList[i].name,
          value: JSON.stringify(el.attrsList[i].value)
        };
      }
    } else if (!el.pre) {
      // non root node in pre blocks with no attributes
      el.plain = true;
    }
  }

  function processKey(el) {
    var exp = getBindingAttr(el, 'key');
    if (exp) {
      if ("development" !== 'production' && el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.");
      }
      el.key = exp;
    }
  }

  function processRef(el) {
    var ref = getBindingAttr(el, 'ref');
    if (ref) {
      el.ref = ref;
      el.refInFor = checkInFor(el);
    }
  }

  function processFor(el) {
    var exp;
    if (exp = getAndRemoveAttr(el, 'v-for')) {
      var inMatch = exp.match(forAliasRE);
      if (!inMatch) {
        "development" !== 'production' && warn$2("Invalid v-for expression: " + exp);
        return;
      }
      el.for = inMatch[2].trim();
      var alias = inMatch[1].trim();
      var iteratorMatch = alias.match(forIteratorRE);
      if (iteratorMatch) {
        el.alias = iteratorMatch[1].trim();
        el.iterator1 = iteratorMatch[2].trim();
        if (iteratorMatch[3]) {
          el.iterator2 = iteratorMatch[3].trim();
        }
      } else {
        el.alias = alias;
      }
    }
  }

  function processIf(el) {
    var exp = getAndRemoveAttr(el, 'v-if');
    if (exp) {
      el.if = exp;
      addIfCondition(el, {
        exp: exp,
        block: el
      });
    } else {
      if (getAndRemoveAttr(el, 'v-else') != null) {
        el.else = true;
      }
      var elseif = getAndRemoveAttr(el, 'v-else-if');
      if (elseif) {
        el.elseif = elseif;
      }
    }
  }

  function processIfConditions(el, parent) {
    var prev = findPrevElement(parent.children);
    if (prev && prev.if) {
      addIfCondition(prev, {
        exp: el.elseif,
        block: el
      });
    } else {
      warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
    }
  }

  function findPrevElement(children) {
    var i = children.length;
    while (i--) {
      if (children[i].type === 1) {
        return children[i];
      } else {
        if ("development" !== 'production' && children[i].text !== ' ') {
          warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
        }
        children.pop();
      }
    }
  }

  function addIfCondition(el, condition) {
    if (!el.ifConditions) {
      el.ifConditions = [];
    }
    el.ifConditions.push(condition);
  }

  function processOnce(el) {
    var once$$1 = getAndRemoveAttr(el, 'v-once');
    if (once$$1 != null) {
      el.once = true;
    }
  }

  function processSlot(el) {
    if (el.tag === 'slot') {
      el.slotName = getBindingAttr(el, 'name');
      if ("development" !== 'production' && el.key) {
        warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
      }
    } else {
      var slotTarget = getBindingAttr(el, 'slot');
      if (slotTarget) {
        el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      }
      if (el.tag === 'template') {
        el.slotScope = getAndRemoveAttr(el, 'scope');
      }
    }
  }

  function processComponent(el) {
    var binding;
    if (binding = getBindingAttr(el, 'is')) {
      el.component = binding;
    }
    if (getAndRemoveAttr(el, 'inline-template') != null) {
      el.inlineTemplate = true;
    }
  }

  function processAttrs(el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, isProp;
    for (i = 0, l = list.length; i < l; i++) {
      name = rawName = list[i].name;
      value = list[i].value;
      if (dirRE.test(name)) {
        // mark element as dynamic
        el.hasBindings = true;
        // modifiers
        modifiers = parseModifiers(name);
        if (modifiers) {
          name = name.replace(modifierRE, '');
        }
        if (bindRE.test(name)) {
          // v-bind
          name = name.replace(bindRE, '');
          value = parseFilters(value);
          isProp = false;
          if (modifiers) {
            if (modifiers.prop) {
              isProp = true;
              name = camelize(name);
              if (name === 'innerHtml') {
                name = 'innerHTML';
              }
            }
            if (modifiers.camel) {
              name = camelize(name);
            }
            if (modifiers.sync) {
              addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
            }
          }
          if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
            addProp(el, name, value);
          } else {
            addAttr(el, name, value);
          }
        } else if (onRE.test(name)) {
          // v-on
          name = name.replace(onRE, '');
          addHandler(el, name, value, modifiers, false, warn$2);
        } else {
          // normal directives
          name = name.replace(dirRE, '');
          // parse arg
          var argMatch = name.match(argRE);
          var arg = argMatch && argMatch[1];
          if (arg) {
            name = name.slice(0, -(arg.length + 1));
          }
          addDirective(el, name, rawName, value, arg, modifiers);
          if ("development" !== 'production' && name === 'model') {
            checkForAliasModel(el, value);
          }
        }
      } else {
        // literal attribute
        {
          var expression = parseText(value, delimiters);
          if (expression) {
            warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
          }
        }
        addAttr(el, name, JSON.stringify(value));
      }
    }
  }

  function checkInFor(el) {
    var parent = el;
    while (parent) {
      if (parent.for !== undefined) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }

  function parseModifiers(name) {
    var match = name.match(modifierRE);
    if (match) {
      var ret = {};
      match.forEach(function (m) {
        ret[m.slice(1)] = true;
      });
      return ret;
    }
  }

  function makeAttrsMap(attrs) {
    var map = {};
    for (var i = 0, l = attrs.length; i < l; i++) {
      if ("development" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
        warn$2('duplicate attribute: ' + attrs[i].name);
      }
      map[attrs[i].name] = attrs[i].value;
    }
    return map;
  }

  // for script (e.g. type="x/template") or style, do not decode content
  function isTextTag(el) {
    return el.tag === 'script' || el.tag === 'style';
  }

  function isForbiddenTag(el) {
    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
  }

  var ieNSBug = /^xmlns:NS\d+/;
  var ieNSPrefix = /^NS\d+:/;

  /* istanbul ignore next */
  function guardIESVGBug(attrs) {
    var res = [];
    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];
      if (!ieNSBug.test(attr.name)) {
        attr.name = attr.name.replace(ieNSPrefix, '');
        res.push(attr);
      }
    }
    return res;
  }

  function checkForAliasModel(el, value) {
    var _el = el;
    while (_el) {
      if (_el.for && _el.alias === value) {
        warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
      }
      _el = _el.parent;
    }
  }

  /*  */

  var isStaticKey;
  var isPlatformReservedTag;

  var genStaticKeysCached = cached(genStaticKeys$1);

  /**
   * Goal of the optimizer: walk the generated template AST tree
   * and detect sub-trees that are purely static, i.e. parts of
   * the DOM that never needs to change.
   *
   * Once we detect these sub-trees, we can:
   *
   * 1. Hoist them into constants, so that we no longer need to
   *    create fresh nodes for them on each re-render;
   * 2. Completely skip them in the patching process.
   */
  function optimize(root, options) {
    if (!root) {
      return;
    }
    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no;
    // first pass: mark all non-static nodes.
    markStatic$1(root);
    // second pass: mark static roots.
    markStaticRoots(root, false);
  }

  function genStaticKeys$1(keys) {
    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
  }

  function markStatic$1(node) {
    node.static = isStatic(node);
    if (node.type === 1) {
      // do not make component slot content static. this avoids
      // 1. components not able to mutate slot nodes
      // 2. static slot content fails for hot-reloading
      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
        return;
      }
      for (var i = 0, l = node.children.length; i < l; i++) {
        var child = node.children[i];
        markStatic$1(child);
        if (!child.static) {
          node.static = false;
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          var block = node.ifConditions[i$1].block;
          markStatic$1(block);
          if (!block.static) {
            node.static = false;
          }
        }
      }
    }
  }

  function markStaticRoots(node, isInFor) {
    if (node.type === 1) {
      if (node.static || node.once) {
        node.staticInFor = isInFor;
      }
      // For a node to qualify as a static root, it should have children that
      // are not just static text. Otherwise the cost of hoisting out will
      // outweigh the benefits and it's better off to just always render it fresh.
      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
        node.staticRoot = true;
        return;
      } else {
        node.staticRoot = false;
      }
      if (node.children) {
        for (var i = 0, l = node.children.length; i < l; i++) {
          markStaticRoots(node.children[i], isInFor || !!node.for);
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          markStaticRoots(node.ifConditions[i$1].block, isInFor);
        }
      }
    }
  }

  function isStatic(node) {
    if (node.type === 2) {
      // expression
      return false;
    }
    if (node.type === 3) {
      // text
      return true;
    }
    return !!(node.pre || !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
  }

  function isDirectChildOfTemplateFor(node) {
    while (node.parent) {
      node = node.parent;
      if (node.tag !== 'template') {
        return false;
      }
      if (node.for) {
        return true;
      }
    }
    return false;
  }

  /*  */

  var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
  var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

  // keyCode aliases
  var keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    'delete': [8, 46]
  };

  // #4868: modifiers that prevent the execution of the listener
  // need to explicitly return null so that we can determine whether to remove
  // the listener for .once
  var genGuard = function (condition) {
    return "if(" + condition + ")return null;";
  };

  var modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard("$event.target !== $event.currentTarget"),
    ctrl: genGuard("!$event.ctrlKey"),
    shift: genGuard("!$event.shiftKey"),
    alt: genGuard("!$event.altKey"),
    meta: genGuard("!$event.metaKey"),
    left: genGuard("'button' in $event && $event.button !== 0"),
    middle: genGuard("'button' in $event && $event.button !== 1"),
    right: genGuard("'button' in $event && $event.button !== 2")
  };

  function genHandlers(events, isNative, warn) {
    var res = isNative ? 'nativeOn:{' : 'on:{';
    for (var name in events) {
      var handler = events[name];
      // #5330: warn click.right, since right clicks do not actually fire click events.
      if ("development" !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {
        warn("Use \"contextmenu\" instead of \"click.right\" since right clicks " + "do not actually fire \"click\" events.");
      }
      res += "\"" + name + "\":" + genHandler(name, handler) + ",";
    }
    return res.slice(0, -1) + '}';
  }

  function genHandler(name, handler) {
    if (!handler) {
      return 'function(){}';
    }

    if (Array.isArray(handler)) {
      return "[" + handler.map(function (handler) {
        return genHandler(name, handler);
      }).join(',') + "]";
    }

    var isMethodPath = simplePathRE.test(handler.value);
    var isFunctionExpression = fnExpRE.test(handler.value);

    if (!handler.modifiers) {
      return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
    } else {
      var code = '';
      var genModifierCode = '';
      var keys = [];
      for (var key in handler.modifiers) {
        if (modifierCode[key]) {
          genModifierCode += modifierCode[key];
          // left/right
          if (keyCodes[key]) {
            keys.push(key);
          }
        } else {
          keys.push(key);
        }
      }
      if (keys.length) {
        code += genKeyFilter(keys);
      }
      // Make sure modifiers like prevent and stop get executed after key filtering
      if (genModifierCode) {
        code += genModifierCode;
      }
      var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
      return "function($event){" + code + handlerCode + "}";
    }
  }

  function genKeyFilter(keys) {
    return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
  }

  function genFilterCode(key) {
    var keyVal = parseInt(key, 10);
    if (keyVal) {
      return "$event.keyCode!==" + keyVal;
    }
    var alias = keyCodes[key];
    return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
  }

  /*  */

  function on(el, dir) {
    if ("development" !== 'production' && dir.modifiers) {
      warn("v-on without argument does not support modifiers.");
    }
    el.wrapListeners = function (code) {
      return "_g(" + code + "," + dir.value + ")";
    };
  }

  /*  */

  function bind$1(el, dir) {
    el.wrapData = function (code) {
      return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
    };
  }

  /*  */

  var baseDirectives = {
    on: on,
    bind: bind$1,
    cloak: noop
  };

  /*  */

  var CodegenState = function CodegenState(options) {
    this.options = options;
    this.warn = options.warn || baseWarn;
    this.transforms = pluckModuleFunction(options.modules, 'transformCode');
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
    this.directives = extend(extend({}, baseDirectives), options.directives);
    var isReservedTag = options.isReservedTag || no;
    this.maybeComponent = function (el) {
      return !isReservedTag(el.tag);
    };
    this.onceId = 0;
    this.staticRenderFns = [];
  };

  function generate(ast, options) {
    var state = new CodegenState(options);
    var code = ast ? genElement(ast, state) : '_c("div")';
    return {
      render: "with(this){return " + code + "}",
      staticRenderFns: state.staticRenderFns
    };
  }

  function genElement(el, state) {
    if (el.staticRoot && !el.staticProcessed) {
      return genStatic(el, state);
    } else if (el.once && !el.onceProcessed) {
      return genOnce(el, state);
    } else if (el.for && !el.forProcessed) {
      return genFor(el, state);
    } else if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.tag === 'template' && !el.slotTarget) {
      return genChildren(el, state) || 'void 0';
    } else if (el.tag === 'slot') {
      return genSlot(el, state);
    } else {
      // component or element
      var code;
      if (el.component) {
        code = genComponent(el.component, el, state);
      } else {
        var data = el.plain ? undefined : genData$2(el, state);

        var children = el.inlineTemplate ? null : genChildren(el, state, true);
        code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
      }
      // module transforms
      for (var i = 0; i < state.transforms.length; i++) {
        code = state.transforms[i](el, code);
      }
      return code;
    }
  }

  // hoist static sub-trees out
  function genStatic(el, state) {
    el.staticProcessed = true;
    state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
    return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
  }

  // v-once
  function genOnce(el, state) {
    el.onceProcessed = true;
    if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.staticInFor) {
      var key = '';
      var parent = el.parent;
      while (parent) {
        if (parent.for) {
          key = parent.key;
          break;
        }
        parent = parent.parent;
      }
      if (!key) {
        "development" !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
        return genElement(el, state);
      }
      return "_o(" + genElement(el, state) + "," + state.onceId++ + (key ? "," + key : "") + ")";
    } else {
      return genStatic(el, state);
    }
  }

  function genIf(el, state, altGen, altEmpty) {
    el.ifProcessed = true; // avoid recursion
    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
  }

  function genIfConditions(conditions, state, altGen, altEmpty) {
    if (!conditions.length) {
      return altEmpty || '_e()';
    }

    var condition = conditions.shift();
    if (condition.exp) {
      return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
    } else {
      return "" + genTernaryExp(condition.block);
    }

    // v-if with v-once should generate code like (a)?_m(0):_m(1)
    function genTernaryExp(el) {
      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
    }
  }

  function genFor(el, state, altGen, altHelper) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

    if ("development" !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
      state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
      );
    }

    el.forProcessed = true; // avoid recursion
    return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
  }

  function genData$2(el, state) {
    var data = '{';

    // directives first.
    // directives may mutate the el's other properties before they are generated.
    var dirs = genDirectives(el, state);
    if (dirs) {
      data += dirs + ',';
    }

    // key
    if (el.key) {
      data += "key:" + el.key + ",";
    }
    // ref
    if (el.ref) {
      data += "ref:" + el.ref + ",";
    }
    if (el.refInFor) {
      data += "refInFor:true,";
    }
    // pre
    if (el.pre) {
      data += "pre:true,";
    }
    // record original tag name for components using "is" attribute
    if (el.component) {
      data += "tag:\"" + el.tag + "\",";
    }
    // module data generation functions
    for (var i = 0; i < state.dataGenFns.length; i++) {
      data += state.dataGenFns[i](el);
    }
    // attributes
    if (el.attrs) {
      data += "attrs:{" + genProps(el.attrs) + "},";
    }
    // DOM props
    if (el.props) {
      data += "domProps:{" + genProps(el.props) + "},";
    }
    // event handlers
    if (el.events) {
      data += genHandlers(el.events, false, state.warn) + ",";
    }
    if (el.nativeEvents) {
      data += genHandlers(el.nativeEvents, true, state.warn) + ",";
    }
    // slot target
    if (el.slotTarget) {
      data += "slot:" + el.slotTarget + ",";
    }
    // scoped slots
    if (el.scopedSlots) {
      data += genScopedSlots(el.scopedSlots, state) + ",";
    }
    // component v-model
    if (el.model) {
      data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
    }
    // inline-template
    if (el.inlineTemplate) {
      var inlineTemplate = genInlineTemplate(el, state);
      if (inlineTemplate) {
        data += inlineTemplate + ",";
      }
    }
    data = data.replace(/,$/, '') + '}';
    // v-bind data wrap
    if (el.wrapData) {
      data = el.wrapData(data);
    }
    // v-on data wrap
    if (el.wrapListeners) {
      data = el.wrapListeners(data);
    }
    return data;
  }

  function genDirectives(el, state) {
    var dirs = el.directives;
    if (!dirs) {
      return;
    }
    var res = 'directives:[';
    var hasRuntime = false;
    var i, l, dir, needRuntime;
    for (i = 0, l = dirs.length; i < l; i++) {
      dir = dirs[i];
      needRuntime = true;
      var gen = state.directives[dir.name];
      if (gen) {
        // compile-time directive that manipulates AST.
        // returns true if it also needs a runtime counterpart.
        needRuntime = !!gen(el, dir, state.warn);
      }
      if (needRuntime) {
        hasRuntime = true;
        res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
      }
    }
    if (hasRuntime) {
      return res.slice(0, -1) + ']';
    }
  }

  function genInlineTemplate(el, state) {
    var ast = el.children[0];
    if ("development" !== 'production' && (el.children.length > 1 || ast.type !== 1)) {
      state.warn('Inline-template components must have exactly one child element.');
    }
    if (ast.type === 1) {
      var inlineRenderFns = generate(ast, state.options);
      return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
        return "function(){" + code + "}";
      }).join(',') + "]}";
    }
  }

  function genScopedSlots(slots, state) {
    return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state);
    }).join(',') + "])";
  }

  function genScopedSlot(key, el, state) {
    if (el.for && !el.forProcessed) {
      return genForScopedSlot(key, el, state);
    }
    return "{key:" + key + ",fn:function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el, state) || 'void 0' : genElement(el, state)) + "}}";
  }

  function genForScopedSlot(key, el, state) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
    el.forProcessed = true; // avoid recursion
    return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
  }

  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
    var children = el.children;
    if (children.length) {
      var el$1 = children[0];
      // optimize single v-for
      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
        return (altGenElement || genElement)(el$1, state);
      }
      var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
      var gen = altGenNode || genNode;
      return "[" + children.map(function (c) {
        return gen(c, state);
      }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
    }
  }

  // determine the normalization needed for the children array.
  // 0: no normalization needed
  // 1: simple normalization needed (possible 1-level deep nested array)
  // 2: full normalization needed
  function getNormalizationType(children, maybeComponent) {
    var res = 0;
    for (var i = 0; i < children.length; i++) {
      var el = children[i];
      if (el.type !== 1) {
        continue;
      }
      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return needsNormalization(c.block);
      })) {
        res = 2;
        break;
      }
      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return maybeComponent(c.block);
      })) {
        res = 1;
      }
    }
    return res;
  }

  function needsNormalization(el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
  }

  function genNode(node, state) {
    if (node.type === 1) {
      return genElement(node, state);
    }if (node.type === 3 && node.isComment) {
      return genComment(node);
    } else {
      return genText(node);
    }
  }

  function genText(text) {
    return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
  }

  function genComment(comment) {
    return "_e(" + JSON.stringify(comment.text) + ")";
  }

  function genSlot(el, state) {
    var slotName = el.slotName || '"default"';
    var children = genChildren(el, state);
    var res = "_t(" + slotName + (children ? "," + children : '');
    var attrs = el.attrs && "{" + el.attrs.map(function (a) {
      return camelize(a.name) + ":" + a.value;
    }).join(',') + "}";
    var bind$$1 = el.attrsMap['v-bind'];
    if ((attrs || bind$$1) && !children) {
      res += ",null";
    }
    if (attrs) {
      res += "," + attrs;
    }
    if (bind$$1) {
      res += (attrs ? '' : ',null') + "," + bind$$1;
    }
    return res + ')';
  }

  // componentName is el.component, take it as argument to shun flow's pessimistic refinement
  function genComponent(componentName, el, state) {
    var children = el.inlineTemplate ? null : genChildren(el, state, true);
    return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
  }

  function genProps(props) {
    var res = '';
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
    }
    return res.slice(0, -1);
  }

  // #3895, #4268
  function transformSpecialNewlines(text) {
    return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
  }

  /*  */

  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed
  var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

  // these unary operators should not be used as property/method names
  var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

  // check valid identifier for v-for
  var identRE = /[A-Za-z_$][\w$]*/;

  // strip strings in expressions
  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

  // detect problematic expressions in a template
  function detectErrors(ast) {
    var errors = [];
    if (ast) {
      checkNode(ast, errors);
    }
    return errors;
  }

  function checkNode(node, errors) {
    if (node.type === 1) {
      for (var name in node.attrsMap) {
        if (dirRE.test(name)) {
          var value = node.attrsMap[name];
          if (value) {
            if (name === 'v-for') {
              checkFor(node, "v-for=\"" + value + "\"", errors);
            } else if (onRE.test(name)) {
              checkEvent(value, name + "=\"" + value + "\"", errors);
            } else {
              checkExpression(value, name + "=\"" + value + "\"", errors);
            }
          }
        }
      }
      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          checkNode(node.children[i], errors);
        }
      }
    } else if (node.type === 2) {
      checkExpression(node.expression, node.text, errors);
    }
  }

  function checkEvent(exp, text, errors) {
    var stipped = exp.replace(stripStringRE, '');
    var keywordMatch = stipped.match(unaryOperatorsRE);
    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
      errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
    }
    checkExpression(exp, text, errors);
  }

  function checkFor(node, text, errors) {
    checkExpression(node.for || '', text, errors);
    checkIdentifier(node.alias, 'v-for alias', text, errors);
    checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
    checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
  }

  function checkIdentifier(ident, type, text, errors) {
    if (typeof ident === 'string' && !identRE.test(ident)) {
      errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
    }
  }

  function checkExpression(exp, text, errors) {
    try {
      new Function("return " + exp);
    } catch (e) {
      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
      if (keywordMatch) {
        errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
      } else {
        errors.push("invalid expression: " + text.trim());
      }
    }
  }

  /*  */

  function createFunction(code, errors) {
    try {
      return new Function(code);
    } catch (err) {
      errors.push({ err: err, code: code });
      return noop;
    }
  }

  function createCompileToFunctionFn(compile) {
    var cache = Object.create(null);

    return function compileToFunctions(template, options, vm) {
      options = options || {};

      /* istanbul ignore if */
      {
        // detect possible CSP restriction
        try {
          new Function('return 1');
        } catch (e) {
          if (e.toString().match(/unsafe-eval|CSP/)) {
            warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
          }
        }
      }

      // check cache
      var key = options.delimiters ? String(options.delimiters) + template : template;
      if (cache[key]) {
        return cache[key];
      }

      // compile
      var compiled = compile(template, options);

      // check compilation errors/tips
      {
        if (compiled.errors && compiled.errors.length) {
          warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
        if (compiled.tips && compiled.tips.length) {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }

      // turn code into functions
      var res = {};
      var fnGenErrors = [];
      res.render = createFunction(compiled.render, fnGenErrors);
      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
        return createFunction(code, fnGenErrors);
      });

      // check function generation errors.
      // this should only happen if there is a bug in the compiler itself.
      // mostly for codegen development use
      /* istanbul ignore if */
      {
        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
          warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return err.toString() + " in\n\n" + code + "\n";
          }).join('\n'), vm);
        }
      }

      return cache[key] = res;
    };
  }

  /*  */

  function createCompilerCreator(baseCompile) {
    return function createCompiler(baseOptions) {
      function compile(template, options) {
        var finalOptions = Object.create(baseOptions);
        var errors = [];
        var tips = [];
        finalOptions.warn = function (msg, tip) {
          (tip ? tips : errors).push(msg);
        };

        if (options) {
          // merge custom modules
          if (options.modules) {
            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
          }
          // merge custom directives
          if (options.directives) {
            finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
          }
          // copy other options
          for (var key in options) {
            if (key !== 'modules' && key !== 'directives') {
              finalOptions[key] = options[key];
            }
          }
        }

        var compiled = baseCompile(template, finalOptions);
        {
          errors.push.apply(errors, detectErrors(compiled.ast));
        }
        compiled.errors = errors;
        compiled.tips = tips;
        return compiled;
      }

      return {
        compile: compile,
        compileToFunctions: createCompileToFunctionFn(compile)
      };
    };
  }

  /*  */

  // `createCompilerCreator` allows creating compilers that use alternative
  // parser/optimizer/codegen, e.g the SSR optimizing compiler.
  // Here we just export a default compiler using the default parts.
  var createCompiler = createCompilerCreator(function baseCompile(template, options) {
    var ast = parse(template.trim(), options);
    optimize(ast, options);
    var code = generate(ast, options);
    return {
      ast: ast,
      render: code.render,
      staticRenderFns: code.staticRenderFns
    };
  });

  /*  */

  var ref$1 = createCompiler(baseOptions);
  var compileToFunctions = ref$1.compileToFunctions;

  /*  */

  var idToTemplate = cached(function (id) {
    var el = query(id);
    return el && el.innerHTML;
  });

  var mount = Vue$3.prototype.$mount;
  Vue$3.prototype.$mount = function (el, hydrating) {
    el = el && query(el);

    /* istanbul ignore if */
    if (el === document.body || el === document.documentElement) {
      "development" !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
      return this;
    }

    var options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
      var template = options.template;
      if (template) {
        if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
            /* istanbul ignore if */
            if ("development" !== 'production' && !template) {
              warn("Template element not found or is empty: " + options.template, this);
            }
          }
        } else if (template.nodeType) {
          template = template.innerHTML;
        } else {
          {
            warn('invalid template option:' + template, this);
          }
          return this;
        }
      } else if (el) {
        template = getOuterHTML(el);
      }
      if (template) {
        /* istanbul ignore if */
        if ("development" !== 'production' && config.performance && mark) {
          mark('compile');
        }

        var ref = compileToFunctions(template, {
          shouldDecodeNewlines: shouldDecodeNewlines,
          delimiters: options.delimiters,
          comments: options.comments
        }, this);
        var render = ref.render;
        var staticRenderFns = ref.staticRenderFns;
        options.render = render;
        options.staticRenderFns = staticRenderFns;

        /* istanbul ignore if */
        if ("development" !== 'production' && config.performance && mark) {
          mark('compile end');
          measure(this._name + " compile", 'compile', 'compile end');
        }
      }
    }
    return mount.call(this, el, hydrating);
  };

  /**
   * Get outerHTML of elements, taking care
   * of SVG elements in IE as well.
   */
  function getOuterHTML(el) {
    if (el.outerHTML) {
      return el.outerHTML;
    } else {
      var container = document.createElement('div');
      container.appendChild(el.cloneNode(true));
      return container.innerHTML;
    }
  }

  Vue$3.compile = compileToFunctions;

  return Vue$3;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
  * vue-router v2.7.0
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if (process.env.NODE_ENV !== 'production' && !condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1;
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (val && current !== vm || !val && current === vm) {
        matched.instances[name] = val;
      }
    }

    // also regiseter instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      if (process.env.NODE_ENV !== 'production') {
        warn(false, "props in \"" + route.path + "\" is a " + typeof config + ", " + "expecting an object, function or boolean.");
      }
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    process.env.NODE_ENV !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    var val = extraQuery[key];
    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;
  }
  return parsedQuery;
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;
  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route);
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal);
    }
    return String(aVal) === String(bVal);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = location.path ? createRoute(null, location, null, router) : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  var isDef = function (v) {
    return v !== undefined;
  };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = this.$parent && this.$parent._routerRoot || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this._routerRoot._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this._routerRoot._route;
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative;
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (index$1(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (index$1(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (process.env.NODE_ENV !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var normalizedPath = normalizePath(path, parent);
  var pathToRegexpOptions = route.pathToRegexpOptions || {};

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && !route.redirect && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];

    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function compileRouteRegex(path, pathToRegexpOptions) {
  var regex = index(path, [], pathToRegexpOptions);
  if (process.env.NODE_ENV !== 'production') {
    var keys = {};
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], "Duplicate param keys in route with path: \"" + path + "\"");
      keys[key.name] = true;
    });
  }
  return regex;
}

function normalizePath(path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

/*  */

function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;

  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      if (!record) {
        return _createRoute(null, location);
      }
      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      if (process.env.NODE_ENV !== 'production') {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if (process.env.NODE_ENV !== 'production') {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return;
    }
    var isObject = typeof shouldScroll === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};
        offset = normalizeOffset(offset);
        position = getElementPosition(el, offset);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function normalizeOffset(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (resolvedDef.__esModule && resolvedDef.default) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          process.env.NODE_ENV !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    var args = [],
        len = arguments.length;
    while (len--) args[len] = arguments[len];

    if (called) {
      return;
    }
    called = true;
    return fn.apply(this, args);
  };
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) {
        cb(err);
      });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function (err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === 'string' || typeof to === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () {
      return this$1.current === route;
    };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      var current = this$1.current;
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function pushHash(path) {
  window.location.hash = path;
}

function replaceHash(path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  window.location.replace(base + "#" + path);
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  process.env.NODE_ENV !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '2.7.0';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["a"] = (VueRouter);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(3)))

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Store */
/* unused harmony export mapState */
/* unused harmony export mapMutations */
/* unused harmony export mapGetters */
/* unused harmony export mapActions */
/**
 * vuex v2.3.0
 * (c) 2017 Evan You
 * @license MIT
 */
var applyMixin = function (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;
    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if (options === void 0) options = {};

      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit() {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin(store) {
  if (!devtoolHook) {
    return;
  }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */

/**
 * forEach for object
 */
function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function (key) {
    return fn(obj[key], key);
  });
}

function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

function isPromise(val) {
  return val && typeof val.then === 'function';
}

function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}

var Module = function Module(rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: {} };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced;
};

Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};

Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties(Module.prototype, prototypeAccessors$1);

var ModuleCollection = function ModuleCollection(rawRootModule) {
  var this$1 = this;

  // register root module (Vuex.Store options)
  this.root = new Module(rawRootModule, false);

  // register all nested modules
  if (rawRootModule.modules) {
    forEachValue(rawRootModule.modules, function (rawModule, key) {
      this$1.register([key], rawModule, false);
    });
  }
};

ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function (module, key) {
    return module.getChild(key);
  }, this.root);
};

ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '');
  }, '');
};

ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update(this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1 = this;
  if (runtime === void 0) runtime = true;

  var parent = this.get(path.slice(0, -1));
  var newModule = new Module(rawModule, runtime);
  parent.addChild(path[path.length - 1], newModule);

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) {
    return;
  }

  parent.removeChild(key);
};

function update(targetModule, newModule) {
  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, " + 'manual reload is needed');
        return;
      }
      update(targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var Vue; // bind on install

var Store = function Store(options) {
  var this$1 = this;
  if (options === void 0) options = {};

  assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
  assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");

  var state = options.state;if (state === void 0) state = {};
  var plugins = options.plugins;if (plugins === void 0) plugins = [];
  var strict = options.strict;if (strict === void 0) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch.call(store, type, payload);
  };
  this.commit = function boundCommit(type, payload, options) {
    return commit.call(store, type, payload, options);
  };

  // strict mode
  this.strict = strict;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.concat(devtoolPlugin).forEach(function (plugin) {
    return plugin(this$1);
  });
};

var prototypeAccessors = { state: {} };

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state;
};

prototypeAccessors.state.set = function (v) {
  assert(false, "Use store.replaceState() to explicit replace store state.");
};

Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    console.error("[vuex] unknown mutation type: " + type);
    return;
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) {
    return sub(mutation, this$1.state);
  });

  if (options && options.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. " + 'Use the filter functionality in the vue-devtools');
  }
};

Store.prototype.dispatch = function dispatch(_type, _payload) {
  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;

  var entry = this._actions[type];
  if (!entry) {
    console.error("[vuex] unknown action type: " + type);
    return;
  }
  return entry.length > 1 ? Promise.all(entry.map(function (handler) {
    return handler(payload);
  })) : entry[0](payload);
};

Store.prototype.subscribe = function subscribe(fn) {
  var subs = this._subscribers;
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  };
};

Store.prototype.watch = function watch(getter, cb, options) {
  var this$1 = this;

  assert(typeof getter === 'function', "store.watch only accepts a function.");
  return this._watcherVM.$watch(function () {
    return getter(this$1.state, this$1.getters);
  }, cb, options);
};

Store.prototype.replaceState = function replaceState(state) {
  var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule(path, rawModule) {
  if (typeof path === 'string') {
    path = [path];
  }
  assert(Array.isArray(path), "module path must be a string or an Array.");
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path));
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1 = this;

  if (typeof path === 'string') {
    path = [path];
  }
  assert(Array.isArray(path), "module path must be a string or an Array.");
  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties(Store.prototype, prototypeAccessors);

function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM(store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () {
      return fn(store);
    };
    Object.defineProperty(store.getters, key, {
      get: function () {
        return store._vm[key];
      },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () {
      return oldVm.$destroy();
    });
  }
}

function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var namespacedType = namespace + key;
    registerAction(store, namespacedType, action, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (!store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }

      return store.dispatch(type, payload);
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (!store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function () {
        return store.getters;
      } : function () {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function () {
        return getNestedState(store.state, path);
      }
    }
  });

  return local;
}

function makeLocalGetters(store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) {
      return;
    }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function () {
        return store.getters[type];
      },
      enumerable: true
    });
  });

  return gettersProxy;
}

function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler(local.state, payload);
  });
}

function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload, cb) {
    var res = handler({
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err;
      });
    } else {
      return res;
    }
  });
}

function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    console.error("[vuex] duplicate getter key: " + type);
    return;
  }
  store._wrappedGetters[type] = function wrappedGetter(store) {
    return rawGetter(local.state, // local state
    local.getters, // local getters
    store.state, // root state
    store.getters // root getters
    );
  };
}

function enableStrictMode(store) {
  store._vm.$watch(function () {
    return this._data.$$state;
  }, function () {
    assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
  }, { deep: true, sync: true });
}

function getNestedState(state, path) {
  return path.length ? path.reduce(function (state, key) {
    return state[key];
  }, state) : state;
}

function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  assert(typeof type === 'string', "Expects string as the type, but found " + typeof type + ".");

  return { type: type, payload: payload, options: options };
}

function install(_Vue) {
  if (Vue) {
    console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');
    return;
  }
  Vue = _Vue;
  applyMixin(Vue);
}

// auto install in dist mode
if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return;
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res;
});

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedMutation() {
      var args = [],
          len = arguments.length;
      while (len--) args[len] = arguments[len];

      if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {
        return;
      }
      return this.$store.commit.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return;
      }
      if (!(val in this.$store.getters)) {
        console.error("[vuex] unknown getter: " + val);
        return;
      }
      return this.$store.getters[val];
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res;
});

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedAction() {
      var args = [],
          len = arguments.length;
      while (len--) args[len] = arguments[len];

      if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {
        return;
      }
      return this.$store.dispatch.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});

function normalizeMap(map) {
  return Array.isArray(map) ? map.map(function (key) {
    return { key: key, val: key };
  }) : Object.keys(map).map(function (key) {
    return { key: key, val: map[key] };
  });
}

function normalizeNamespace(fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map);
  };
}

function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (!module) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace);
  }
  return module;
}

var index_esm = {
  Store: Store,
  install: install,
  version: '2.3.0',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions
};

/* harmony default export */ __webpack_exports__["a"] = (index_esm);

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Url */
/* unused harmony export Http */
/* unused harmony export Resource */
/*!
 * vue-resource v1.3.4
 * https://github.com/pagekit/vue-resource
 * Released under the MIT License.
 */

/**
 * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
 */

var RESOLVED = 0;
var REJECTED = 1;
var PENDING = 2;

function Promise$1(executor) {

    this.state = PENDING;
    this.value = undefined;
    this.deferred = [];

    var promise = this;

    try {
        executor(function (x) {
            promise.resolve(x);
        }, function (r) {
            promise.reject(r);
        });
    } catch (e) {
        promise.reject(e);
    }
}

Promise$1.reject = function (r) {
    return new Promise$1(function (resolve, reject) {
        reject(r);
    });
};

Promise$1.resolve = function (x) {
    return new Promise$1(function (resolve, reject) {
        resolve(x);
    });
};

Promise$1.all = function all(iterable) {
    return new Promise$1(function (resolve, reject) {
        var count = 0,
            result = [];

        if (iterable.length === 0) {
            resolve(result);
        }

        function resolver(i) {
            return function (x) {
                result[i] = x;
                count += 1;

                if (count === iterable.length) {
                    resolve(result);
                }
            };
        }

        for (var i = 0; i < iterable.length; i += 1) {
            Promise$1.resolve(iterable[i]).then(resolver(i), reject);
        }
    });
};

Promise$1.race = function race(iterable) {
    return new Promise$1(function (resolve, reject) {
        for (var i = 0; i < iterable.length; i += 1) {
            Promise$1.resolve(iterable[i]).then(resolve, reject);
        }
    });
};

var p$1 = Promise$1.prototype;

p$1.resolve = function resolve(x) {
    var promise = this;

    if (promise.state === PENDING) {
        if (x === promise) {
            throw new TypeError('Promise settled with itself.');
        }

        var called = false;

        try {
            var then = x && x['then'];

            if (x !== null && typeof x === 'object' && typeof then === 'function') {
                then.call(x, function (x) {
                    if (!called) {
                        promise.resolve(x);
                    }
                    called = true;
                }, function (r) {
                    if (!called) {
                        promise.reject(r);
                    }
                    called = true;
                });
                return;
            }
        } catch (e) {
            if (!called) {
                promise.reject(e);
            }
            return;
        }

        promise.state = RESOLVED;
        promise.value = x;
        promise.notify();
    }
};

p$1.reject = function reject(reason) {
    var promise = this;

    if (promise.state === PENDING) {
        if (reason === promise) {
            throw new TypeError('Promise settled with itself.');
        }

        promise.state = REJECTED;
        promise.value = reason;
        promise.notify();
    }
};

p$1.notify = function notify() {
    var promise = this;

    nextTick(function () {
        if (promise.state !== PENDING) {
            while (promise.deferred.length) {
                var deferred = promise.deferred.shift(),
                    onResolved = deferred[0],
                    onRejected = deferred[1],
                    resolve = deferred[2],
                    reject = deferred[3];

                try {
                    if (promise.state === RESOLVED) {
                        if (typeof onResolved === 'function') {
                            resolve(onResolved.call(undefined, promise.value));
                        } else {
                            resolve(promise.value);
                        }
                    } else if (promise.state === REJECTED) {
                        if (typeof onRejected === 'function') {
                            resolve(onRejected.call(undefined, promise.value));
                        } else {
                            reject(promise.value);
                        }
                    }
                } catch (e) {
                    reject(e);
                }
            }
        }
    });
};

p$1.then = function then(onResolved, onRejected) {
    var promise = this;

    return new Promise$1(function (resolve, reject) {
        promise.deferred.push([onResolved, onRejected, resolve, reject]);
        promise.notify();
    });
};

p$1.catch = function (onRejected) {
    return this.then(undefined, onRejected);
};

/**
 * Promise adapter.
 */

if (typeof Promise === 'undefined') {
    window.Promise = Promise$1;
}

function PromiseObj(executor, context) {

    if (executor instanceof Promise) {
        this.promise = executor;
    } else {
        this.promise = new Promise(executor.bind(context));
    }

    this.context = context;
}

PromiseObj.all = function (iterable, context) {
    return new PromiseObj(Promise.all(iterable), context);
};

PromiseObj.resolve = function (value, context) {
    return new PromiseObj(Promise.resolve(value), context);
};

PromiseObj.reject = function (reason, context) {
    return new PromiseObj(Promise.reject(reason), context);
};

PromiseObj.race = function (iterable, context) {
    return new PromiseObj(Promise.race(iterable), context);
};

var p = PromiseObj.prototype;

p.bind = function (context) {
    this.context = context;
    return this;
};

p.then = function (fulfilled, rejected) {

    if (fulfilled && fulfilled.bind && this.context) {
        fulfilled = fulfilled.bind(this.context);
    }

    if (rejected && rejected.bind && this.context) {
        rejected = rejected.bind(this.context);
    }

    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);
};

p.catch = function (rejected) {

    if (rejected && rejected.bind && this.context) {
        rejected = rejected.bind(this.context);
    }

    return new PromiseObj(this.promise.catch(rejected), this.context);
};

p.finally = function (callback) {

    return this.then(function (value) {
        callback.call(this);
        return value;
    }, function (reason) {
        callback.call(this);
        return Promise.reject(reason);
    });
};

/**
 * Utility functions.
 */

var ref = {};
var hasOwnProperty = ref.hasOwnProperty;

var ref$1 = [];
var slice = ref$1.slice;
var debug = false;
var ntick;

var inBrowser = typeof window !== 'undefined';

var Util = function (ref) {
    var config = ref.config;
    var nextTick = ref.nextTick;

    ntick = nextTick;
    debug = config.debug || !config.silent;
};

function warn(msg) {
    if (typeof console !== 'undefined' && debug) {
        console.warn('[VueResource warn]: ' + msg);
    }
}

function error(msg) {
    if (typeof console !== 'undefined') {
        console.error(msg);
    }
}

function nextTick(cb, ctx) {
    return ntick(cb, ctx);
}

function trim(str) {
    return str ? str.replace(/^\s*|\s*$/g, '') : '';
}

function trimEnd(str, chars) {

    if (str && chars === undefined) {
        return str.replace(/\s+$/, '');
    }

    if (!str || !chars) {
        return str;
    }

    return str.replace(new RegExp("[" + chars + "]+$"), '');
}

function toLower(str) {
    return str ? str.toLowerCase() : '';
}

function toUpper(str) {
    return str ? str.toUpperCase() : '';
}

var isArray = Array.isArray;

function isString(val) {
    return typeof val === 'string';
}

function isFunction(val) {
    return typeof val === 'function';
}

function isObject(obj) {
    return obj !== null && typeof obj === 'object';
}

function isPlainObject(obj) {
    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
}

function isBlob(obj) {
    return typeof Blob !== 'undefined' && obj instanceof Blob;
}

function isFormData(obj) {
    return typeof FormData !== 'undefined' && obj instanceof FormData;
}

function when(value, fulfilled, rejected) {

    var promise = PromiseObj.resolve(value);

    if (arguments.length < 2) {
        return promise;
    }

    return promise.then(fulfilled, rejected);
}

function options(fn, obj, opts) {

    opts = opts || {};

    if (isFunction(opts)) {
        opts = opts.call(obj);
    }

    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });
}

function each(obj, iterator) {

    var i, key;

    if (isArray(obj)) {
        for (i = 0; i < obj.length; i++) {
            iterator.call(obj[i], obj[i], i);
        }
    } else if (isObject(obj)) {
        for (key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                iterator.call(obj[key], obj[key], key);
            }
        }
    }

    return obj;
}

var assign = Object.assign || _assign;

function merge(target) {

    var args = slice.call(arguments, 1);

    args.forEach(function (source) {
        _merge(target, source, true);
    });

    return target;
}

function defaults(target) {

    var args = slice.call(arguments, 1);

    args.forEach(function (source) {

        for (var key in source) {
            if (target[key] === undefined) {
                target[key] = source[key];
            }
        }
    });

    return target;
}

function _assign(target) {

    var args = slice.call(arguments, 1);

    args.forEach(function (source) {
        _merge(target, source);
    });

    return target;
}

function _merge(target, source, deep) {
    for (var key in source) {
        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
                target[key] = {};
            }
            if (isArray(source[key]) && !isArray(target[key])) {
                target[key] = [];
            }
            _merge(target[key], source[key], deep);
        } else if (source[key] !== undefined) {
            target[key] = source[key];
        }
    }
}

/**
 * Root Prefix Transform.
 */

var root = function (options$$1, next) {

    var url = next(options$$1);

    if (isString(options$$1.root) && !/^(https?:)?\//.test(url)) {
        url = trimEnd(options$$1.root, '/') + '/' + url;
    }

    return url;
};

/**
 * Query Parameter Transform.
 */

var query = function (options$$1, next) {

    var urlParams = Object.keys(Url.options.params),
        query = {},
        url = next(options$$1);

    each(options$$1.params, function (value, key) {
        if (urlParams.indexOf(key) === -1) {
            query[key] = value;
        }
    });

    query = Url.params(query);

    if (query) {
        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
    }

    return url;
};

/**
 * URL Template v2.0.6 (https://github.com/bramstein/url-template)
 */

function expand(url, params, variables) {

    var tmpl = parse(url),
        expanded = tmpl.expand(params);

    if (variables) {
        variables.push.apply(variables, tmpl.vars);
    }

    return expanded;
}

function parse(template) {

    var operators = ['+', '#', '.', '/', ';', '?', '&'],
        variables = [];

    return {
        vars: variables,
        expand: function expand(context) {
            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
                if (expression) {

                    var operator = null,
                        values = [];

                    if (operators.indexOf(expression.charAt(0)) !== -1) {
                        operator = expression.charAt(0);
                        expression = expression.substr(1);
                    }

                    expression.split(/,/g).forEach(function (variable) {
                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
                        variables.push(tmp[1]);
                    });

                    if (operator && operator !== '+') {

                        var separator = ',';

                        if (operator === '?') {
                            separator = '&';
                        } else if (operator !== '#') {
                            separator = operator;
                        }

                        return (values.length !== 0 ? operator : '') + values.join(separator);
                    } else {
                        return values.join(',');
                    }
                } else {
                    return encodeReserved(literal);
                }
            });
        }
    };
}

function getValues(context, operator, key, modifier) {

    var value = context[key],
        result = [];

    if (isDefined(value) && value !== '') {
        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
            value = value.toString();

            if (modifier && modifier !== '*') {
                value = value.substring(0, parseInt(modifier, 10));
            }

            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
        } else {
            if (modifier === '*') {
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
                    });
                } else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            result.push(encodeValue(operator, value[k], k));
                        }
                    });
                }
            } else {
                var tmp = [];

                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function (value) {
                        tmp.push(encodeValue(operator, value));
                    });
                } else {
                    Object.keys(value).forEach(function (k) {
                        if (isDefined(value[k])) {
                            tmp.push(encodeURIComponent(k));
                            tmp.push(encodeValue(operator, value[k].toString()));
                        }
                    });
                }

                if (isKeyOperator(operator)) {
                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
                } else if (tmp.length !== 0) {
                    result.push(tmp.join(','));
                }
            }
        }
    } else {
        if (operator === ';') {
            result.push(encodeURIComponent(key));
        } else if (value === '' && (operator === '&' || operator === '?')) {
            result.push(encodeURIComponent(key) + '=');
        } else if (value === '') {
            result.push('');
        }
    }

    return result;
}

function isDefined(value) {
    return value !== undefined && value !== null;
}

function isKeyOperator(operator) {
    return operator === ';' || operator === '&' || operator === '?';
}

function encodeValue(operator, value, key) {

    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);

    if (key) {
        return encodeURIComponent(key) + '=' + value;
    } else {
        return value;
    }
}

function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part);
        }
        return part;
    }).join('');
}

/**
 * URL Template (RFC 6570) Transform.
 */

var template = function (options) {

    var variables = [],
        url = expand(options.url, options.params, variables);

    variables.forEach(function (key) {
        delete options.params[key];
    });

    return url;
};

/**
 * Service for URL templating.
 */

function Url(url, params) {

    var self = this || {},
        options$$1 = url,
        transform;

    if (isString(url)) {
        options$$1 = { url: url, params: params };
    }

    options$$1 = merge({}, Url.options, self.$options, options$$1);

    Url.transforms.forEach(function (handler) {

        if (isString(handler)) {
            handler = Url.transform[handler];
        }

        if (isFunction(handler)) {
            transform = factory(handler, transform, self.$vm);
        }
    });

    return transform(options$$1);
}

/**
 * Url options.
 */

Url.options = {
    url: '',
    root: null,
    params: {}
};

/**
 * Url transforms.
 */

Url.transform = { template: template, query: query, root: root };
Url.transforms = ['template', 'query', 'root'];

/**
 * Encodes a Url parameter string.
 *
 * @param {Object} obj
 */

Url.params = function (obj) {

    var params = [],
        escape = encodeURIComponent;

    params.add = function (key, value) {

        if (isFunction(value)) {
            value = value();
        }

        if (value === null) {
            value = '';
        }

        this.push(escape(key) + '=' + escape(value));
    };

    serialize(params, obj);

    return params.join('&').replace(/%20/g, '+');
};

/**
 * Parse a URL and return its components.
 *
 * @param {String} url
 */

Url.parse = function (url) {

    var el = document.createElement('a');

    if (document.documentMode) {
        el.href = url;
        url = el.href;
    }

    el.href = url;

    return {
        href: el.href,
        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
        port: el.port,
        host: el.host,
        hostname: el.hostname,
        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
        search: el.search ? el.search.replace(/^\?/, '') : '',
        hash: el.hash ? el.hash.replace(/^#/, '') : ''
    };
};

function factory(handler, next, vm) {
    return function (options$$1) {
        return handler.call(vm, options$$1, next);
    };
}

function serialize(params, obj, scope) {

    var array = isArray(obj),
        plain = isPlainObject(obj),
        hash;

    each(obj, function (value, key) {

        hash = isObject(value) || isArray(value);

        if (scope) {
            key = scope + '[' + (plain || hash ? key : '') + ']';
        }

        if (!scope && array) {
            params.add(value.name, value.value);
        } else if (hash) {
            serialize(params, value, key);
        } else {
            params.add(key, value);
        }
    });
}

/**
 * XDomain client (Internet Explorer).
 */

var xdrClient = function (request) {
    return new PromiseObj(function (resolve) {

        var xdr = new XDomainRequest(),
            handler = function (ref) {
            var type = ref.type;

            var status = 0;

            if (type === 'load') {
                status = 200;
            } else if (type === 'error') {
                status = 500;
            }

            resolve(request.respondWith(xdr.responseText, { status: status }));
        };

        request.abort = function () {
            return xdr.abort();
        };

        xdr.open(request.method, request.getUrl());

        if (request.timeout) {
            xdr.timeout = request.timeout;
        }

        xdr.onload = handler;
        xdr.onabort = handler;
        xdr.onerror = handler;
        xdr.ontimeout = handler;
        xdr.onprogress = function () {};
        xdr.send(request.getBody());
    });
};

/**
 * CORS Interceptor.
 */

var SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();

var cors = function (request, next) {

    if (inBrowser) {

        var orgUrl = Url.parse(location.href);
        var reqUrl = Url.parse(request.getUrl());

        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {

            request.crossOrigin = true;
            request.emulateHTTP = false;

            if (!SUPPORTS_CORS) {
                request.client = xdrClient;
            }
        }
    }

    next();
};

/**
 * Form data Interceptor.
 */

var form = function (request, next) {

    if (isFormData(request.body)) {

        request.headers.delete('Content-Type');
    } else if (isObject(request.body) && request.emulateJSON) {

        request.body = Url.params(request.body);
        request.headers.set('Content-Type', 'application/x-www-form-urlencoded');
    }

    next();
};

/**
 * JSON Interceptor.
 */

var json = function (request, next) {

    var type = request.headers.get('Content-Type') || '';

    if (isObject(request.body) && type.indexOf('application/json') === 0) {
        request.body = JSON.stringify(request.body);
    }

    next(function (response) {

        return response.bodyText ? when(response.text(), function (text) {

            type = response.headers.get('Content-Type') || '';

            if (type.indexOf('application/json') === 0 || isJson(text)) {

                try {
                    response.body = JSON.parse(text);
                } catch (e) {
                    response.body = null;
                }
            } else {
                response.body = text;
            }

            return response;
        }) : response;
    });
};

function isJson(str) {

    var start = str.match(/^\[|^\{(?!\{)/),
        end = { '[': /]$/, '{': /}$/ };

    return start && end[start[0]].test(str);
}

/**
 * JSONP client (Browser).
 */

var jsonpClient = function (request) {
    return new PromiseObj(function (resolve) {

        var name = request.jsonp || 'callback',
            callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2),
            body = null,
            handler,
            script;

        handler = function (ref) {
            var type = ref.type;

            var status = 0;

            if (type === 'load' && body !== null) {
                status = 200;
            } else if (type === 'error') {
                status = 500;
            }

            if (status && window[callback]) {
                delete window[callback];
                document.body.removeChild(script);
            }

            resolve(request.respondWith(body, { status: status }));
        };

        window[callback] = function (result) {
            body = JSON.stringify(result);
        };

        request.abort = function () {
            handler({ type: 'abort' });
        };

        request.params[name] = callback;

        if (request.timeout) {
            setTimeout(request.abort, request.timeout);
        }

        script = document.createElement('script');
        script.src = request.getUrl();
        script.type = 'text/javascript';
        script.async = true;
        script.onload = handler;
        script.onerror = handler;

        document.body.appendChild(script);
    });
};

/**
 * JSONP Interceptor.
 */

var jsonp = function (request, next) {

    if (request.method == 'JSONP') {
        request.client = jsonpClient;
    }

    next();
};

/**
 * Before Interceptor.
 */

var before = function (request, next) {

    if (isFunction(request.before)) {
        request.before.call(this, request);
    }

    next();
};

/**
 * HTTP method override Interceptor.
 */

var method = function (request, next) {

    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
        request.headers.set('X-HTTP-Method-Override', request.method);
        request.method = 'POST';
    }

    next();
};

/**
 * Header Interceptor.
 */

var header = function (request, next) {

    var headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[toLower(request.method)]);

    each(headers, function (value, name) {
        if (!request.headers.has(name)) {
            request.headers.set(name, value);
        }
    });

    next();
};

/**
 * XMLHttp client (Browser).
 */

var xhrClient = function (request) {
    return new PromiseObj(function (resolve) {

        var xhr = new XMLHttpRequest(),
            handler = function (event) {

            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {
                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)
            });

            each(trim(xhr.getAllResponseHeaders()).split('\n'), function (row) {
                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));
            });

            resolve(response);
        };

        request.abort = function () {
            return xhr.abort();
        };

        if (request.progress) {
            if (request.method === 'GET') {
                xhr.addEventListener('progress', request.progress);
            } else if (/^(POST|PUT)$/i.test(request.method)) {
                xhr.upload.addEventListener('progress', request.progress);
            }
        }

        xhr.open(request.method, request.getUrl(), true);

        if (request.timeout) {
            xhr.timeout = request.timeout;
        }

        if (request.responseType && 'responseType' in xhr) {
            xhr.responseType = request.responseType;
        }

        if (request.withCredentials || request.credentials) {
            xhr.withCredentials = true;
        }

        if (!request.crossOrigin) {
            request.headers.set('X-Requested-With', 'XMLHttpRequest');
        }

        request.headers.forEach(function (value, name) {
            xhr.setRequestHeader(name, value);
        });

        xhr.onload = handler;
        xhr.onabort = handler;
        xhr.onerror = handler;
        xhr.ontimeout = handler;
        xhr.send(request.getBody());
    });
};

/**
 * Http client (Node).
 */

var nodeClient = function (request) {

    var client = __webpack_require__(21);

    return new PromiseObj(function (resolve) {

        var url = request.getUrl();
        var body = request.getBody();
        var method = request.method;
        var headers = {},
            handler;

        request.headers.forEach(function (value, name) {
            headers[name] = value;
        });

        client(url, { body: body, method: method, headers: headers }).then(handler = function (resp) {

            var response = request.respondWith(resp.body, {
                status: resp.statusCode,
                statusText: trim(resp.statusMessage)
            });

            each(resp.headers, function (value, name) {
                response.headers.set(name, value);
            });

            resolve(response);
        }, function (error$$1) {
            return handler(error$$1.response);
        });
    });
};

/**
 * Base client.
 */

var Client = function (context) {

    var reqHandlers = [sendRequest],
        resHandlers = [],
        handler;

    if (!isObject(context)) {
        context = null;
    }

    function Client(request) {
        return new PromiseObj(function (resolve, reject) {

            function exec() {

                handler = reqHandlers.pop();

                if (isFunction(handler)) {
                    handler.call(context, request, next);
                } else {
                    warn("Invalid interceptor of type " + typeof handler + ", must be a function");
                    next();
                }
            }

            function next(response) {

                if (isFunction(response)) {

                    resHandlers.unshift(response);
                } else if (isObject(response)) {

                    resHandlers.forEach(function (handler) {
                        response = when(response, function (response) {
                            return handler.call(context, response) || response;
                        }, reject);
                    });

                    when(response, resolve, reject);

                    return;
                }

                exec();
            }

            exec();
        }, context);
    }

    Client.use = function (handler) {
        reqHandlers.push(handler);
    };

    return Client;
};

function sendRequest(request, resolve) {

    var client = request.client || (inBrowser ? xhrClient : nodeClient);

    resolve(client(request));
}

/**
 * HTTP Headers.
 */

var Headers = function Headers(headers) {
    var this$1 = this;

    this.map = {};

    each(headers, function (value, name) {
        return this$1.append(name, value);
    });
};

Headers.prototype.has = function has(name) {
    return getName(this.map, name) !== null;
};

Headers.prototype.get = function get(name) {

    var list = this.map[getName(this.map, name)];

    return list ? list.join() : null;
};

Headers.prototype.getAll = function getAll(name) {
    return this.map[getName(this.map, name)] || [];
};

Headers.prototype.set = function set(name, value) {
    this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];
};

Headers.prototype.append = function append(name, value) {

    var list = this.map[getName(this.map, name)];

    if (list) {
        list.push(trim(value));
    } else {
        this.set(name, value);
    }
};

Headers.prototype.delete = function delete$1(name) {
    delete this.map[getName(this.map, name)];
};

Headers.prototype.deleteAll = function deleteAll() {
    this.map = {};
};

Headers.prototype.forEach = function forEach(callback, thisArg) {
    var this$1 = this;

    each(this.map, function (list, name) {
        each(list, function (value) {
            return callback.call(thisArg, value, name, this$1);
        });
    });
};

function getName(map, name) {
    return Object.keys(map).reduce(function (prev, curr) {
        return toLower(name) === toLower(curr) ? curr : prev;
    }, null);
}

function normalizeName(name) {

    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name');
    }

    return trim(name);
}

/**
 * HTTP Response.
 */

var Response = function Response(body, ref) {
    var url = ref.url;
    var headers = ref.headers;
    var status = ref.status;
    var statusText = ref.statusText;

    this.url = url;
    this.ok = status >= 200 && status < 300;
    this.status = status || 0;
    this.statusText = statusText || '';
    this.headers = new Headers(headers);
    this.body = body;

    if (isString(body)) {

        this.bodyText = body;
    } else if (isBlob(body)) {

        this.bodyBlob = body;

        if (isBlobText(body)) {
            this.bodyText = blobText(body);
        }
    }
};

Response.prototype.blob = function blob() {
    return when(this.bodyBlob);
};

Response.prototype.text = function text() {
    return when(this.bodyText);
};

Response.prototype.json = function json() {
    return when(this.text(), function (text) {
        return JSON.parse(text);
    });
};

Object.defineProperty(Response.prototype, 'data', {

    get: function get() {
        return this.body;
    },

    set: function set(body) {
        this.body = body;
    }

});

function blobText(body) {
    return new PromiseObj(function (resolve) {

        var reader = new FileReader();

        reader.readAsText(body);
        reader.onload = function () {
            resolve(reader.result);
        };
    });
}

function isBlobText(body) {
    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;
}

/**
 * HTTP Request.
 */

var Request = function Request(options$$1) {

    this.body = null;
    this.params = {};

    assign(this, options$$1, {
        method: toUpper(options$$1.method || 'GET')
    });

    if (!(this.headers instanceof Headers)) {
        this.headers = new Headers(this.headers);
    }
};

Request.prototype.getUrl = function getUrl() {
    return Url(this);
};

Request.prototype.getBody = function getBody() {
    return this.body;
};

Request.prototype.respondWith = function respondWith(body, options$$1) {
    return new Response(body, assign(options$$1 || {}, { url: this.getUrl() }));
};

/**
 * Service for sending network requests.
 */

var COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };
var JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };

function Http(options$$1) {

    var self = this || {},
        client = Client(self.$vm);

    defaults(options$$1 || {}, self.$options, Http.options);

    Http.interceptors.forEach(function (handler) {

        if (isString(handler)) {
            handler = Http.interceptor[handler];
        }

        if (isFunction(handler)) {
            client.use(handler);
        }
    });

    return client(new Request(options$$1)).then(function (response) {

        return response.ok ? response : PromiseObj.reject(response);
    }, function (response) {

        if (response instanceof Error) {
            error(response);
        }

        return PromiseObj.reject(response);
    });
}

Http.options = {};

Http.headers = {
    put: JSON_CONTENT_TYPE,
    post: JSON_CONTENT_TYPE,
    patch: JSON_CONTENT_TYPE,
    delete: JSON_CONTENT_TYPE,
    common: COMMON_HEADERS,
    custom: {}
};

Http.interceptor = { before: before, method: method, jsonp: jsonp, json: json, form: form, header: header, cors: cors };
Http.interceptors = ['before', 'method', 'jsonp', 'json', 'form', 'header', 'cors'];

['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {

    Http[method$$1] = function (url, options$$1) {
        return this(assign(options$$1 || {}, { url: url, method: method$$1 }));
    };
});

['post', 'put', 'patch'].forEach(function (method$$1) {

    Http[method$$1] = function (url, body, options$$1) {
        return this(assign(options$$1 || {}, { url: url, method: method$$1, body: body }));
    };
});

/**
 * Service for interacting with RESTful services.
 */

function Resource(url, params, actions, options$$1) {

    var self = this || {},
        resource = {};

    actions = assign({}, Resource.actions, actions);

    each(actions, function (action, name) {

        action = merge({ url: url, params: assign({}, params) }, options$$1, action);

        resource[name] = function () {
            return (self.$http || Http)(opts(action, arguments));
        };
    });

    return resource;
}

function opts(action, args) {

    var options$$1 = assign({}, action),
        params = {},
        body;

    switch (args.length) {

        case 2:

            params = args[0];
            body = args[1];

            break;

        case 1:

            if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {
                body = args[0];
            } else {
                params = args[0];
            }

            break;

        case 0:

            break;

        default:

            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';
    }

    options$$1.body = body;
    options$$1.params = assign({}, options$$1.params, params);

    return options$$1;
}

Resource.actions = {

    get: { method: 'GET' },
    save: { method: 'POST' },
    query: { method: 'GET' },
    update: { method: 'PUT' },
    remove: { method: 'DELETE' },
    delete: { method: 'DELETE' }

};

/**
 * Install plugin.
 */

function plugin(Vue) {

    if (plugin.installed) {
        return;
    }

    Util(Vue);

    Vue.url = Url;
    Vue.http = Http;
    Vue.resource = Resource;
    Vue.Promise = PromiseObj;

    Object.defineProperties(Vue.prototype, {

        $url: {
            get: function get() {
                return options(Vue.url, this, this.$options.url);
            }
        },

        $http: {
            get: function get() {
                return options(Vue.http, this, this.$options.http);
            }
        },

        $resource: {
            get: function get() {
                return Vue.resource.bind(this);
            }
        },

        $promise: {
            get: function get() {
                var this$1 = this;

                return function (executor) {
                    return new Vue.Promise(executor, this$1);
                };
            }
        }

    });
}

if (typeof window !== 'undefined' && window.Vue) {
    window.Vue.use(plugin);
}

/* harmony default export */ __webpack_exports__["a"] = (plugin);


/***/ }),
/* 21 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(23);

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var bind = __webpack_require__(7);
var Axios = __webpack_require__(25);
var defaults = __webpack_require__(4);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(11);
axios.CancelToken = __webpack_require__(39);
axios.isCancel = __webpack_require__(10);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(40);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

/***/ }),
/* 24 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(4);
var utils = __webpack_require__(0);
var InterceptorManager = __webpack_require__(34);
var dispatchRequest = __webpack_require__(35);
var isAbsoluteURL = __webpack_require__(37);
var combineURLs = __webpack_require__(38);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(9);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :

// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error();
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
  // initialize result and counter
  var block, charCode, idx = 0, map = chars;
  // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1);
  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :

// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var transformData = __webpack_require__(36);
var isCancel = __webpack_require__(10);
var defaults = __webpack_require__(4);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(config.data, config.headers, config.transformRequest);

  // Flatten headers
  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});

  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(response.data, response.headers, config.transformResponse);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
  );
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(11);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(42),
  /* template */
  __webpack_require__(46),
  /* styles */
  null,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "D:\\newtest\\6.20\\bilibili-live\\node_modules\\_vue-awesome-swiper@2.5.4@vue-awesome-swiper\\swiper.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] swiper.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-d3a671a8", Component.options)
  } else {
    hotAPI.reload("data-v-d3a671a8", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//

var browser = typeof window !== 'undefined';
if (browser) {
  window.Swiper = __webpack_require__(13);
  __webpack_require__(43);
}
/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'swiper',
  props: {
    options: {
      type: Object,
      default() {
        return {
          autoplay: 3500
        };
      }
    }
  },
  data() {
    return {
      defaultSwiperClasses: {
        wrapperClass: 'swiper-wrapper'
      }
    };
  },
  ready() {
    if (!this.swiper && browser) {
      this.swiper = new Swiper(this.$el, this.options);
    }
  },
  mounted() {
    var self = this;
    var mount = function () {
      if (!self.swiper && browser) {
        delete self.options.notNextTick;
        var setClassName = false;
        for (var className in self.defaultSwiperClasses) {
          if (self.defaultSwiperClasses.hasOwnProperty(className)) {
            if (self.options[className]) {
              setClassName = true;
              self.defaultSwiperClasses[className] = self.options[className];
            }
          }
        }
        var mountInstance = function () {
          self.swiper = new Swiper(self.$el, self.options);
        };
        setClassName ? self.$nextTick(mountInstance) : mountInstance();
      }
    };
    this.options.notNextTick ? mount() : this.$nextTick(mount);
  },
  updated() {
    if (this.swiper) {
      this.swiper.update();
    }
  },
  beforeDestroy() {
    if (this.swiper) {
      this.swiper.destroy();
      delete this.swiper;
    }
  }
});

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(44);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(14)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../_css-loader@0.28.4@css-loader/index.js!./swiper.css", function() {
			var newContent = require("!!../../../_css-loader@0.28.4@css-loader/index.js!./swiper.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)(undefined);
// imports


// module
exports.push([module.i, "/**\n * Swiper 3.4.2\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * \n * http://www.idangero.us/swiper/\n * \n * Copyright 2017, Vladimir Kharlampidi\n * The iDangero.us\n * http://www.idangero.us/\n * \n * Licensed under MIT\n * \n * Released on: March 10, 2017\n */\n.swiper-container {\n  margin-left: auto;\n  margin-right: auto;\n  position: relative;\n  overflow: hidden;\n  /* Fix of Webkit flickering */\n  z-index: 1;\n}\n.swiper-container-no-flexbox .swiper-slide {\n  float: left;\n}\n.swiper-container-vertical > .swiper-wrapper {\n  -webkit-box-orient: vertical;\n  -moz-box-orient: vertical;\n  -ms-flex-direction: column;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n.swiper-wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  display: -webkit-box;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-transition-property: -webkit-transform;\n  -moz-transition-property: -moz-transform;\n  -o-transition-property: -o-transform;\n  -ms-transition-property: -ms-transform;\n  transition-property: transform;\n  -webkit-box-sizing: content-box;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n.swiper-container-android .swiper-slide,\n.swiper-wrapper {\n  -webkit-transform: translate3d(0px, 0, 0);\n  -moz-transform: translate3d(0px, 0, 0);\n  -o-transform: translate(0px, 0px);\n  -ms-transform: translate3d(0px, 0, 0);\n  transform: translate3d(0px, 0, 0);\n}\n.swiper-container-multirow > .swiper-wrapper {\n  -webkit-box-lines: multiple;\n  -moz-box-lines: multiple;\n  -ms-flex-wrap: wrap;\n  -webkit-flex-wrap: wrap;\n  flex-wrap: wrap;\n}\n.swiper-container-free-mode > .swiper-wrapper {\n  -webkit-transition-timing-function: ease-out;\n  -moz-transition-timing-function: ease-out;\n  -ms-transition-timing-function: ease-out;\n  -o-transition-timing-function: ease-out;\n  transition-timing-function: ease-out;\n  margin: 0 auto;\n}\n.swiper-slide {\n  -webkit-flex-shrink: 0;\n  -ms-flex: 0 0 auto;\n  flex-shrink: 0;\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n/* Auto Height */\n.swiper-container-autoheight,\n.swiper-container-autoheight .swiper-slide {\n  height: auto;\n}\n.swiper-container-autoheight .swiper-wrapper {\n  -webkit-box-align: start;\n  -ms-flex-align: start;\n  -webkit-align-items: flex-start;\n  align-items: flex-start;\n  -webkit-transition-property: -webkit-transform, height;\n  -moz-transition-property: -moz-transform;\n  -o-transition-property: -o-transform;\n  -ms-transition-property: -ms-transform;\n  transition-property: transform, height;\n}\n/* a11y */\n.swiper-container .swiper-notification {\n  position: absolute;\n  left: 0;\n  top: 0;\n  pointer-events: none;\n  opacity: 0;\n  z-index: -1000;\n}\n/* IE10 Windows Phone 8 Fixes */\n.swiper-wp8-horizontal {\n  -ms-touch-action: pan-y;\n  touch-action: pan-y;\n}\n.swiper-wp8-vertical {\n  -ms-touch-action: pan-x;\n  touch-action: pan-x;\n}\n/* Arrows */\n.swiper-button-prev,\n.swiper-button-next {\n  position: absolute;\n  top: 50%;\n  width: 27px;\n  height: 44px;\n  margin-top: -22px;\n  z-index: 10;\n  cursor: pointer;\n  -moz-background-size: 27px 44px;\n  -webkit-background-size: 27px 44px;\n  background-size: 27px 44px;\n  background-position: center;\n  background-repeat: no-repeat;\n}\n.swiper-button-prev.swiper-button-disabled,\n.swiper-button-next.swiper-button-disabled {\n  opacity: 0.35;\n  cursor: auto;\n  pointer-events: none;\n}\n.swiper-button-prev,\n.swiper-container-rtl .swiper-button-next {\n  background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");\n  left: 10px;\n  right: auto;\n}\n.swiper-button-prev.swiper-button-black,\n.swiper-container-rtl .swiper-button-next.swiper-button-black {\n  background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\");\n}\n.swiper-button-prev.swiper-button-white,\n.swiper-container-rtl .swiper-button-next.swiper-button-white {\n  background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\");\n}\n.swiper-button-next,\n.swiper-container-rtl .swiper-button-prev {\n  background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");\n  right: 10px;\n  left: auto;\n}\n.swiper-button-next.swiper-button-black,\n.swiper-container-rtl .swiper-button-prev.swiper-button-black {\n  background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\");\n}\n.swiper-button-next.swiper-button-white,\n.swiper-container-rtl .swiper-button-prev.swiper-button-white {\n  background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\");\n}\n/* Pagination Styles */\n.swiper-pagination {\n  position: absolute;\n  text-align: center;\n  -webkit-transition: 300ms;\n  -moz-transition: 300ms;\n  -o-transition: 300ms;\n  transition: 300ms;\n  -webkit-transform: translate3d(0, 0, 0);\n  -ms-transform: translate3d(0, 0, 0);\n  -o-transform: translate3d(0, 0, 0);\n  transform: translate3d(0, 0, 0);\n  z-index: 10;\n}\n.swiper-pagination.swiper-pagination-hidden {\n  opacity: 0;\n}\n/* Common Styles */\n.swiper-pagination-fraction,\n.swiper-pagination-custom,\n.swiper-container-horizontal > .swiper-pagination-bullets {\n  bottom: 10px;\n  left: 0;\n  width: 100%;\n}\n/* Bullets */\n.swiper-pagination-bullet {\n  width: 8px;\n  height: 8px;\n  display: inline-block;\n  border-radius: 100%;\n  background: #000;\n  opacity: 0.2;\n}\nbutton.swiper-pagination-bullet {\n  border: none;\n  margin: 0;\n  padding: 0;\n  box-shadow: none;\n  -moz-appearance: none;\n  -ms-appearance: none;\n  -webkit-appearance: none;\n  appearance: none;\n}\n.swiper-pagination-clickable .swiper-pagination-bullet {\n  cursor: pointer;\n}\n.swiper-pagination-white .swiper-pagination-bullet {\n  background: #fff;\n}\n.swiper-pagination-bullet-active {\n  opacity: 1;\n  background: #007aff;\n}\n.swiper-pagination-white .swiper-pagination-bullet-active {\n  background: #fff;\n}\n.swiper-pagination-black .swiper-pagination-bullet-active {\n  background: #000;\n}\n.swiper-container-vertical > .swiper-pagination-bullets {\n  right: 10px;\n  top: 50%;\n  -webkit-transform: translate3d(0px, -50%, 0);\n  -moz-transform: translate3d(0px, -50%, 0);\n  -o-transform: translate(0px, -50%);\n  -ms-transform: translate3d(0px, -50%, 0);\n  transform: translate3d(0px, -50%, 0);\n}\n.swiper-container-vertical > .swiper-pagination-bullets .swiper-pagination-bullet {\n  margin: 5px 0;\n  display: block;\n}\n.swiper-container-horizontal > .swiper-pagination-bullets .swiper-pagination-bullet {\n  margin: 0 5px;\n}\n/* Progress */\n.swiper-pagination-progress {\n  background: rgba(0, 0, 0, 0.25);\n  position: absolute;\n}\n.swiper-pagination-progress .swiper-pagination-progressbar {\n  background: #007aff;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  -webkit-transform: scale(0);\n  -ms-transform: scale(0);\n  -o-transform: scale(0);\n  transform: scale(0);\n  -webkit-transform-origin: left top;\n  -moz-transform-origin: left top;\n  -ms-transform-origin: left top;\n  -o-transform-origin: left top;\n  transform-origin: left top;\n}\n.swiper-container-rtl .swiper-pagination-progress .swiper-pagination-progressbar {\n  -webkit-transform-origin: right top;\n  -moz-transform-origin: right top;\n  -ms-transform-origin: right top;\n  -o-transform-origin: right top;\n  transform-origin: right top;\n}\n.swiper-container-horizontal > .swiper-pagination-progress {\n  width: 100%;\n  height: 4px;\n  left: 0;\n  top: 0;\n}\n.swiper-container-vertical > .swiper-pagination-progress {\n  width: 4px;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n.swiper-pagination-progress.swiper-pagination-white {\n  background: rgba(255, 255, 255, 0.5);\n}\n.swiper-pagination-progress.swiper-pagination-white .swiper-pagination-progressbar {\n  background: #fff;\n}\n.swiper-pagination-progress.swiper-pagination-black .swiper-pagination-progressbar {\n  background: #000;\n}\n/* 3D Container */\n.swiper-container-3d {\n  -webkit-perspective: 1200px;\n  -moz-perspective: 1200px;\n  -o-perspective: 1200px;\n  perspective: 1200px;\n}\n.swiper-container-3d .swiper-wrapper,\n.swiper-container-3d .swiper-slide,\n.swiper-container-3d .swiper-slide-shadow-left,\n.swiper-container-3d .swiper-slide-shadow-right,\n.swiper-container-3d .swiper-slide-shadow-top,\n.swiper-container-3d .swiper-slide-shadow-bottom,\n.swiper-container-3d .swiper-cube-shadow {\n  -webkit-transform-style: preserve-3d;\n  -moz-transform-style: preserve-3d;\n  -ms-transform-style: preserve-3d;\n  transform-style: preserve-3d;\n}\n.swiper-container-3d .swiper-slide-shadow-left,\n.swiper-container-3d .swiper-slide-shadow-right,\n.swiper-container-3d .swiper-slide-shadow-top,\n.swiper-container-3d .swiper-slide-shadow-bottom {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 10;\n}\n.swiper-container-3d .swiper-slide-shadow-left {\n  background-image: -webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));\n  /* Safari 4+, Chrome */\n  background-image: -webkit-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Chrome 10+, Safari 5.1+, iOS 5+ */\n  background-image: -moz-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Firefox 3.6-15 */\n  background-image: -o-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Opera 11.10-12.00 */\n  background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Firefox 16+, IE10, Opera 12.50+ */\n}\n.swiper-container-3d .swiper-slide-shadow-right {\n  background-image: -webkit-gradient(linear, right top, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));\n  /* Safari 4+, Chrome */\n  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Chrome 10+, Safari 5.1+, iOS 5+ */\n  background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Firefox 3.6-15 */\n  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Opera 11.10-12.00 */\n  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Firefox 16+, IE10, Opera 12.50+ */\n}\n.swiper-container-3d .swiper-slide-shadow-top {\n  background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));\n  /* Safari 4+, Chrome */\n  background-image: -webkit-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Chrome 10+, Safari 5.1+, iOS 5+ */\n  background-image: -moz-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Firefox 3.6-15 */\n  background-image: -o-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Opera 11.10-12.00 */\n  background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Firefox 16+, IE10, Opera 12.50+ */\n}\n.swiper-container-3d .swiper-slide-shadow-bottom {\n  background-image: -webkit-gradient(linear, left bottom, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));\n  /* Safari 4+, Chrome */\n  background-image: -webkit-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Chrome 10+, Safari 5.1+, iOS 5+ */\n  background-image: -moz-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Firefox 3.6-15 */\n  background-image: -o-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Opera 11.10-12.00 */\n  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n  /* Firefox 16+, IE10, Opera 12.50+ */\n}\n/* Coverflow */\n.swiper-container-coverflow .swiper-wrapper,\n.swiper-container-flip .swiper-wrapper {\n  /* Windows 8 IE 10 fix */\n  -ms-perspective: 1200px;\n}\n/* Cube + Flip */\n.swiper-container-cube,\n.swiper-container-flip {\n  overflow: visible;\n}\n.swiper-container-cube .swiper-slide,\n.swiper-container-flip .swiper-slide {\n  pointer-events: none;\n  -webkit-backface-visibility: hidden;\n  -moz-backface-visibility: hidden;\n  -ms-backface-visibility: hidden;\n  backface-visibility: hidden;\n  z-index: 1;\n}\n.swiper-container-cube .swiper-slide .swiper-slide,\n.swiper-container-flip .swiper-slide .swiper-slide {\n  pointer-events: none;\n}\n.swiper-container-cube .swiper-slide-active,\n.swiper-container-flip .swiper-slide-active,\n.swiper-container-cube .swiper-slide-active .swiper-slide-active,\n.swiper-container-flip .swiper-slide-active .swiper-slide-active {\n  pointer-events: auto;\n}\n.swiper-container-cube .swiper-slide-shadow-top,\n.swiper-container-flip .swiper-slide-shadow-top,\n.swiper-container-cube .swiper-slide-shadow-bottom,\n.swiper-container-flip .swiper-slide-shadow-bottom,\n.swiper-container-cube .swiper-slide-shadow-left,\n.swiper-container-flip .swiper-slide-shadow-left,\n.swiper-container-cube .swiper-slide-shadow-right,\n.swiper-container-flip .swiper-slide-shadow-right {\n  z-index: 0;\n  -webkit-backface-visibility: hidden;\n  -moz-backface-visibility: hidden;\n  -ms-backface-visibility: hidden;\n  backface-visibility: hidden;\n}\n/* Cube */\n.swiper-container-cube .swiper-slide {\n  visibility: hidden;\n  -webkit-transform-origin: 0 0;\n  -moz-transform-origin: 0 0;\n  -ms-transform-origin: 0 0;\n  transform-origin: 0 0;\n  width: 100%;\n  height: 100%;\n}\n.swiper-container-cube.swiper-container-rtl .swiper-slide {\n  -webkit-transform-origin: 100% 0;\n  -moz-transform-origin: 100% 0;\n  -ms-transform-origin: 100% 0;\n  transform-origin: 100% 0;\n}\n.swiper-container-cube .swiper-slide-active,\n.swiper-container-cube .swiper-slide-next,\n.swiper-container-cube .swiper-slide-prev,\n.swiper-container-cube .swiper-slide-next + .swiper-slide {\n  pointer-events: auto;\n  visibility: visible;\n}\n.swiper-container-cube .swiper-cube-shadow {\n  position: absolute;\n  left: 0;\n  bottom: 0px;\n  width: 100%;\n  height: 100%;\n  background: #000;\n  opacity: 0.6;\n  -webkit-filter: blur(50px);\n  filter: blur(50px);\n  z-index: 0;\n}\n/* Fade */\n.swiper-container-fade.swiper-container-free-mode .swiper-slide {\n  -webkit-transition-timing-function: ease-out;\n  -moz-transition-timing-function: ease-out;\n  -ms-transition-timing-function: ease-out;\n  -o-transition-timing-function: ease-out;\n  transition-timing-function: ease-out;\n}\n.swiper-container-fade .swiper-slide {\n  pointer-events: none;\n  -webkit-transition-property: opacity;\n  -moz-transition-property: opacity;\n  -o-transition-property: opacity;\n  transition-property: opacity;\n}\n.swiper-container-fade .swiper-slide .swiper-slide {\n  pointer-events: none;\n}\n.swiper-container-fade .swiper-slide-active,\n.swiper-container-fade .swiper-slide-active .swiper-slide-active {\n  pointer-events: auto;\n}\n.swiper-zoom-container {\n  width: 100%;\n  height: 100%;\n  display: -webkit-box;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-pack: center;\n  -moz-box-pack: center;\n  -ms-flex-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  -webkit-box-align: center;\n  -moz-box-align: center;\n  -ms-flex-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  text-align: center;\n}\n.swiper-zoom-container > img,\n.swiper-zoom-container > svg,\n.swiper-zoom-container > canvas {\n  max-width: 100%;\n  max-height: 100%;\n  object-fit: contain;\n}\n/* Scrollbar */\n.swiper-scrollbar {\n  border-radius: 10px;\n  position: relative;\n  -ms-touch-action: none;\n  background: rgba(0, 0, 0, 0.1);\n}\n.swiper-container-horizontal > .swiper-scrollbar {\n  position: absolute;\n  left: 1%;\n  bottom: 3px;\n  z-index: 50;\n  height: 5px;\n  width: 98%;\n}\n.swiper-container-vertical > .swiper-scrollbar {\n  position: absolute;\n  right: 3px;\n  top: 1%;\n  z-index: 50;\n  width: 5px;\n  height: 98%;\n}\n.swiper-scrollbar-drag {\n  height: 100%;\n  width: 100%;\n  position: relative;\n  background: rgba(0, 0, 0, 0.5);\n  border-radius: 10px;\n  left: 0;\n  top: 0;\n}\n.swiper-scrollbar-cursor-drag {\n  cursor: move;\n}\n/* Preloader */\n.swiper-lazy-preloader {\n  width: 42px;\n  height: 42px;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: -21px;\n  margin-top: -21px;\n  z-index: 10;\n  -webkit-transform-origin: 50%;\n  -moz-transform-origin: 50%;\n  transform-origin: 50%;\n  -webkit-animation: swiper-preloader-spin 1s steps(12, end) infinite;\n  -moz-animation: swiper-preloader-spin 1s steps(12, end) infinite;\n  animation: swiper-preloader-spin 1s steps(12, end) infinite;\n}\n.swiper-lazy-preloader:after {\n  display: block;\n  content: \"\";\n  width: 100%;\n  height: 100%;\n  background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20viewBox%3D'0%200%20120%20120'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20xmlns%3Axlink%3D'http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink'%3E%3Cdefs%3E%3Cline%20id%3D'l'%20x1%3D'60'%20x2%3D'60'%20y1%3D'7'%20y2%3D'27'%20stroke%3D'%236c6c6c'%20stroke-width%3D'11'%20stroke-linecap%3D'round'%2F%3E%3C%2Fdefs%3E%3Cg%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(30%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(60%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(90%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(120%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(150%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.37'%20transform%3D'rotate(180%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.46'%20transform%3D'rotate(210%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.56'%20transform%3D'rotate(240%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.66'%20transform%3D'rotate(270%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.75'%20transform%3D'rotate(300%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.85'%20transform%3D'rotate(330%2060%2C60)'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\");\n  background-position: 50%;\n  -webkit-background-size: 100%;\n  background-size: 100%;\n  background-repeat: no-repeat;\n}\n.swiper-lazy-preloader-white:after {\n  background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20viewBox%3D'0%200%20120%20120'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20xmlns%3Axlink%3D'http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink'%3E%3Cdefs%3E%3Cline%20id%3D'l'%20x1%3D'60'%20x2%3D'60'%20y1%3D'7'%20y2%3D'27'%20stroke%3D'%23fff'%20stroke-width%3D'11'%20stroke-linecap%3D'round'%2F%3E%3C%2Fdefs%3E%3Cg%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(30%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(60%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(90%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(120%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(150%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.37'%20transform%3D'rotate(180%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.46'%20transform%3D'rotate(210%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.56'%20transform%3D'rotate(240%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.66'%20transform%3D'rotate(270%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.75'%20transform%3D'rotate(300%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.85'%20transform%3D'rotate(330%2060%2C60)'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\");\n}\n@-webkit-keyframes swiper-preloader-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n  }\n}\n@keyframes swiper-preloader-spin {\n  100% {\n    transform: rotate(360deg);\n  }\n}\n", ""]);

// exports


/***/ }),
/* 45 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "swiper-container"
  }, [_vm._t("parallax-bg"), _vm._v(" "), _c('div', {
    class: _vm.defaultSwiperClasses.wrapperClass
  }, [_vm._t("default")], 2), _vm._v(" "), _vm._t("pagination"), _vm._v(" "), _vm._t("button-prev"), _vm._v(" "), _vm._t("button-next"), _vm._v(" "), _vm._t("scrollbar")], 2)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-d3a671a8", module.exports)
  }
}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(48),
  /* template */
  __webpack_require__(49),
  /* styles */
  null,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "D:\\newtest\\6.20\\bilibili-live\\node_modules\\_vue-awesome-swiper@2.5.4@vue-awesome-swiper\\slide.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] slide.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4806d42d", Component.options)
  } else {
    hotAPI.reload("data-v-4806d42d", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'swiper-slide',
  data() {
    return {
      slideClass: 'swiper-slide'
    };
  },
  ready() {
    this.update();
  },
  mounted() {
    this.update();
    if (this.$parent.options.slideClass) {
      this.slideClass = this.$parent.options.slideClass;
    }
  },
  updated() {
    this.update();
  },
  attached() {
    this.update();
  },
  methods: {
    update() {
      if (this.$parent && this.$parent.swiper && this.$parent.swiper.update) {
        this.$parent.swiper.update(true);
        if (this.$parent.options.loop) {
          this.$parent.swiper.reLoop();
        }
      }
    }
  }
});

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    class: _vm.slideClass
  }, [_vm._t("default")], 2)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-4806d42d", module.exports)
  }
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(51);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(14)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/_css-loader@0.28.4@css-loader/index.js!./index.css", function() {
			var newContent = require("!!../../node_modules/_css-loader@0.28.4@css-loader/index.js!./index.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)(undefined);
// imports


// module
exports.push([module.i, ".bili-app-link-container {\r\n    position: fixed;\r\n    left: 0;\r\n    bottom: 0;\r\n    width: 100%;\r\n    z-index: 1000;\r\n    box-shadow: 0 .026666666666667rem .053333333333333rem #ddd;\r\n    background-color: #de698c;\r\n    -webkit-transition: all .3s ease;\r\n    transition: all .3s ease;\r\n    -webkit-transform: translateZ(0);\r\n    transform: translateZ(0)\r\n}\r\n\r\n.bili-app-link-container.hide {\r\n    -webkit-transform: translate3d(0, 100%, 0);\r\n    transform: translate3d(0, 100%, 0)\r\n}\r\n\r\n.bili-app-link-container .bili-app-link {\r\n    display: -webkit-box;\r\n    display: -ms-flexbox;\r\n    display: flex;\r\n    -webkit-box-pack: justify;\r\n    -ms-flex-pack: justify;\r\n    justify-content: space-between;\r\n    -webkit-box-align: center;\r\n    -ms-flex-align: center;\r\n    align-items: center;\r\n    padding: 0 .053333333333333rem 0 .266666666666667rem\r\n}\r\n\r\n.bili-app-link-container .bili-app-link .logo {\r\n    width: .96rem;\r\n    height: .96rem;\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA25pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTExIDc5LjE1ODMyNSwgMjAxNS8wOS8xMC0wMToxMDoyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpjM2FmMjYzMS02NzYxLTMzNDgtOTg4NS0wMzdhY2RjZTE4MmQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OTk4RDI3NzMzNzdCMTFFNjg4NDdGQ0FGMjQ1NTNFMDMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OTk4RDI3NzIzNzdCMTFFNjg4NDdGQ0FGMjQ1NTNFMDMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDk4RTE2ODEzNzdCMTFFNkI2RUNGQjY0MDA4QUREMUIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDk4RTE2ODIzNzdCMTFFNkI2RUNGQjY0MDA4QUREMUIiLz4gPC9yZGY6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);\r\n    background-size: contain;\r\n    background-repeat: no-repeat;\r\n    border: 1px solid #fff;\r\n    border-radius: .213333333333333rem\r\n}\r\n\r\n.bili-app-link-container .bili-app-link .intro {\r\n    margin-right: .266666666666667rem;\r\n    margin-left: .266666666666667rem;\r\n    -webkit-box-flex: 1;\r\n    -ms-flex-positive: 1;\r\n    flex-grow: 1\r\n}\r\n\r\n.bili-app-link-container .bili-app-link .intro .first-line {\r\n    display: block;\r\n    font-size: .373333333333333rem;\r\n    height: .72rem;\r\n    line-height: .906666666666667rem;\r\n    overflow: hidden;\r\n    color: #fff\r\n}\r\n\r\n.bili-app-link-container .bili-app-link .intro .second-line {\r\n    white-space: nowrap;\r\n    display: block;\r\n    font-size: .293333333333333rem;\r\n    height: .72rem;\r\n    line-height: .533333333333333rem;\r\n    overflow: hidden;\r\n    color: #fff;\r\n    opacity: .7\r\n}\r\n\r\n.bili-app-link-container .bili-app-link .app-link-btn {\r\n    width: 1.6rem;\r\n    height: .853333333333333rem;\r\n    padding: .32rem 0;\r\n    text-align: center;\r\n    line-height: .24rem;\r\n    font-size: .346666666666667rem;\r\n    border-radius: .16rem;\r\n    color: #de689c\r\n}\r\n\r\n.bili-app-link-container .bili-app-link .close {\r\n    text-align: center;\r\n    border-radius: 60%;\r\n    border: 1px solid hsla(0, 0%, 100%, .5);\r\n    color: hsla(0, 0%, 100%, .5);\r\n    display: inline-block\r\n}\r\n\r\n[data-dpr=\"1\"] .bili-app-link-container .close {\r\n    font-size: 12px;\r\n    line-height: 12px;\r\n    width: 12px;\r\n    height: 12px;\r\n    padding: 1px;\r\n    margin: 0 1px 0 4px\r\n}\r\n\r\n[data-dpr=\"2\"] .bili-app-link-container .close {\r\n    font-size: 24px;\r\n    line-height: 24px;\r\n    width: 24px;\r\n    height: 24px;\r\n    padding: 2px;\r\n    margin: 0 2px 0 8px\r\n}\r\n\r\n[data-dpr=\"3\"] .bili-app-link-container .close {\r\n    font-size: 36px;\r\n    line-height: 36px;\r\n    width: 36px;\r\n    height: 36px;\r\n    padding: 3px;\r\n    margin: 0 3px 0 12px\r\n}\r\n\r\n.bili-btn {\r\n    height: 1.066666666666667rem;\r\n    box-sizing: border-box;\r\n    border-radius: .106666666666667rem;\r\n    outline: none;\r\n    font-size: .373333333333333rem;\r\n    font-family: Microsoft YaHei, Microsoft Sans Serif, Microsoft SanSerf, \\\\5FAE\\8F6F\\96C5\\9ED1;\r\n    line-height: 1.066666666666667rem;\r\n    text-align: center;\r\n    cursor: pointer;\r\n    -webkit-tap-highlight-color: transparent;\r\n    text-decoration: none\r\n}\r\n\r\n.bili-btn.default {\r\n    border: 0\r\n}\r\n\r\n.bili-btn.basic {\r\n    border: 1px solid #d3d3d3\r\n}\r\n\r\n.bili-btn.pink {\r\n    background-color: #fb7299;\r\n    color: #fff;\r\n    border-color: #fb7299!important\r\n}\r\n\r\n.bili-btn.pink:hover {\r\n    background-color: #fb80a3\r\n}\r\n\r\n.bili-btn.pink:active {\r\n    background-color: #fa4f7f\r\n}\r\n\r\n.bili-btn.blue {\r\n    background-color: #4fc1e9;\r\n    color: #fff\r\n}\r\n\r\n.bili-btn.blue:hover {\r\n    background-color: #61c7eb\r\n}\r\n\r\n.bili-btn.blue:active {\r\n    background-color: #33b7e6\r\n}\r\n\r\n.bili-btn.white {\r\n    background-color: #fff;\r\n    color: #fb7299\r\n}\r\n\r\n.bili-btn.white.active,\r\n.bili-btn.white.hover {\r\n    background-color: #e6e6e6\r\n}\r\n\r\n.logo-bar {\r\n    width: 100%;\r\n    height: 1.066666666666667rem;\r\n    font-size: .373333333333333rem;\r\n    line-height: 1.066666666666667rem;\r\n    color: #fb7299;\r\n    background-color: #fff;\r\n    border-style: solid;\r\n    border-width: 0 0 1px;\r\n    border-color: #e7e7e7;\r\n    position: absolute;\r\n    z-index: 10100\r\n}\r\n\r\n.logo-bar .logo {\r\n    display: block;\r\n    width: 1.68rem;\r\n    height: 100%;\r\n    margin-left: .48rem;\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGwAAAAwCAYAAAD0Kp9BAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFRTVDQzg2MTU4MDAxMUU0ODU0Q0I1NDVBQkVFRDA4MyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFRTVDQzg2MjU4MDAxMUU0ODU0Q0I1NDVBQkVFRDA4MyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkVFNUNDODVGNTgwMDExRTQ4NTRDQjU0NUFCRUVEMDgzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkVFNUNDODYwNTgwMDExRTQ4NTRDQjU0NUFCRUVEMDgzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+wNYPEAAAChhJREFUeNrcXGlsXcUV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);\r\n    background-position: 0 .16rem;\r\n    background-repeat: no-repeat;\r\n    -webkit-tap-highlight-color: transparent\r\n}\r\n\r\n.logo-bar .link {\r\n    width: 60%;\r\n    padding-right: .32rem\r\n}\r\n\r\n.logo-bar .link .area-info {\r\n    width: 100%;\r\n    float: right;\r\n    white-space: nowrap;\r\n    text-align: right;\r\n    text-overflow: ellipsis;\r\n    overflow: hidden\r\n}\r\n\r\n.hide-logobar .logo-bar {\r\n    display: none\r\n}\r\n\r\n.top-nav-ctnr {\r\n    overflow: hidden\r\n}\r\n\r\n.top-nav-ctnr .nav-bar {\r\n    display: -webkit-box;\r\n    display: -ms-flexbox;\r\n    display: flex;\r\n    padding: 0 .213333333333333rem;\r\n    margin: 0;\r\n    list-style: none;\r\n    -webkit-box-pack: justify;\r\n    -ms-flex-pack: justify;\r\n    justify-content: space-between;\r\n    background: #fff;\r\n    margin-top: 1.066666666666667rem\r\n}\r\n\r\n.top-nav-ctnr .nav-bar .nav-item {\r\n    display: block;\r\n    width: 1.6rem;\r\n    height: 1.066666666666667rem;\r\n    font-size: .426666666666667rem;\r\n    line-height: 1.066666666666667rem;\r\n    text-align: center;\r\n    box-sizing: border-box\r\n}\r\n\r\n.top-nav-ctnr .nav-bar .nav-item.on {\r\n    border-bottom: .106666666666667rem solid #fb7299\r\n}\r\n\r\n.top-nav-ctnr .nav-bar .nav-item a {\r\n    text-decoration: none;\r\n    color: #000\r\n}\r\n\r\n.room-list-container {\r\n    padding: 0 .333333333333333rem;\r\n    margin-bottom: .32rem;\r\n    background-color: #fff\r\n}\r\n\r\n.room-list-container:nth-last-child(2) {\r\n    margin-bottom: 0\r\n}\r\n\r\n.room-list-container .room-card {\r\n    width: 4.533333333333333rem\r\n}\r\n\r\n.room-list-container .room-card:nth-last-child(2) {\r\n    margin-bottom: 0\r\n}\r\n\r\n.room-list-container .title-ctnr {\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis\r\n}\r\n\r\n.room-list-container .title-ctnr .title-row {\r\n    padding: .333333333333333rem 0 .36rem;\r\n    font-size: .4rem;\r\n    height: .48rem;\r\n    line-height: .48rem;\r\n    color: #181818\r\n}\r\n\r\n.room-list-container .block-ctnr {\r\n    display: -webkit-box;\r\n    display: -ms-flexbox;\r\n    display: flex;\r\n    display: -webkit-flex;\r\n    -ms-flex-wrap: wrap;\r\n    flex-wrap: wrap;\r\n    -webkit-flex-wrap: wrap;\r\n    -webkit-box-pack: justify;\r\n    -ms-flex-pack: justify;\r\n    justify-content: space-between;\r\n    -webkit-justify-content: space-between\r\n}\r\n\r\n.room-card[_v-51f62538] {\r\n    margin-bottom: .266666666666667rem;\r\n    text-decoration: none;\r\n    color: #000;\r\n    display: inline-block;\r\n    vertical-align: top\r\n}\r\n\r\n.room-card[_v-51f62538]:nth-of-type(even) {\r\n    margin-left: .266666666666667rem\r\n}\r\n\r\n.room-card .cover-wrap[_v-51f62538] {\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEsAAABHCAYAAABPjLqRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NDM2RTI2RkY1RkMxMUUzODg4RUZDRjlGRDNDN0UwNSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NDM2RTI3MEY1RkMxMUUzODg4RUZDRjlGRDNDN0UwNSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg0MzZFMjZERjVGQzExRTM4ODhFRkNGOUZEM0M3RTA1IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg0MzZFMjZFRjVGQzExRTM4ODhFRkNGOUZEM0M3RTA1Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+HLC+wQAABbxJREFUeNrsnF1oHFUUx+9u06StlZo2kGpptYso+JWPSlMNoZGqL2L7IFgQURREsFoRQepDRQhSrKA+iFWfRMQvRDFo86AWP1prW9JNFGOLJmptraLU2qS2sU3W/3H+a252Z+ZOdnZndmfmwJ/s7p25u/eXe++cc++ZSeVyOaXbyMiI8mEroVegS6Fd0B1SpQrO6qEXoNuhUehR6KWZVJDJZBzL0mX8oVLXWwQl1gl9Bl0cIKi3obug2dBC6EXoinI2sFzWBF1Y8NkS6JMAgM2DPoButim7uhph/QH9ZPN5pYEJqPeh623KZI7ZV42wJqFboRMBAsuDus6h/H7om2qEJbYXujEgYCZQ90HPl7Nx6QoMiz0BAPMCalu5G5au0DxSSWChgKokrEoBCw1UpWGVG1iooMTqDOUpaAXUJc4tdG6J3/M91O4A7FPoQw91XOlQh9gvUAc1UxtllPE51E93wx6GQ7gjkG6DNmseeRzsINQDvYawJ+dlGIon3ge9GjNQiu2Vdveh0zS59iwcsJjzSNwgOfWybvSwX4tgAdRcrhS0JZz+t6wsCADYqcJhuDUBVWRt5DLVs9CrWvF6Pyf2xIqD8Xb0roG867B5BqBOQ+MRgNAAzfFwXIp8bkkNDw+fjxc/Q7M8OJgPQbsj1GuugZ7x4J9NQEtlzlrrAZQ4bKsjBkqxPavZPjcTPmsFVreHMXtPRIaenY2zfTnDcd0Cq8Vw0D76HFH3qUwrqi1pxnxuNhSTq56pnZk0rwpu9ldMYJna2ZBWiXm2BFYCK4EVutUF+F0LGJjKaufr0FGf9d0NHefKwA+1DGuxBkaCdFmaXq6VH1JWXoIfe0pZ+QxKg5blgkCWvtNEtcHKFIBpJyzT0ocfWMs0UGLnKWsjQ9/M+Bv6WoOX5fvxoGGth+4lmAUlnL/C5z+o3cMx81TxJsZZ6FtoO7QpKFhNynlLyou1BgDLqb2yS1RSzlipV8N+n41tVtY2WNCw8rY/yGEoY3+yBNj/QF9x/pjlo7GSJDeb0JqqHdZJ6AB0mcsxsnk5UHCFGuK84de2qqm18SWcA/MXF9FSw/nZoK+GWQ3W7wQywCEqf2UXOqcqb0eoXu2zhYTWpl2pL1HWEvFvPD5QWM9BbxDaEVVddgz6iMrbOex9i8Lws76ssWhFpo5dSWyYBNIJrARWAitcq0tgebP5ykp7mp/Amvpep3BHMu86+dfp3HRcYEnUvxN60qasG9rI1xuV/W75Ezz/8qjDWsewSBIyHiawepZJb3pH+01pvu/k+3oev4nnD7C+yE6kHzMAz9/W9gh0p7LW0DtUcdpTo7KSNiSDR5alm7WyA6wvsj1rTFl58YPaZwJglQbqDHvQGb5PsVwHNch6xqI+Zx3l0HpaWYlxuslaVxeHWhff63aa53Uq/7tDNePPnOSc9Th7jQy3gwU9ToZeCyXLK8cZvI/G1fmThpvurhgsgJg4pbUS7pg2IufGhIWpnRMC67DhoItiAsvUzsMCy5Tx1sUJOMrWyHa62VCaoYOpe/ZEHFaPh2G4U2D1eqhsAx3FORGD1MB2bfBwbG/+dhTxaVZ6OOFP6AtlPcOh1m0RnVsvU8zeTCbTkfeztkDvehzbN8XQa9ii+1nvQTsST8rWdpDPtPsNl3HZozHhM23aacUQPDTNg+cHsj50KmH0nwmHdXlQReEOCmTtaE0YEX2Vmdzqu4Y8XGPD3Yz0X1ZlzsmsAZtgu68CqKI74FKGJ7NJCCApkXKb2fICx018rmbDl0vCyNmAG3yBsnK33FY6jhUMN1mpledLvAlIPzqdmPLxGDt5iJfpTirJNz0RMCxJ/rjWpfwxt4ikUo+xG+TYdgwPQgAl1mco315qxX5gyRq5PP9l0qZM0qofCGneeVZZaZx2Js/T6g8DlqLXfwNDIJkcJcdcnr23ij5bGDbGOXabNjd9Bz2orCe1lWz/CjAAUaBevr2x6hQAAAAASUVORK5CYII=);\r\n    background-repeat: no-repeat;\r\n    background-position: 50%;\r\n    background-size: 2rem 1.893333333333333rem\r\n}\r\n\r\n.room-card .cover-wrap .cover[_v-51f62538] {\r\n    width: 4.533333333333333rem;\r\n    height: 2.8rem;\r\n    position: relative;\r\n    margin: 0 auto;\r\n    border-radius: 5px;\r\n    color: #fff;\r\n    overflow: hidden;\r\n    -webkit-transition: all .3s ease;\r\n    transition: all .3s ease\r\n}\r\n\r\n.room-card .cover-wrap .cover img[_v-51f62538] {\r\n    width: 100%;\r\n    height: 100%;\r\n    display: block;\r\n    overflow: hidden\r\n}\r\n\r\n.room-card .cover-wrap .cover[_v-51f62538]:before {\r\n    content: \"\";\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background-color: rgba(0, 0, 0, .2);\r\n    border-radius: 5px;\r\n    z-index: 100\r\n}\r\n\r\n.room-card .cover-wrap .cover .hostname[_v-51f62538] {\r\n    width: 2.933333333333333rem;\r\n    height: .32rem;\r\n    line-height: .32rem;\r\n    position: absolute;\r\n    left: 0;\r\n    bottom: 0;\r\n    font-size: .32rem;\r\n    margin: 0 0 .213333333333333rem .2rem;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    white-space: nowrap;\r\n    z-index: 110\r\n}\r\n\r\n.room-card .cover-wrap .cover .viewers-count[_v-51f62538] {\r\n    width: 1.28rem;\r\n    height: .266666666666667rem;\r\n    line-height: .266666666666667rem;\r\n    position: absolute;\r\n    right: 0;\r\n    bottom: 0;\r\n    font-size: .266666666666667rem;\r\n    margin-bottom: .213333333333333rem;\r\n    box-sizing: border-box;\r\n    z-index: 110\r\n}\r\n\r\n.room-card .title-container[_v-51f62538] {\r\n    font-size: .36rem;\r\n    margin: .186666666666667rem .133333333333333rem;\r\n    line-height: .426666666666667rem;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n    display: -webkit-box;\r\n    -webkit-line-clamp: 2;\r\n    -webkit-box-orient: vertical\r\n}\r\n\r\n.room-card .title-container .category[_v-51f62538] {\r\n    color: #fb7299\r\n}\r\n\r\n.eye.icon[_v-51f62538] {\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA4BpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpGNERFNUQ2QzI3RTAxMUU2QjU3MkM1OUY1NUM3QTA3QSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowOTk5Q0U5MDQ3RDcxMUU2QUY5MEM3QjY0OTgwNzk3NCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowOTk5Q0U4RjQ3RDcxMUU2QUY5MEM3QjY0OTgwNzk3NCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNSAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpkY2I4ZDBlZC1kNWI1LWVhNDctOTFlZC03MGMzNGE4MDRkZjYiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozYmU5MmU0OS0zOWVjLTExZTYtYmQ1OC1hYzAyMTgwNDYxZjUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6F7fS4AAABcUlEQVR42uyVP0sDQRDFcxYS9Tj8V6W2sDCNYBBMooWtTRpFC7XwU9ilEMl3UAQhh+Cfxm9g7VkF0ihoYRm9iJBCPd/CWziGuQ2IwcaBHwv3ZmYvu29yXpIkuUHEUG5A8SeNfbAOQvAAeiAGLXBGzc+sNmcsyIN90En6R4e5edlHNp0DrVThFzgFZTAGxsEquBIbmJpiVuMK6KaSP8CG8osse9zYxhtYlo0XwLt4izq1SXAEXsArOOEzozVEjemxaBtPgEeREAMfDINb5WwjagFz0/FkeprGh0rhJd9o23FxO8w5V7SGsduWYpZ7rmWHHStc24q2229AvB/OR880birCDNcbR7HVZhUtdF1ewAuKlDO8ozZCt6iXZygpdjugNg2OuVlMu01Rqyt2K8kBqdLkNj7piqwB2eQQpQekmjXSRWWkQ7BCX4+CJdAUU+cc6V/9E/IcX5AA1MAamAcFPn8GEbgGF6Cr+vT/02TjW4ABAMoHcwPh+6RRAAAAAElFTkSuQmCC);\r\n    background-position: 0 0;\r\n    background-repeat: no-repeat;\r\n    background-size: .266666666666667rem .24rem;\r\n    padding-left: .346666666666667rem\r\n}\r\n\r\n.app .load-cover {\r\n    display: block;\r\n    position: fixed;\r\n    height: 100%;\r\n    width: 100%;\r\n    top: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n    opacity: 1;\r\n    z-index: 10010;\r\n    visibility: visible;\r\n    background: #f8f8f8;\r\n    -webkit-transition: all .3s;\r\n    transition: all .3s\r\n}\r\n\r\n.app .load-cover .loading-txt {\r\n    position: absolute;\r\n    top: 50%;\r\n    text-align: center;\r\n    width: 100%;\r\n    height: .426666666666667rem;\r\n    line-height: .426666666666667rem;\r\n    margin-top: -.213333333333333rem;\r\n    color: #666;\r\n    font-size: .426666666666667rem\r\n}\r\n\r\n.app.loaded .load-cover {\r\n    visibility: hidden;\r\n    opacity: 0\r\n}\r\n\r\n#bili-footer {\r\n    position: absolute;\r\n    width: 100%;\r\n    display: none;\r\n    font-size: .373333333333333rem;\r\n    padding-top: .4rem;\r\n    padding-bottom: .266666666666667rem;\r\n    clear: both;\r\n    color: #aaa;\r\n    line-height: 1.48;\r\n    text-align: center;\r\n    background-color: #f8f8f8;\r\n    bottom: 0\r\n}\r\n\r\n#bili-footer p {\r\n    margin: .4rem 0\r\n}\r\n\r\n#bili-footer .footer-btn {\r\n    float: none;\r\n    display: inline-block;\r\n    width: 33%;\r\n    margin-bottom: .133333333333333rem;\r\n    text-decoration: none;\r\n    color: gray\r\n}\r\n\r\n#bili-footer .footer-btn span {\r\n    background-position: 0;\r\n    background-repeat: no-repeat;\r\n    padding: .133333333333333rem 0 .133333333333333rem .533333333333333rem\r\n}\r\n\r\n#bili-footer #link-to-app {\r\n    border-right: 1px solid #ddd\r\n}\r\n\r\n#bili-footer #link-to-app span {\r\n    background-size: .32rem;\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAeCAYAAAAhDE4sAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTExIDc5LjE1ODMyNSwgMjAxNS8wOS8xMC0wMToxMDoyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI4NUUxOEJFM0QxRTExRTY5NkU2ODE1NTMwMkI4NzAxIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI4NUUxOEJGM0QxRTExRTY5NkU2ODE1NTMwMkI4NzAxIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6Mjg1RTE4QkMzRDFFMTFFNjk2RTY4MTU1MzAyQjg3MDEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6Mjg1RTE4QkQzRDFFMTFFNjk2RTY4MTU1MzAyQjg3MDEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6iDw45AAAAp0lEQVR42mJctWoVGwMDQzcQxwCxEANp4D0QLwbiUhYg0QXEeQzkAUGo3u9MQCIWKrgdiKWAmJFILAXVAwKpTEjeSQbi5yS45jlUDwgIMaFJkArgepgYqARGDRo1aNSgUYNGDSLGIEky9EtgM2gOsgQRQBqI58I4LEgSXmTWJHAXvSOgxhaK8YF3TNC6mxD4T0B+DshrZdAqOBZal6ODw0Q0ImoBAgwAL50ZwRBcQCUAAAAASUVORK5CYII=)\r\n}\r\n\r\n#bili-footer #back-to-top span {\r\n    background-size: .426666666666667rem;\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAaCAYAAABCfffNAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTExIDc5LjE1ODMyNSwgMjAxNS8wOS8xMC0wMToxMDoyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjNFQzBCNUM2M0QxRTExRTZBMzg4OTE4NDY4ODlDQTU3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjNFQzBCNUM3M0QxRTExRTZBMzg4OTE4NDY4ODlDQTU3Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6M0VDMEI1QzQzRDFFMTFFNkEzODg5MTg0Njg4OUNBNTciIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6M0VDMEI1QzUzRDFFMTFFNkEzODg5MTg0Njg4OUNBNTciLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7IukFtAAABR0lEQVR42uzWv0sCYRzH8ccUioYSmmpqbasgIgStLSqopcUKor3GovYgGw2iqYIU7BZJEIVAraEI6cfWfxCO1iTSr/cDX+MQCu+6kyAfeHHwPMd97rnv8zycxzCMslKqW7nXnttUE5oPfrdDmjITKyH9uMUdBtwIGcQVhjGEa0w5GTKBC/Sa+vRqTGHdiZB5ZNCFtKl/F15EcIIOuyGrSKAdx5gzjW1gCRUsooA+KyEebCMq4ztYwWvdfTGM4wmjKGKkkRC9bw6xhXesYRMf37zkjTy4KDO5xMJPIZ1IYhlVhLHXQF31TIKIS21iMntvfUgPcpjBCyZxamEr1Gqja/Um1zNZMF8hWfmuJYSQt7m59aqb1YcipnFuDtmXnRzAwy9PEb3Ux3CPg1qhdTsSTrVHOR3+5gHZCmmF/NcQn9UfNTshnwIMAHMAOxY9yuPvAAAAAElFTkSuQmCC)\r\n}\r\n\r\n.black-wrap {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: fixed;\r\n    z-index: 10055;\r\n    background-color: rgba(0, 0, 0, .5);\r\n    left: 0;\r\n    top: 0;\r\n    display: table\r\n}\r\n\r\n.black-wrap .float-box-wrp {\r\n    display: table-cell;\r\n    position: relative;\r\n    text-align: center;\r\n    vertical-align: middle\r\n}\r\n\r\n.black-wrap .float-box {\r\n    margin: 0 auto;\r\n    background: #fff;\r\n    padding: .64rem .533333333333333rem;\r\n    width: 75%;\r\n    box-sizing: border-box;\r\n    border-radius: .133333333333333rem\r\n}\r\n\r\n.black-wrap .float-box .float-notice-title {\r\n    font-size: .426666666666667rem;\r\n    line-height: .8rem\r\n}\r\n\r\n.black-wrap .float-box .float-notice-content {\r\n    font-size: .341333333333333rem;\r\n    color: #999;\r\n    margin-bottom: .533333333333333rem\r\n}\r\n\r\n.black-wrap .float-box .float-notice-options {\r\n    padding: 0 1%\r\n}\r\n\r\n.black-wrap .float-box .float-notice-options .options-btn {\r\n    box-sizing: border-box;\r\n    width: 40%;\r\n    color: #333;\r\n    line-height: .96rem;\r\n    font-size: .341333333333333rem;\r\n    border-radius: .16rem;\r\n    display: inline-block;\r\n    margin: 0 3%;\r\n    border: 1px solid #ddd\r\n}\r\n\r\n.black-wrap .float-box .float-notice-options .options-btn.float-notice-download {\r\n    color: #fff;\r\n    border-color: #de698c;\r\n    background-color: #de698c;\r\n    text-decoration: none\r\n}\r\n\r\nhtml {\r\n    font-size: 12px;\r\n    -webkit-text-size-adjust: none\r\n}\r\n\r\nbody,\r\nhtml {\r\n    height: 100%\r\n}\r\n\r\nbody {\r\n    padding: 0;\r\n    margin: 0;\r\n    border: 0;\r\n    font-family: Microsoft YaHei, Microsoft Sans Serif, Microsoft SanSerf, \\\\5FAE\\8F6F\\96C5\\9ED1;\r\n    background: #f2f2f2;\r\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0)\r\n}\r\n\r\nimg {\r\n    border: 0;\r\n    outline: 0\r\n}\r\n\r\n.p-absolute {\r\n    position: absolute\r\n}\r\n\r\n.p-relative {\r\n    position: relative\r\n}\r\n\r\n.f-left {\r\n    float: left\r\n}\r\n\r\n.f-right {\r\n    float: right\r\n}\r\n\r\n.f-clear:after {\r\n    content: \"\";\r\n    display: block;\r\n    visibility: hidden;\r\n    clear: both\r\n}\r\n\r\n.v-top {\r\n    vertical-align: top\r\n}\r\n\r\n.v-middle {\r\n    vertical-align: middle\r\n}\r\n\r\n.v-bottom {\r\n    vertical-align: bottom\r\n}\r\n\r\n.dp-block {\r\n    display: block\r\n}\r\n\r\n.dp-i-block {\r\n    display: inline-block\r\n}\r\n\r\n.dp-table {\r\n    display: table\r\n}\r\n\r\n.dp-table-cell {\r\n    display: table-cell\r\n}\r\n\r\n.border-box {\r\n    box-sizing: border-box\r\n}\r\n\r\n.t-center {\r\n    text-align: center\r\n}\r\n\r\n.t-right {\r\n    text-align: right\r\n}\r\n\r\n.t-over-hidden {\r\n    overflow: hidden;\r\n    text-overflow: ellipsis\r\n}\r\n\r\n.t-nowrap {\r\n    white-space: nowrap\r\n}\r\n\r\n.bg-white {\r\n    background-color: #fff\r\n}\r\n\r\n.bg-center {\r\n    background-position: 50%;\r\n    background-repeat: no-repeat\r\n}\r\n\r\n.bg-cover {\r\n    background-size: cover\r\n}\r\n\r\n.bg-contain {\r\n    background-size: contain\r\n}\r\n\r\n.over-hidden {\r\n    overflow: hidden\r\n}\r\n\r\n.pointer {\r\n    cursor: pointer\r\n}\r\n\r\n.none-select {\r\n    -webkit-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n    user-select: none\r\n}\r\n\r\n.move-in-left {\r\n    -webkit-animation: move-in-left cubic-bezier(.22, .58, .12, .98) .4s;\r\n    animation: move-in-left cubic-bezier(.22, .58, .12, .98) .4s\r\n}\r\n\r\n.fade-in {\r\n    -webkit-animation: fade-in cubic-bezier(.22, .58, .12, .98) .4s;\r\n    animation: fade-in cubic-bezier(.22, .58, .12, .98) .4s\r\n}\r\n\r\n.bili-link {\r\n    text-decoration: none;\r\n    color: #fb7299\r\n}\r\n\r\n.bili-link:active {\r\n    color: #fff\r\n}\r\n\r\n.bili-link.cyan {\r\n    color: #4fc1e9\r\n}\r\n\r\n.bili-link.gray {\r\n    color: #646c7a\r\n}\r\n\r\n.bili-pink {\r\n    color: #fb7299\r\n}\r\n\r\n.app-ctnr {\r\n    min-height: 100%;\r\n    position: relative;\r\n    padding-bottom: 4rem;\r\n    box-sizing: border-box\r\n}\r\n\r\n@-webkit-keyframes move-in-left {\r\n    0% {\r\n        opacity: 0;\r\n        -webkit-transform: translate(5em);\r\n        transform: translate(5em)\r\n    }\r\n    to {\r\n        opacity: 1;\r\n        -webkit-transform: translate(0);\r\n        transform: translate(0)\r\n    }\r\n}\r\n\r\n@keyframes move-in-left {\r\n    0% {\r\n        opacity: 0;\r\n        -webkit-transform: translate(5em);\r\n        transform: translate(5em)\r\n    }\r\n    to {\r\n        opacity: 1;\r\n        -webkit-transform: translate(0);\r\n        transform: translate(0)\r\n    }\r\n}\r\n\r\n@-webkit-keyframes fade-in {\r\n    0% {\r\n        opacity: 0\r\n    }\r\n    to {\r\n        opacity: 1\r\n    }\r\n}\r\n\r\n@keyframes fade-in {\r\n    0% {\r\n        opacity: 0\r\n    }\r\n    to {\r\n        opacity: 1\r\n    }\r\n}\r\n\r\n.loading {\r\n    margin: 15px 10px\r\n}\r\n\r\n.live-main {\r\n    background-color: #f4f4f4\r\n}\r\n\r\n.live-main .banner-wrap {\r\n    width: 100%;\r\n    height: 3.125rem\r\n}\r\n\r\n.live-main .rooms .link {\r\n    text-decoration: none;\r\n    color: #000\r\n}\r\n\r\n.live-main .rooms .live-class-icon {\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTExIDc5LjE1ODMyNSwgMjAxNS8wOS8xMC0wMToxMDoyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkQ1MzRCMzhDMjYzQzExRTY5QTEwQTgxQUEyRTA5Nzc4IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkQ1MzRCMzhEMjYzQzExRTY5QTEwQTgxQUEyRTA5Nzc4Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RDUzNEIzOEEyNjNDMTFFNjlBMTBBODFBQTJFMDk3NzgiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RDUzNEIzOEIyNjNDMTFFNjlBMTBBODFBQTJFMDk3NzgiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5RNcGDAAAEnUlEQVR42uxYW0xUVxTdd2ZgmIcSQcRXREbQmEZrjDE+IlGrJZqoMRo1xmo/bKrx25j008R+2dj+qNFaMfrnI7ZNbPWjRBM1Kj5QjPhsjBGLUlBBYIBhujZnUy/DPfcxAw0f3cliAtxzZt199l57n20kk0kayuajIW6Bnp/fnE93fREwVVAIZMmefCydwBvgDnAX+MvTzt+Wmwh6swJgEbAcmAJMAMbaPP8SeApcBX6WT48edGc5wE5gCzDJw7pxgjJgF/ArsA+oHMgYXCZHtdsjOStbAfwBHABGZOLBaUALsAr4bhASahswS07knYTOHTcEs4EjwDrTwsEyJngR+CBhUAHsADrsjngNsEmIFvwHSjJS1ICdtRVY6RSDzL7b89cYBlEXlr1tQ2B0KKEx0iLc7UTwisSeN3LxLmwNVnPhjGLEfktckfRmnNlnnGLwK2C4p20TeOl2ENw4g2geZLETvx++RlQNbS6IKOLuJYkzu0nnwWLROg/e41RqJ5oxRpFjy8K266fjNYMI/w4vu02WJNEe8WYg6vpYGeytALZZWtL3//nwXFmMqBUVz298fN7ZNgARK4JRyWB7bzE6EyrG3sNzz3EapUjEIgvNnQ+PBhFFL95J8sRVItkT/QRYaEVwjvxTU3MMdVyNbYolx9b4XKJPcbTlpdZr8sJES+DZErxALF+tSSAeGz6ol/Rpic6xSpIF2mrB+zC5McNVlo7H5yh8WQjNi9+hwKycqsDG8lPXTPSgHi3DcwhaQoVHf5uXStAPlGu/hCUkC498MRN9y7D0JTkK7Z+cr8Avdq6WKDfH6shjqUfMBHNtg4+lYiC7bz5qfSyGUgmGzH/sZ0G/0rmTNSprM7XqV6jAz5Cr2TqSYSsP6jsbdhxr2oPXRD9VqQBP13iPI9iju1uFjUMb6DPVv4SjxOTBydV1RN9fVtLh1a4gMQ7fUHtFg3Yh055KsE1Atl40RDpqkIUnbqnkcWuPcD05fluVxWFBp/IXTyUYlwuOO+PYYQQ89LB+HGcYa7L9bpKt3kqoq9w1Q5LNE/OcNdBsLE+FEbfxe8mK4I9AsyuCnHl5IW/xx6KeH1alzlmtKq0I3gdOuWqtON8LNYJdCfmo0VyBR0bcyNQ94IKuH+Sb1pe2vTB7L2n0r6NPGrDtY6VxYSTBbLR2C2OqPJq972z7zQmbShAaQIeAr/X3QJ+Kvd8eEi0GgThi6hbu5vehb+2dKsvZSxf/VA0r94kzQbahleh2ndJTe+9V9PFHz/Co7+gjKqOKYlsvtsQ/HjnHfSRLtVa9AcYfXH24H+zJXKlIOQGdJ1mz5v6brDajD76PrAV+197q+KVYZhLS23FDmqT+8hEKKHSZntMf81YrJdHpBFSYVgMN9trmU7GYtBH3pIvniLYDx7yOPi5Lj1hFg2dN4oiD6c5m0LDRZ8BeoHWAyZ2WxvRspsOj93LT45HbUeDvTLpAEeG1gtqBHL9dF8RkQrVI7jAlDuuaZR1L2C+DOR/sNZQK+kFQKARHy3SVye8xPdsIfA7czGwEnL7VmzuP3v5b5om9lelmJl9g/D/lz9D+EWAArtNHEC0BYOcAAAAASUVORK5CYII=);\r\n    background-position: 0;\r\n    background-repeat: no-repeat;\r\n    background-size: contain;\r\n    padding-left: .64rem\r\n}\r\n\r\n.live-main .rooms .right-arrow.icon {\r\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTExIDc5LjE1ODMyNSwgMjAxNS8wOS8xMC0wMToxMDoyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjkyRTUxRjYyM0MxNTExRTY4RjJFQ0YzNTlFRTFBMTdFIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjkyRTUxRjYzM0MxNTExRTY4RjJFQ0YzNTlFRTFBMTdFIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTJFNTFGNjAzQzE1MTFFNjhGMkVDRjM1OUVFMUExN0UiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTJFNTFGNjEzQzE1MTFFNjhGMkVDRjM1OUVFMUExN0UiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7c7GU4AAACjklEQVR42syYz0tUURTH31x/bVKhf0A0CEUXkRtDRaysTNcpSVsRHHVTpqBoUpCCUCkibkPRoF2OOKULf6CLUTcpZq2yf6CmFur443vgvOn5mHHufffO4IEPjvLueR/nvnPfPdcXCoUsxcgH90EFKAR5IAcI8Af8BLtgFQTBnkrydMnr0kAD8IMy4Itz3VXmBmjkv22AN2AaRBLdSEjI3AFfwSS4dYFMvCgF78E2uKsjlAVGwBeeGt24Dj5zzixVoVwe7LfMh59z58oK0YULoNJKXlDuxVhSbqFM8InnPdlxE8y6p88t9JbLWSaoxJfAkYZUOXgXT4iqqUUhGa1FVVw5fzWkmvne54RonRlVTLTPP+lbegj+aUiNskNU6JGH0p7hFZpiGdRqSBXywhsV8nuc/wDINiTVagsV8Ars9aGcMyRFDtcEP5w+zUoxIUUO9wQn1A1TUuXC0HvKlFSR4P2MdUmk8oRjsEmpgL2usBStUycSY68IyT2RanwEx47fayXvI+iisGGZp7xDtKMTdEmODQvHK8BEdINhl8ygwvhfJLRjSKYXvNaQodgR3B3oxgvwUlOGYoWE5jVlXoF+AzIUQRL6AdY9JhgCPYZkyOG7XYojHhLQ7vK5IRl7TxRdGz5wt6kSfY7PzzRlvvH+KioU8bAnegwyuLqGDLRGEfeemlqfcYUkY+AQDGjKTHAzGrPr6KDSs1IXtOS0X9QG0X9cDzZTILMF6sBBos71N7jNb+lkBeWu5ntJ9fZ0YY2H1ki2vGtiySQ6/aCvso0bwV0DInss0uaeJtXzIaq+EtAE1sCpoggdWD0Bxc5qiheyJ2i02Zpi6EjvgXX+SC/b+n+kt88LHT0nykd6ZwIMAD99jKUhR5YjAAAAAElFTkSuQmCC);\r\n    background-position: 100%;\r\n    background-repeat: no-repeat;\r\n    background-size: contain;\r\n    padding-right: .666666666666667rem;\r\n    color: #919799;\r\n    font-size: .346666666666667rem\r\n}\r\n\r\n.live-main .main-bottom {\r\n    height: 1.066666666666667rem;\r\n    padding: 15px 10px\r\n}\r\n\r\n.live-main .main-bottom div {\r\n    display: inline-block;\r\n    width: 50%\r\n}\r\n\r\n.live-main .main-bottom div a {\r\n    width: 90%;\r\n    display: block;\r\n    margin: 0 5%\r\n}\r\n\r\n.banner {\r\n    background: #f4f4f4;\r\n    padding-bottom: .266666666666667rem\r\n}\r\n\r\n.banner img {\r\n    display: block\r\n}\r\n\r\n.banner.swipe {\r\n    visibility: hidden;\r\n    -webkit-backface-visibility: hidden;\r\n    backface-visibility: hidden;\r\n    -webkit-transform-style: preserve-3d;\r\n    transform-style: preserve-3d\r\n}\r\n\r\n.banner.swipe,\r\n.banner.swipe .swipe-wrap {\r\n    overflow: hidden;\r\n    position: relative\r\n}\r\n\r\n.banner.swipe .swipe-wrap a {\r\n    float: left;\r\n    width: 100%;\r\n    position: relative\r\n}\r\n\r\n.banner.swipe .indicators {\r\n    position: absolute;\r\n    right: 0;\r\n    bottom: .266666666666667rem\r\n}\r\n\r\n.banner.swipe .indicators a {\r\n    display: inline-block;\r\n    background-color: #fff\r\n}\r\n\r\n.banner.swipe .indicators a.selected {\r\n    background-color: #fb7299\r\n}\r\n\r\n[data-dpr=\"1\"] .banner .indicators {\r\n    padding: 5px\r\n}\r\n\r\n[data-dpr=\"1\"] .banner .indicators a {\r\n    width: 6px;\r\n    height: 6px;\r\n    border-radius: 5px;\r\n    margin: 2px!important\r\n}\r\n\r\n[data-dpr=\"2\"] .banner .indicators {\r\n    padding: 10px\r\n}\r\n\r\n[data-dpr=\"2\"] .banner .indicators a {\r\n    width: 12px;\r\n    height: 12px;\r\n    border-radius: 10px;\r\n    margin: 4px!important\r\n}\r\n\r\n[data-dpr=\"3\"] .banner .indicators {\r\n    padding: 15px\r\n}\r\n\r\n[data-dpr=\"3\"] .banner .indicators a {\r\n    width: 18px;\r\n    height: 18px;\r\n    border-radius: 15px;\r\n    margin: 6px!important\r\n}\r\n", ""]);

// exports


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;!function (e) {
  if (true) module.exports = e();else if ("function" == typeof define && define.amd) define([], e);else {
    var t;t = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, t.flvjs = e();
  }
}(function () {
  var e;return function e(t, n, i) {
    function r(a, o) {
      if (!n[a]) {
        if (!t[a]) {
          var u = "function" == typeof require && require;if (!o && u) return require(a, !0);if (s) return s(a, !0);var l = new Error("Cannot find module '" + a + "'");throw l.code = "MODULE_NOT_FOUND", l;
        }var d = n[a] = { exports: {} };t[a][0].call(d.exports, function (e) {
          var n = t[a][1][e];return r(n || e);
        }, d, d.exports, e, t, n, i);
      }return n[a].exports;
    }for (var s = "function" == typeof require && require, a = 0; a < i.length; a++) r(i[a]);return r;
  }({ 1: [function (t, n, i) {
      (function (r, s) {
        !function (t, r) {
          "object" == typeof i && void 0 !== n ? n.exports = r() : "function" == typeof e && e.amd ? e(r) : t.ES6Promise = r();
        }(this, function () {
          "use strict";
          function e(e) {
            var t = typeof e;return null !== e && ("object" === t || "function" === t);
          }function n(e) {
            return "function" == typeof e;
          }function i(e) {
            K = e;
          }function a(e) {
            q = e;
          }function o() {
            return void 0 !== H ? function () {
              H(l);
            } : u();
          }function u() {
            var e = setTimeout;return function () {
              return e(l, 1);
            };
          }function l() {
            for (var e = 0; e < z; e += 2) {
              (0, J[e])(J[e + 1]), J[e] = void 0, J[e + 1] = void 0;
            }z = 0;
          }function d(e, t) {
            var n = arguments,
                i = this,
                r = new this.constructor(f);void 0 === r[ee] && I(r);var s = i._state;return s ? function () {
              var e = n[s - 1];q(function () {
                return O(s, r, e, i._result);
              });
            }() : L(i, r, e, t), r;
          }function h(e) {
            var t = this;if (e && "object" == typeof e && e.constructor === t) return e;var n = new t(f);return E(n, e), n;
          }function f() {}function c() {
            return new TypeError("You cannot resolve a promise with itself");
          }function _() {
            return new TypeError("A promises callback cannot return that same promise.");
          }function m(e) {
            try {
              return e.then;
            } catch (e) {
              return re.error = e, re;
            }
          }function p(e, t, n, i) {
            try {
              e.call(t, n, i);
            } catch (e) {
              return e;
            }
          }function v(e, t, n) {
            q(function (e) {
              var i = !1,
                  r = p(n, t, function (n) {
                i || (i = !0, t !== n ? E(e, n) : S(e, n));
              }, function (t) {
                i || (i = !0, k(e, t));
              }, "Settle: " + (e._label || " unknown promise"));!i && r && (i = !0, k(e, r));
            }, e);
          }function g(e, t) {
            t._state === ne ? S(e, t._result) : t._state === ie ? k(e, t._result) : L(t, void 0, function (t) {
              return E(e, t);
            }, function (t) {
              return k(e, t);
            });
          }function y(e, t, i) {
            t.constructor === e.constructor && i === d && t.constructor.resolve === h ? g(e, t) : i === re ? (k(e, re.error), re.error = null) : void 0 === i ? S(e, t) : n(i) ? v(e, t, i) : S(e, t);
          }function E(t, n) {
            t === n ? k(t, c()) : e(n) ? y(t, n, m(n)) : S(t, n);
          }function b(e) {
            e._onerror && e._onerror(e._result), w(e);
          }function S(e, t) {
            e._state === te && (e._result = t, e._state = ne, 0 !== e._subscribers.length && q(w, e));
          }function k(e, t) {
            e._state === te && (e._state = ie, e._result = t, q(b, e));
          }function L(e, t, n, i) {
            var r = e._subscribers,
                s = r.length;e._onerror = null, r[s] = t, r[s + ne] = n, r[s + ie] = i, 0 === s && e._state && q(w, e);
          }function w(e) {
            var t = e._subscribers,
                n = e._state;if (0 !== t.length) {
              for (var i = void 0, r = void 0, s = e._result, a = 0; a < t.length; a += 3) i = t[a], r = t[a + n], i ? O(n, i, r, s) : r(s);e._subscribers.length = 0;
            }
          }function R() {
            this.error = null;
          }function A(e, t) {
            try {
              return e(t);
            } catch (e) {
              return se.error = e, se;
            }
          }function O(e, t, i, r) {
            var s = n(i),
                a = void 0,
                o = void 0,
                u = void 0,
                l = void 0;if (s) {
              if (a = A(i, r), a === se ? (l = !0, o = a.error, a.error = null) : u = !0, t === a) return void k(t, _());
            } else a = r, u = !0;t._state !== te || (s && u ? E(t, a) : l ? k(t, o) : e === ne ? S(t, a) : e === ie && k(t, a));
          }function T(e, t) {
            try {
              t(function (t) {
                E(e, t);
              }, function (t) {
                k(e, t);
              });
            } catch (t) {
              k(e, t);
            }
          }function C() {
            return ae++;
          }function I(e) {
            e[ee] = ae++, e._state = void 0, e._result = void 0, e._subscribers = [];
          }function x(e, t) {
            this._instanceConstructor = e, this.promise = new e(f), this.promise[ee] || I(this.promise), V(t) ? (this.length = t.length, this._remaining = t.length, this._result = new Array(this.length), 0 === this.length ? S(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(t), 0 === this._remaining && S(this.promise, this._result))) : k(this.promise, M());
          }function M() {
            return new Error("Array Methods must be provided an Array");
          }function D(e) {
            return new x(this, e).promise;
          }function B(e) {
            var t = this;return new t(V(e) ? function (n, i) {
              for (var r = e.length, s = 0; s < r; s++) t.resolve(e[s]).then(n, i);
            } : function (e, t) {
              return t(new TypeError("You must pass an array to race."));
            });
          }function j(e) {
            var t = this,
                n = new t(f);return k(n, e), n;
          }function P() {
            throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
          }function U() {
            throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
          }function N(e) {
            this[ee] = C(), this._result = this._state = void 0, this._subscribers = [], f !== e && ("function" != typeof e && P(), this instanceof N ? T(this, e) : U());
          }function F() {
            var e = void 0;if (void 0 !== s) e = s;else if ("undefined" != typeof self) e = self;else try {
              e = Function("return this")();
            } catch (e) {
              throw new Error("polyfill failed because global object is unavailable in this environment");
            }var t = e.Promise;if (t) {
              var n = null;try {
                n = Object.prototype.toString.call(t.resolve());
              } catch (e) {}if ("[object Promise]" === n && !t.cast) return;
            }e.Promise = N;
          }var G = void 0;G = Array.isArray ? Array.isArray : function (e) {
            return "[object Array]" === Object.prototype.toString.call(e);
          };var V = G,
              z = 0,
              H = void 0,
              K = void 0,
              q = function (e, t) {
            J[z] = e, J[z + 1] = t, 2 === (z += 2) && (K ? K(l) : $());
          },
              W = "undefined" != typeof window ? window : void 0,
              X = W || {},
              Y = X.MutationObserver || X.WebKitMutationObserver,
              Z = "undefined" == typeof self && void 0 !== r && "[object process]" === {}.toString.call(r),
              Q = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel,
              J = new Array(1e3),
              $ = void 0;$ = Z ? function () {
            return function () {
              return r.nextTick(l);
            };
          }() : Y ? function () {
            var e = 0,
                t = new Y(l),
                n = document.createTextNode("");return t.observe(n, { characterData: !0 }), function () {
              n.data = e = ++e % 2;
            };
          }() : Q ? function () {
            var e = new MessageChannel();return e.port1.onmessage = l, function () {
              return e.port2.postMessage(0);
            };
          }() : void 0 === W && "function" == typeof t ? function () {
            try {
              var e = t,
                  n = e("vertx");return H = n.runOnLoop || n.runOnContext, o();
            } catch (e) {
              return u();
            }
          }() : u();var ee = Math.random().toString(36).substring(16),
              te = void 0,
              ne = 1,
              ie = 2,
              re = new R(),
              se = new R(),
              ae = 0;return x.prototype._enumerate = function (e) {
            for (var t = 0; this._state === te && t < e.length; t++) this._eachEntry(e[t], t);
          }, x.prototype._eachEntry = function (e, t) {
            var n = this._instanceConstructor,
                i = n.resolve;if (i === h) {
              var r = m(e);if (r === d && e._state !== te) this._settledAt(e._state, t, e._result);else if ("function" != typeof r) this._remaining--, this._result[t] = e;else if (n === N) {
                var s = new n(f);y(s, e, r), this._willSettleAt(s, t);
              } else this._willSettleAt(new n(function (t) {
                return t(e);
              }), t);
            } else this._willSettleAt(i(e), t);
          }, x.prototype._settledAt = function (e, t, n) {
            var i = this.promise;i._state === te && (this._remaining--, e === ie ? k(i, n) : this._result[t] = n), 0 === this._remaining && S(i, this._result);
          }, x.prototype._willSettleAt = function (e, t) {
            var n = this;L(e, void 0, function (e) {
              return n._settledAt(ne, t, e);
            }, function (e) {
              return n._settledAt(ie, t, e);
            });
          }, N.all = D, N.race = B, N.resolve = h, N.reject = j, N._setScheduler = i, N._setAsap = a, N._asap = q, N.prototype = { constructor: N, then: d, catch: function (e) {
              return this.then(null, e);
            } }, N.polyfill = F, N.Promise = N, N;
        });
      }).call(this, t("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, { _process: 3 }], 2: [function (e, t, n) {
      function i() {
        this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
      }function r(e) {
        return "function" == typeof e;
      }function s(e) {
        return "number" == typeof e;
      }function a(e) {
        return "object" == typeof e && null !== e;
      }function o(e) {
        return void 0 === e;
      }t.exports = i, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._maxListeners = void 0, i.defaultMaxListeners = 10, i.prototype.setMaxListeners = function (e) {
        if (!s(e) || e < 0 || isNaN(e)) throw TypeError("n must be a positive number");return this._maxListeners = e, this;
      }, i.prototype.emit = function (e) {
        var t, n, i, s, u, l;if (this._events || (this._events = {}), "error" === e && (!this._events.error || a(this._events.error) && !this._events.error.length)) {
          if ((t = arguments[1]) instanceof Error) throw t;var d = new Error('Uncaught, unspecified "error" event. (' + t + ")");throw d.context = t, d;
        }if (n = this._events[e], o(n)) return !1;if (r(n)) switch (arguments.length) {case 1:
            n.call(this);break;case 2:
            n.call(this, arguments[1]);break;case 3:
            n.call(this, arguments[1], arguments[2]);break;default:
            s = Array.prototype.slice.call(arguments, 1), n.apply(this, s);} else if (a(n)) for (s = Array.prototype.slice.call(arguments, 1), l = n.slice(), i = l.length, u = 0; u < i; u++) l[u].apply(this, s);return !0;
      }, i.prototype.addListener = function (e, t) {
        var n;if (!r(t)) throw TypeError("listener must be a function");return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", e, r(t.listener) ? t.listener : t), this._events[e] ? a(this._events[e]) ? this._events[e].push(t) : this._events[e] = [this._events[e], t] : this._events[e] = t, a(this._events[e]) && !this._events[e].warned && (n = o(this._maxListeners) ? i.defaultMaxListeners : this._maxListeners) && n > 0 && this._events[e].length > n && (this._events[e].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[e].length), "function" == typeof console.trace && console.trace()), this;
      }, i.prototype.on = i.prototype.addListener, i.prototype.once = function (e, t) {
        function n() {
          this.removeListener(e, n), i || (i = !0, t.apply(this, arguments));
        }if (!r(t)) throw TypeError("listener must be a function");var i = !1;return n.listener = t, this.on(e, n), this;
      }, i.prototype.removeListener = function (e, t) {
        var n, i, s, o;if (!r(t)) throw TypeError("listener must be a function");if (!this._events || !this._events[e]) return this;if (n = this._events[e], s = n.length, i = -1, n === t || r(n.listener) && n.listener === t) delete this._events[e], this._events.removeListener && this.emit("removeListener", e, t);else if (a(n)) {
          for (o = s; o-- > 0;) if (n[o] === t || n[o].listener && n[o].listener === t) {
            i = o;break;
          }if (i < 0) return this;1 === n.length ? (n.length = 0, delete this._events[e]) : n.splice(i, 1), this._events.removeListener && this.emit("removeListener", e, t);
        }return this;
      }, i.prototype.removeAllListeners = function (e) {
        var t, n;if (!this._events) return this;if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[e] && delete this._events[e], this;if (0 === arguments.length) {
          for (t in this._events) "removeListener" !== t && this.removeAllListeners(t);return this.removeAllListeners("removeListener"), this._events = {}, this;
        }if (n = this._events[e], r(n)) this.removeListener(e, n);else if (n) for (; n.length;) this.removeListener(e, n[n.length - 1]);return delete this._events[e], this;
      }, i.prototype.listeners = function (e) {
        return this._events && this._events[e] ? r(this._events[e]) ? [this._events[e]] : this._events[e].slice() : [];
      }, i.prototype.listenerCount = function (e) {
        if (this._events) {
          var t = this._events[e];if (r(t)) return 1;if (t) return t.length;
        }return 0;
      }, i.listenerCount = function (e, t) {
        return e.listenerCount(t);
      };
    }, {}], 3: [function (e, t, n) {
      function i() {
        throw new Error("setTimeout has not been defined");
      }function r() {
        throw new Error("clearTimeout has not been defined");
      }function s(e) {
        if (h === setTimeout) return setTimeout(e, 0);if ((h === i || !h) && setTimeout) return h = setTimeout, setTimeout(e, 0);try {
          return h(e, 0);
        } catch (t) {
          try {
            return h.call(null, e, 0);
          } catch (t) {
            return h.call(this, e, 0);
          }
        }
      }function a(e) {
        if (f === clearTimeout) return clearTimeout(e);if ((f === r || !f) && clearTimeout) return f = clearTimeout, clearTimeout(e);try {
          return f(e);
        } catch (t) {
          try {
            return f.call(null, e);
          } catch (t) {
            return f.call(this, e);
          }
        }
      }function o() {
        p && _ && (p = !1, _.length ? m = _.concat(m) : v = -1, m.length && u());
      }function u() {
        if (!p) {
          var e = s(o);p = !0;for (var t = m.length; t;) {
            for (_ = m, m = []; ++v < t;) _ && _[v].run();v = -1, t = m.length;
          }_ = null, p = !1, a(e);
        }
      }function l(e, t) {
        this.fun = e, this.array = t;
      }function d() {}var h,
          f,
          c = t.exports = {};!function () {
        try {
          h = "function" == typeof setTimeout ? setTimeout : i;
        } catch (e) {
          h = i;
        }try {
          f = "function" == typeof clearTimeout ? clearTimeout : r;
        } catch (e) {
          f = r;
        }
      }();var _,
          m = [],
          p = !1,
          v = -1;c.nextTick = function (e) {
        var t = new Array(arguments.length - 1);if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];m.push(new l(e, t)), 1 !== m.length || p || s(u);
      }, l.prototype.run = function () {
        this.fun.apply(null, this.array);
      }, c.title = "browser", c.browser = !0, c.env = {}, c.argv = [], c.version = "", c.versions = {}, c.on = d, c.addListener = d, c.once = d, c.off = d, c.removeListener = d, c.removeAllListeners = d, c.emit = d, c.prependListener = d, c.prependOnceListener = d, c.listeners = function (e) {
        return [];
      }, c.binding = function (e) {
        throw new Error("process.binding is not supported");
      }, c.cwd = function () {
        return "/";
      }, c.chdir = function (e) {
        throw new Error("process.chdir is not supported");
      }, c.umask = function () {
        return 0;
      };
    }, {}], 4: [function (e, t, n) {
      var i = arguments[3],
          r = arguments[4],
          s = arguments[5],
          a = JSON.stringify;t.exports = function (e, t) {
        function n(e) {
          p[e] = !0;for (var t in r[e][1]) {
            var i = r[e][1][t];p[i] || n(i);
          }
        }for (var o, u = Object.keys(s), l = 0, d = u.length; l < d; l++) {
          var h = u[l],
              f = s[h].exports;if (f === e || f && f.default === e) {
            o = h;break;
          }
        }if (!o) {
          o = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);for (var c = {}, l = 0, d = u.length; l < d; l++) {
            var h = u[l];c[h] = h;
          }r[o] = [Function(["require", "module", "exports"], "(" + e + ")(self)"), c];
        }var _ = Math.floor(Math.pow(16, 8) * Math.random()).toString(16),
            m = {};m[o] = o, r[_] = [Function(["require"], "var f = require(" + a(o) + ");(f.default ? f.default : f)(self);"), m];var p = {};n(_);var v = "(" + i + ")({" + Object.keys(p).map(function (e) {
          return a(e) + ":[" + r[e][0] + "," + a(r[e][1]) + "]";
        }).join(",") + "},{},[" + a(_) + "])",
            g = window.URL || window.webkitURL || window.mozURL || window.msURL,
            y = new Blob([v], { type: "text/javascript" });if (t && t.bare) return y;var E = g.createObjectURL(y),
            b = new Worker(E);return b.objectURL = E, b;
      };
    }, {}], 5: [function (e, t, n) {
      "use strict";
      function i() {
        return Object.assign({}, r);
      }Object.defineProperty(n, "__esModule", { value: !0 }), n.createDefaultConfig = i;var r = n.defaultConfig = { enableWorker: !1, enableStashBuffer: !0, stashInitialSize: void 0, isLive: !1, lazyLoad: !0, lazyLoadMaxDuration: 180, lazyLoadRecoverDuration: 30, deferLoadAfterSourceOpen: !0, autoCleanupMaxBackwardDuration: 180, autoCleanupMinBackwardDuration: 120, statisticsInfoReportInterval: 600, fixAudioTimestampGap: !0, accurateSeek: !1, seekType: "range", seekParamStart: "bstart", seekParamEnd: "bend", rangeLoadZeroStart: !1, customSeekHandler: void 0, reuseRedirectedURL: !1 };
    }, {}], 6: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = e("../io/io-controller.js"),
          a = function (e) {
        return e && e.__esModule ? e : { default: e };
      }(s),
          o = e("../config.js"),
          u = function () {
        function e() {
          i(this, e);
        }return r(e, null, [{ key: "supportMSEH264Playback", value: function () {
            return window.MediaSource && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
          } }, { key: "supportNetworkStreamIO", value: function () {
            var e = new a.default({}, (0, o.createDefaultConfig)()),
                t = e.loaderType;return e.destroy(), "fetch-stream-loader" == t || "xhr-moz-chunked-loader" == t;
          } }, { key: "getNetworkLoaderTypeName", value: function () {
            var e = new a.default({}, (0, o.createDefaultConfig)()),
                t = e.loaderType;return e.destroy(), t;
          } }, { key: "supportNativeMediaPlayback", value: function (t) {
            void 0 == e.videoElement && (e.videoElement = window.document.createElement("video"));var n = e.videoElement.canPlayType(t);return "probably" === n || "maybe" == n;
          } }, { key: "getFeatureList", value: function () {
            var t = { mseFlvPlayback: !1, mseLiveFlvPlayback: !1, networkStreamIO: !1, networkLoaderName: "", nativeMP4H264Playback: !1, nativeWebmVP8Playback: !1, nativeWebmVP9Playback: !1 };return t.mseFlvPlayback = e.supportMSEH264Playback(), t.networkStreamIO = e.supportNetworkStreamIO(), t.networkLoaderName = e.getNetworkLoaderTypeName(), t.mseLiveFlvPlayback = t.mseFlvPlayback && t.networkStreamIO, t.nativeMP4H264Playback = e.supportNativeMediaPlayback('video/mp4; codecs="avc1.42001E, mp4a.40.2"'), t.nativeWebmVP8Playback = e.supportNativeMediaPlayback('video/webm; codecs="vp8.0, vorbis"'), t.nativeWebmVP9Playback = e.supportNativeMediaPlayback('video/webm; codecs="vp9"'), t;
          } }]), e;
      }();n.default = u;
    }, { "../config.js": 5, "../io/io-controller.js": 23 }], 7: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = function () {
        function e() {
          i(this, e), this.mimeType = null, this.duration = null, this.hasAudio = null, this.hasVideo = null, this.audioCodec = null, this.videoCodec = null, this.audioDataRate = null, this.videoDataRate = null, this.audioSampleRate = null, this.audioChannelCount = null, this.width = null, this.height = null, this.fps = null, this.profile = null, this.level = null, this.chromaFormat = null, this.sarNum = null, this.sarDen = null, this.metadata = null, this.segments = null, this.segmentCount = null, this.hasKeyframesIndex = null, this.keyframesIndex = null;
        }return r(e, [{ key: "isComplete", value: function () {
            var e = !1 === this.hasAudio || !0 === this.hasAudio && null != this.audioCodec && null != this.audioSampleRate && null != this.audioChannelCount,
                t = !1 === this.hasVideo || !0 === this.hasVideo && null != this.videoCodec && null != this.width && null != this.height && null != this.fps && null != this.profile && null != this.level && null != this.chromaFormat && null != this.sarNum && null != this.sarDen;return null != this.mimeType && null != this.duration && null != this.metadata && null != this.hasKeyframesIndex && e && t;
          } }, { key: "isSeekable", value: function () {
            return !0 === this.hasKeyframesIndex;
          } }, { key: "getNearestKeyframe", value: function (e) {
            if (null == this.keyframesIndex) return null;var t = this.keyframesIndex,
                n = this._search(t.times, e);return { index: n, milliseconds: t.times[n], fileposition: t.filepositions[n] };
          } }, { key: "_search", value: function (e, t) {
            var n = 0,
                i = e.length - 1,
                r = 0,
                s = 0,
                a = i;for (t < e[0] && (n = 0, s = a + 1); s <= a;) {
              if ((r = s + Math.floor((a - s) / 2)) === i || t >= e[r] && t < e[r + 1]) {
                n = r;break;
              }e[r] < t ? s = r + 1 : a = r - 1;
            }return n;
          } }]), e;
      }();n.default = s;
    }, {}], 8: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }();n.SampleInfo = function e(t, n, r, s, a) {
        i(this, e), this.dts = t, this.pts = n, this.duration = r, this.originalDts = s, this.isSyncPoint = a, this.fileposition = null;
      }, n.MediaSegmentInfo = function () {
        function e() {
          i(this, e), this.beginDts = 0, this.endDts = 0, this.beginPts = 0, this.endPts = 0, this.originalBeginDts = 0, this.originalEndDts = 0, this.syncPoints = [], this.firstSample = null, this.lastSample = null;
        }return r(e, [{ key: "appendSyncPoint", value: function (e) {
            e.isSyncPoint = !0, this.syncPoints.push(e);
          } }]), e;
      }(), n.IDRSampleList = function () {
        function e() {
          i(this, e), this._list = [];
        }return r(e, [{ key: "clear", value: function () {
            this._list = [];
          } }, { key: "appendArray", value: function (e) {
            var t = this._list;0 !== e.length && (t.length > 0 && e[0].originalDts < t[t.length - 1].originalDts && this.clear(), Array.prototype.push.apply(t, e));
          } }, { key: "getLastSyncPointBeforeDts", value: function (e) {
            if (0 == this._list.length) return null;var t = this._list,
                n = 0,
                i = t.length - 1,
                r = 0,
                s = 0,
                a = i;for (e < t[0].dts && (n = 0, s = a + 1); s <= a;) {
              if ((r = s + Math.floor((a - s) / 2)) === i || e >= t[r].dts && e < t[r + 1].dts) {
                n = r;break;
              }t[r].dts < e ? s = r + 1 : a = r - 1;
            }return this._list[n];
          } }]), e;
      }(), n.MediaSegmentInfoList = function () {
        function e(t) {
          i(this, e), this._type = t, this._list = [], this._lastAppendLocation = -1;
        }return r(e, [{ key: "isEmpty", value: function () {
            return 0 === this._list.length;
          } }, { key: "clear", value: function () {
            this._list = [], this._lastAppendLocation = -1;
          } }, { key: "_searchNearestSegmentBefore", value: function (e) {
            var t = this._list;if (0 === t.length) return -2;var n = t.length - 1,
                i = 0,
                r = 0,
                s = n,
                a = 0;if (e < t[0].originalBeginDts) return a = -1;for (; r <= s;) {
              if ((i = r + Math.floor((s - r) / 2)) === n || e > t[i].lastSample.originalDts && e < t[i + 1].originalBeginDts) {
                a = i;break;
              }t[i].originalBeginDts < e ? r = i + 1 : s = i - 1;
            }return a;
          } }, { key: "_searchNearestSegmentAfter", value: function (e) {
            return this._searchNearestSegmentBefore(e) + 1;
          } }, { key: "append", value: function (e) {
            var t = this._list,
                n = e,
                i = this._lastAppendLocation,
                r = 0;-1 !== i && i < t.length && n.originalBeginDts >= t[i].lastSample.originalDts && (i === t.length - 1 || i < t.length - 1 && n.originalBeginDts < t[i + 1].originalBeginDts) ? r = i + 1 : t.length > 0 && (r = this._searchNearestSegmentBefore(n.originalBeginDts) + 1), this._lastAppendLocation = r, this._list.splice(r, 0, n);
          } }, { key: "getLastSegmentBefore", value: function (e) {
            var t = this._searchNearestSegmentBefore(e);return t >= 0 ? this._list[t] : null;
          } }, { key: "getLastSampleBefore", value: function (e) {
            var t = this.getLastSegmentBefore(e);return null != t ? t.lastSample : null;
          } }, { key: "getLastSyncPointBefore", value: function (e) {
            for (var t = this._searchNearestSegmentBefore(e), n = this._list[t].syncPoints; 0 === n.length && t > 0;) t--, n = this._list[t].syncPoints;return n.length > 0 ? n[n.length - 1] : null;
          } }, { key: "type", get: function () {
            return this._type;
          } }, { key: "length", get: function () {
            return this._list.length;
          } }]), e;
      }();
    }, {}], 9: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var s = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          a = e("events"),
          o = i(a),
          u = e("../utils/logger.js"),
          l = i(u),
          d = e("../utils/browser.js"),
          h = i(d),
          f = e("./mse-events.js"),
          c = i(f),
          _ = e("./media-segment-info.js"),
          m = e("../utils/exception.js"),
          p = function () {
        function e(t) {
          r(this, e), this.TAG = "MSEController", this._config = t, this._emitter = new o.default(), this._config.isLive && void 0 == this._config.autoCleanupSourceBuffer && (this._config.autoCleanupSourceBuffer = !0), this.e = { onSourceOpen: this._onSourceOpen.bind(this), onSourceEnded: this._onSourceEnded.bind(this), onSourceClose: this._onSourceClose.bind(this), onSourceBufferError: this._onSourceBufferError.bind(this), onSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this) }, this._mediaSource = null, this._mediaSourceObjectURL = null, this._mediaElement = null, this._isBufferFull = !1, this._hasPendingEos = !1, this._requireSetMediaDuration = !1, this._pendingMediaDuration = 0, this._pendingSourceBufferInit = [], this._mimeTypes = { video: null, audio: null }, this._sourceBuffers = { video: null, audio: null }, this._lastInitSegments = { video: null, audio: null }, this._pendingSegments = { video: [], audio: [] }, this._pendingRemoveRanges = { video: [], audio: [] }, this._idrList = new _.IDRSampleList();
        }return s(e, [{ key: "destroy", value: function () {
            (this._mediaElement || this._mediaSource) && this.detachMediaElement(), this.e = null, this._emitter.removeAllListeners(), this._emitter = null;
          } }, { key: "on", value: function (e, t) {
            this._emitter.addListener(e, t);
          } }, { key: "off", value: function (e, t) {
            this._emitter.removeListener(e, t);
          } }, { key: "attachMediaElement", value: function (e) {
            if (this._mediaSource) throw new m.IllegalStateException("MediaSource has been attached to an HTMLMediaElement!");var t = this._mediaSource = new window.MediaSource();t.addEventListener("sourceopen", this.e.onSourceOpen), t.addEventListener("sourceended", this.e.onSourceEnded), t.addEventListener("sourceclose", this.e.onSourceClose), this._mediaElement = e, this._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource), e.src = this._mediaSourceObjectURL;
          } }, { key: "detachMediaElement", value: function () {
            if (this._mediaSource) {
              var e = this._mediaSource;for (var t in this._sourceBuffers) {
                var n = this._pendingSegments[t];n.splice(0, n.length), this._pendingSegments[t] = null, this._pendingRemoveRanges[t] = null, this._lastInitSegments[t] = null;var i = this._sourceBuffers[t];i && ("closed" !== e.readyState && (e.removeSourceBuffer(i), i.removeEventListener("error", this.e.onSourceBufferError), i.removeEventListener("updateend", this.e.onSourceBufferUpdateEnd)), this._mimeTypes[t] = null, this._sourceBuffers[t] = null);
              }if ("open" === e.readyState) try {
                e.endOfStream();
              } catch (e) {
                l.default.e(this.TAG, e.message);
              }e.removeEventListener("sourceopen", this.e.onSourceOpen), e.removeEventListener("sourceended", this.e.onSourceEnded), e.removeEventListener("sourceclose", this.e.onSourceClose), this._pendingSourceBufferInit = [], this._isBufferFull = !1, this._idrList.clear(), this._mediaSource = null;
            }this._mediaElement && (this._mediaElement.src = "", this._mediaElement.removeAttribute("src"), this._mediaElement = null), this._mediaSourceObjectURL && (window.URL.revokeObjectURL(this._mediaSourceObjectURL), this._mediaSourceObjectURL = null);
          } }, { key: "appendInitSegment", value: function (e, t) {
            if (!this._mediaSource || "open" !== this._mediaSource.readyState) return this._pendingSourceBufferInit.push(e), void this._pendingSegments[e.type].push(e);var n = e,
                i = "" + n.container;n.codec && n.codec.length > 0 && (i += ";codecs=" + n.codec);var r = !1;if (l.default.v(this.TAG, "Received Initialization Segment, mimeType: " + i), this._lastInitSegments[n.type] = n, i !== this._mimeTypes[n.type]) {
              if (this._mimeTypes[n.type]) l.default.v(this.TAG, "Notice: " + n.type + " mimeType changed, origin: " + this._mimeTypes[n.type] + ", target: " + i);else {
                r = !0;try {
                  var s = this._sourceBuffers[n.type] = this._mediaSource.addSourceBuffer(i);s.addEventListener("error", this.e.onSourceBufferError), s.addEventListener("updateend", this.e.onSourceBufferUpdateEnd);
                } catch (e) {
                  return l.default.e(this.TAG, e.message), void this._emitter.emit(c.default.ERROR, { code: e.code, msg: e.message });
                }
              }this._mimeTypes[n.type] = i;
            }t || this._pendingSegments[n.type].push(n), r || this._sourceBuffers[n.type] && !this._sourceBuffers[n.type].updating && this._doAppendSegments(), h.default.safari && "audio/mpeg" === n.container && n.mediaDuration > 0 && (this._requireSetMediaDuration = !0, this._pendingMediaDuration = n.mediaDuration / 1e3, this._updateMediaSourceDuration());
          } }, { key: "appendMediaSegment", value: function (e) {
            var t = e;this._pendingSegments[t.type].push(t), this._config.autoCleanupSourceBuffer && this._needCleanupSourceBuffer() && this._doCleanupSourceBuffer();var n = this._sourceBuffers[t.type];!n || n.updating || this._hasPendingRemoveRanges() || this._doAppendSegments();
          } }, { key: "seek", value: function (e) {
            for (var t in this._sourceBuffers) if (this._sourceBuffers[t]) {
              var n = this._sourceBuffers[t];if ("open" === this._mediaSource.readyState) try {
                n.abort();
              } catch (e) {
                l.default.e(this.TAG, e.message);
              }this._idrList.clear();var i = this._pendingSegments[t];if (i.splice(0, i.length), "closed" !== this._mediaSource.readyState) {
                for (var r = 0; r < n.buffered.length; r++) {
                  var s = n.buffered.start(r),
                      a = n.buffered.end(r);this._pendingRemoveRanges[t].push({ start: s, end: a });
                }if (n.updating || this._doRemoveRanges(), h.default.safari) {
                  var o = this._lastInitSegments[t];o && (this._pendingSegments[t].push(o), n.updating || this._doAppendSegments());
                }
              }
            }
          } }, { key: "endOfStream", value: function () {
            var e = this._mediaSource,
                t = this._sourceBuffers;if (!e || "open" !== e.readyState) return void (e && "closed" === e.readyState && this._hasPendingSegments() && (this._hasPendingEos = !0));t.video && t.video.updating || t.audio && t.audio.updating ? this._hasPendingEos = !0 : (this._hasPendingEos = !1, e.endOfStream());
          } }, { key: "getNearestKeyframe", value: function (e) {
            return this._idrList.getLastSyncPointBeforeDts(e);
          } }, { key: "_needCleanupSourceBuffer", value: function () {
            if (!this._config.autoCleanupSourceBuffer) return !1;var e = this._mediaElement.currentTime;for (var t in this._sourceBuffers) {
              var n = this._sourceBuffers[t];if (n) {
                var i = n.buffered;if (i.length >= 1 && e - i.start(0) >= this._config.autoCleanupMaxBackwardDuration) return !0;
              }
            }return !1;
          } }, { key: "_doCleanupSourceBuffer", value: function () {
            var e = this._mediaElement.currentTime;for (var t in this._sourceBuffers) {
              var n = this._sourceBuffers[t];if (n) {
                for (var i = n.buffered, r = !1, s = 0; s < i.length; s++) {
                  var a = i.start(s),
                      o = i.end(s);if (a <= e && e < o + 3) {
                    if (e - a >= this._config.autoCleanupMaxBackwardDuration) {
                      r = !0;var u = e - this._config.autoCleanupMinBackwardDuration;this._pendingRemoveRanges[t].push({ start: a, end: u });
                    }
                  } else o < e && (r = !0, this._pendingRemoveRanges[t].push({ start: a, end: o }));
                }r && !n.updating && this._doRemoveRanges();
              }
            }
          } }, { key: "_updateMediaSourceDuration", value: function () {
            var e = this._sourceBuffers;if (0 !== this._mediaElement.readyState && "open" === this._mediaSource.readyState && !(e.video && e.video.updating || e.audio && e.audio.updating)) {
              var t = this._mediaSource.duration,
                  n = this._pendingMediaDuration;n > 0 && (isNaN(t) || n > t) && (l.default.v(this.TAG, "Update MediaSource duration from " + t + " to " + n), this._mediaSource.duration = n), this._requireSetMediaDuration = !1, this._pendingMediaDuration = 0;
            }
          } }, { key: "_doRemoveRanges", value: function () {
            for (var e in this._pendingRemoveRanges) if (this._sourceBuffers[e] && !this._sourceBuffers[e].updating) for (var t = this._sourceBuffers[e], n = this._pendingRemoveRanges[e]; n.length && !t.updating;) {
              var i = n.shift();t.remove(i.start, i.end);
            }
          } }, { key: "_doAppendSegments", value: function () {
            var e = this._pendingSegments;for (var t in e) if (this._sourceBuffers[t] && !this._sourceBuffers[t].updating && e[t].length > 0) {
              var n = e[t].shift();if (n.timestampOffset) {
                var i = this._sourceBuffers[t].timestampOffset,
                    r = n.timestampOffset / 1e3,
                    s = Math.abs(i - r);s > .1 && (l.default.v(this.TAG, "Update MPEG audio timestampOffset from " + i + " to " + r), this._sourceBuffers[t].timestampOffset = r), delete n.timestampOffset;
              }if (!n.data || 0 === n.data.byteLength) continue;try {
                this._sourceBuffers[t].appendBuffer(n.data), this._isBufferFull = !1, "video" === t && n.hasOwnProperty("info") && this._idrList.appendArray(n.info.syncPoints);
              } catch (e) {
                this._pendingSegments[t].unshift(n), 22 === e.code ? (this._isBufferFull || this._emitter.emit(c.default.BUFFER_FULL), this._isBufferFull = !0) : (l.default.e(this.TAG, e.message), this._emitter.emit(c.default.ERROR, { code: e.code, msg: e.message }));
              }
            }
          } }, { key: "_onSourceOpen", value: function () {
            if (l.default.v(this.TAG, "MediaSource onSourceOpen"), this._mediaSource.removeEventListener("sourceopen", this.e.onSourceOpen), this._pendingSourceBufferInit.length > 0) for (var e = this._pendingSourceBufferInit; e.length;) {
              var t = e.shift();this.appendInitSegment(t, !0);
            }this._hasPendingSegments() && this._doAppendSegments(), this._emitter.emit(c.default.SOURCE_OPEN);
          } }, { key: "_onSourceEnded", value: function () {
            l.default.v(this.TAG, "MediaSource onSourceEnded");
          } }, { key: "_onSourceClose", value: function () {
            l.default.v(this.TAG, "MediaSource onSourceClose"), this._mediaSource && null != this.e && (this._mediaSource.removeEventListener("sourceopen", this.e.onSourceOpen), this._mediaSource.removeEventListener("sourceended", this.e.onSourceEnded), this._mediaSource.removeEventListener("sourceclose", this.e.onSourceClose));
          } }, { key: "_hasPendingSegments", value: function () {
            var e = this._pendingSegments;return e.video.length > 0 || e.audio.length > 0;
          } }, { key: "_hasPendingRemoveRanges", value: function () {
            var e = this._pendingRemoveRanges;return e.video.length > 0 || e.audio.length > 0;
          } }, { key: "_onSourceBufferUpdateEnd", value: function () {
            this._requireSetMediaDuration ? this._updateMediaSourceDuration() : this._hasPendingRemoveRanges() ? this._doRemoveRanges() : this._hasPendingSegments() ? this._doAppendSegments() : this._hasPendingEos && this.endOfStream(), this._emitter.emit(c.default.UPDATE_END);
          } }, { key: "_onSourceBufferError", value: function (e) {
            l.default.e(this.TAG, "SourceBuffer Error: " + e);
          } }]), e;
      }();n.default = p;
    }, { "../utils/browser.js": 39, "../utils/exception.js": 40, "../utils/logger.js": 41, "./media-segment-info.js": 8, "./mse-events.js": 10, events: 2 }], 10: [function (e, t, n) {
      "use strict";
      Object.defineProperty(n, "__esModule", { value: !0 });var i = { ERROR: "error", SOURCE_OPEN: "source_open", UPDATE_END: "update_end", BUFFER_FULL: "buffer_full" };n.default = i;
    }, {}], 11: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var s = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          a = e("events"),
          o = i(a),
          u = e("../utils/logger.js"),
          l = i(u),
          d = e("../utils/logging-control.js"),
          h = i(d),
          f = e("./transmuxing-controller.js"),
          c = i(f),
          _ = e("./transmuxing-events.js"),
          m = i(_),
          p = e("./transmuxing-worker.js"),
          v = i(p),
          g = e("./media-info.js"),
          y = i(g),
          E = function () {
        function t(n, i) {
          if (r(this, t), this.TAG = "Transmuxer", this._emitter = new o.default(), i.enableWorker && "undefined" != typeof Worker) try {
            var s = e("webworkify");this._worker = s(v.default), this._workerDestroying = !1, this._worker.addEventListener("message", this._onWorkerMessage.bind(this)), this._worker.postMessage({ cmd: "init", param: [n, i] }), this.e = { onLoggingConfigChanged: this._onLoggingConfigChanged.bind(this) }, h.default.registerListener(this.e.onLoggingConfigChanged), this._worker.postMessage({ cmd: "logging_config", param: h.default.getConfig() });
          } catch (e) {
            l.default.e(this.TAG, "Error while initialize transmuxing worker, fallback to inline transmuxing"), this._worker = null, this._controller = new c.default(n, i);
          } else this._controller = new c.default(n, i);if (this._controller) {
            var a = this._controller;a.on(m.default.IO_ERROR, this._onIOError.bind(this)), a.on(m.default.DEMUX_ERROR, this._onDemuxError.bind(this)), a.on(m.default.INIT_SEGMENT, this._onInitSegment.bind(this)), a.on(m.default.MEDIA_SEGMENT, this._onMediaSegment.bind(this)), a.on(m.default.LOADING_COMPLETE, this._onLoadingComplete.bind(this)), a.on(m.default.RECOVERED_EARLY_EOF, this._onRecoveredEarlyEof.bind(this)), a.on(m.default.MEDIA_INFO, this._onMediaInfo.bind(this)), a.on(m.default.STATISTICS_INFO, this._onStatisticsInfo.bind(this)), a.on(m.default.RECOMMEND_SEEKPOINT, this._onRecommendSeekpoint.bind(this));
          }
        }return s(t, [{ key: "destroy", value: function () {
            this._worker ? this._workerDestroying || (this._workerDestroying = !0, this._worker.postMessage({ cmd: "destroy" }), h.default.removeListener(this.e.onLoggingConfigChanged), this.e = null) : (this._controller.destroy(), this._controller = null), this._emitter.removeAllListeners(), this._emitter = null;
          } }, { key: "on", value: function (e, t) {
            this._emitter.addListener(e, t);
          } }, { key: "off", value: function (e, t) {
            this._emitter.removeListener(e, t);
          } }, { key: "hasWorker", value: function () {
            return null != this._worker;
          } }, { key: "open", value: function () {
            this._worker ? this._worker.postMessage({ cmd: "start" }) : this._controller.start();
          } }, { key: "close", value: function () {
            this._worker ? this._worker.postMessage({ cmd: "stop" }) : this._controller.stop();
          } }, { key: "seek", value: function (e) {
            this._worker ? this._worker.postMessage({ cmd: "seek", param: e }) : this._controller.seek(e);
          } }, { key: "pause", value: function () {
            this._worker ? this._worker.postMessage({ cmd: "pause" }) : this._controller.pause();
          } }, { key: "resume", value: function () {
            this._worker ? this._worker.postMessage({ cmd: "resume" }) : this._controller.resume();
          } }, { key: "_onInitSegment", value: function (e, t) {
            var n = this;Promise.resolve().then(function () {
              n._emitter.emit(m.default.INIT_SEGMENT, e, t);
            });
          } }, { key: "_onMediaSegment", value: function (e, t) {
            var n = this;Promise.resolve().then(function () {
              n._emitter.emit(m.default.MEDIA_SEGMENT, e, t);
            });
          } }, { key: "_onLoadingComplete", value: function () {
            var e = this;Promise.resolve().then(function () {
              e._emitter.emit(m.default.LOADING_COMPLETE);
            });
          } }, { key: "_onRecoveredEarlyEof", value: function () {
            var e = this;Promise.resolve().then(function () {
              e._emitter.emit(m.default.RECOVERED_EARLY_EOF);
            });
          } }, { key: "_onMediaInfo", value: function (e) {
            var t = this;Promise.resolve().then(function () {
              t._emitter.emit(m.default.MEDIA_INFO, e);
            });
          } }, { key: "_onStatisticsInfo", value: function (e) {
            var t = this;Promise.resolve().then(function () {
              t._emitter.emit(m.default.STATISTICS_INFO, e);
            });
          } }, { key: "_onIOError", value: function (e, t) {
            var n = this;Promise.resolve().then(function () {
              n._emitter.emit(m.default.IO_ERROR, e, t);
            });
          } }, { key: "_onDemuxError", value: function (e, t) {
            var n = this;Promise.resolve().then(function () {
              n._emitter.emit(m.default.DEMUX_ERROR, e, t);
            });
          } }, { key: "_onRecommendSeekpoint", value: function (e) {
            var t = this;Promise.resolve().then(function () {
              t._emitter.emit(m.default.RECOMMEND_SEEKPOINT, e);
            });
          } }, { key: "_onLoggingConfigChanged", value: function (e) {
            this._worker && this._worker.postMessage({ cmd: "logging_config", param: e });
          } }, { key: "_onWorkerMessage", value: function (e) {
            var t = e.data,
                n = t.data;if ("destroyed" === t.msg || this._workerDestroying) return this._workerDestroying = !1, this._worker.terminate(), void (this._worker = null);switch (t.msg) {case m.default.INIT_SEGMENT:case m.default.MEDIA_SEGMENT:
                this._emitter.emit(t.msg, n.type, n.data);break;case m.default.LOADING_COMPLETE:case m.default.RECOVERED_EARLY_EOF:
                this._emitter.emit(t.msg);break;case m.default.MEDIA_INFO:
                Object.setPrototypeOf(n, y.default.prototype), this._emitter.emit(t.msg, n);break;case m.default.STATISTICS_INFO:
                this._emitter.emit(t.msg, n);break;case m.default.IO_ERROR:case m.default.DEMUX_ERROR:
                this._emitter.emit(t.msg, n.type, n.info);break;case m.default.RECOMMEND_SEEKPOINT:
                this._emitter.emit(t.msg, n);break;case "logcat_callback":
                l.default.emitter.emit("log", n.type, n.logcat);}
          } }]), t;
      }();n.default = E;
    }, { "../utils/logger.js": 41, "../utils/logging-control.js": 42, "./media-info.js": 7, "./transmuxing-controller.js": 12, "./transmuxing-events.js": 13, "./transmuxing-worker.js": 14, events: 2, webworkify: 4 }], 12: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var s = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          a = e("events"),
          o = i(a),
          u = e("../utils/logger.js"),
          l = i(u),
          d = e("../utils/browser.js"),
          h = i(d),
          f = e("./media-info.js"),
          c = i(f),
          _ = e("../demux/flv-demuxer.js"),
          m = i(_),
          p = e("../remux/mp4-remuxer.js"),
          v = i(p),
          g = e("../demux/demux-errors.js"),
          y = i(g),
          E = e("../io/io-controller.js"),
          b = i(E),
          S = e("./transmuxing-events.js"),
          k = i(S),
          L = (e("../io/loader.js"), function () {
        function e(t, n) {
          r(this, e), this.TAG = "TransmuxingController", this._emitter = new o.default(), this._config = n, t.segments || (t.segments = [{ duration: t.duration, filesize: t.filesize, url: t.url }]), "boolean" != typeof t.cors && (t.cors = !0), "boolean" != typeof t.withCredentials && (t.withCredentials = !1), this._mediaDataSource = t, this._currentSegmentIndex = 0;var i = 0;this._mediaDataSource.segments.forEach(function (e) {
            e.timestampBase = i, i += e.duration, e.cors = t.cors, e.withCredentials = t.withCredentials, n.referrerPolicy && (e.referrerPolicy = n.referrerPolicy);
          }), isNaN(i) || this._mediaDataSource.duration === i || (this._mediaDataSource.duration = i), this._mediaInfo = null, this._demuxer = null, this._remuxer = null, this._ioctl = null, this._pendingSeekTime = null, this._pendingResolveSeekPoint = null, this._statisticsReporter = null;
        }return s(e, [{ key: "destroy", value: function () {
            this._mediaInfo = null, this._mediaDataSource = null, this._statisticsReporter && this._disableStatisticsReporter(), this._ioctl && (this._ioctl.destroy(), this._ioctl = null), this._demuxer && (this._demuxer.destroy(), this._demuxer = null), this._remuxer && (this._remuxer.destroy(), this._remuxer = null), this._emitter.removeAllListeners(), this._emitter = null;
          } }, { key: "on", value: function (e, t) {
            this._emitter.addListener(e, t);
          } }, { key: "off", value: function (e, t) {
            this._emitter.removeListener(e, t);
          } }, { key: "start", value: function () {
            this._loadSegment(0), this._enableStatisticsReporter();
          } }, { key: "_loadSegment", value: function (e, t) {
            this._currentSegmentIndex = e;var n = this._mediaDataSource.segments[e],
                i = this._ioctl = new b.default(n, this._config, e);i.onError = this._onIOException.bind(this), i.onSeeked = this._onIOSeeked.bind(this), i.onComplete = this._onIOComplete.bind(this), i.onRedirect = this._onIORedirect.bind(this), i.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this), t ? this._demuxer.bindDataSource(this._ioctl) : i.onDataArrival = this._onInitChunkArrival.bind(this), i.open(t);
          } }, { key: "stop", value: function () {
            this._internalAbort(), this._disableStatisticsReporter();
          } }, { key: "_internalAbort", value: function () {
            this._ioctl && (this._ioctl.destroy(), this._ioctl = null);
          } }, { key: "pause", value: function () {
            this._ioctl && this._ioctl.isWorking() && (this._ioctl.pause(), this._disableStatisticsReporter());
          } }, { key: "resume", value: function () {
            this._ioctl && this._ioctl.isPaused() && (this._ioctl.resume(), this._enableStatisticsReporter());
          } }, { key: "seek", value: function (e) {
            if (null != this._mediaInfo && this._mediaInfo.isSeekable()) {
              var t = this._searchSegmentIndexContains(e);if (t === this._currentSegmentIndex) {
                var n = this._mediaInfo.segments[t];if (void 0 == n) this._pendingSeekTime = e;else {
                  var i = n.getNearestKeyframe(e);this._remuxer.seek(i.milliseconds), this._ioctl.seek(i.fileposition), this._pendingResolveSeekPoint = i.milliseconds;
                }
              } else {
                var r = this._mediaInfo.segments[t];if (void 0 == r) this._pendingSeekTime = e, this._internalAbort(), this._remuxer.seek(), this._remuxer.insertDiscontinuity(), this._loadSegment(t);else {
                  var s = r.getNearestKeyframe(e);this._internalAbort(), this._remuxer.seek(e), this._remuxer.insertDiscontinuity(), this._demuxer.resetMediaInfo(), this._demuxer.timestampBase = this._mediaDataSource.segments[t].timestampBase, this._loadSegment(t, s.fileposition), this._pendingResolveSeekPoint = s.milliseconds, this._reportSegmentMediaInfo(t);
                }
              }this._enableStatisticsReporter();
            }
          } }, { key: "_searchSegmentIndexContains", value: function (e) {
            for (var t = this._mediaDataSource.segments, n = t.length - 1, i = 0; i < t.length; i++) if (e < t[i].timestampBase) {
              n = i - 1;break;
            }return n;
          } }, { key: "_onInitChunkArrival", value: function (e, t) {
            var n = this,
                i = null,
                r = 0;if (t > 0) this._demuxer.bindDataSource(this._ioctl), this._demuxer.timestampBase = this._mediaDataSource.segments[this._currentSegmentIndex].timestampBase, r = this._demuxer.parseChunks(e, t);else if ((i = m.default.probe(e)).match) {
              this._demuxer = new m.default(i, this._config), this._remuxer || (this._remuxer = new v.default(this._config));var s = this._mediaDataSource;void 0 == s.duration || isNaN(s.duration) || (this._demuxer.overridedDuration = s.duration), "boolean" == typeof s.hasAudio && (this._demuxer.overridedHasAudio = s.hasAudio), "boolean" == typeof s.hasVideo && (this._demuxer.overridedHasVideo = s.hasVideo), this._demuxer.timestampBase = s.segments[this._currentSegmentIndex].timestampBase, this._demuxer.onError = this._onDemuxException.bind(this), this._demuxer.onMediaInfo = this._onMediaInfo.bind(this), this._remuxer.bindDataSource(this._demuxer.bindDataSource(this._ioctl)), this._remuxer.onInitSegment = this._onRemuxerInitSegmentArrival.bind(this), this._remuxer.onMediaSegment = this._onRemuxerMediaSegmentArrival.bind(this), r = this._demuxer.parseChunks(e, t);
            } else i = null, l.default.e(this.TAG, "Non-FLV, Unsupported media type!"), Promise.resolve().then(function () {
              n._internalAbort();
            }), this._emitter.emit(k.default.DEMUX_ERROR, y.default.FORMAT_UNSUPPORTED, "Non-FLV, Unsupported media type"), r = 0;return r;
          } }, { key: "_onMediaInfo", value: function (e) {
            var t = this;null == this._mediaInfo && (this._mediaInfo = Object.assign({}, e), this._mediaInfo.keyframesIndex = null, this._mediaInfo.segments = [], this._mediaInfo.segmentCount = this._mediaDataSource.segments.length, Object.setPrototypeOf(this._mediaInfo, c.default.prototype));var n = Object.assign({}, e);Object.setPrototypeOf(n, c.default.prototype), this._mediaInfo.segments[this._currentSegmentIndex] = n, this._reportSegmentMediaInfo(this._currentSegmentIndex), null != this._pendingSeekTime && Promise.resolve().then(function () {
              var e = t._pendingSeekTime;t._pendingSeekTime = null, t.seek(e);
            });
          } }, { key: "_onIOSeeked", value: function () {
            this._remuxer.insertDiscontinuity();
          } }, { key: "_onIOComplete", value: function (e) {
            var t = e,
                n = t + 1;n < this._mediaDataSource.segments.length ? (this._internalAbort(), this._loadSegment(n)) : (this._emitter.emit(k.default.LOADING_COMPLETE), this._disableStatisticsReporter());
          } }, { key: "_onIORedirect", value: function (e) {
            var t = this._ioctl.extraData;this._mediaDataSource.segments[t].redirectedURL = e;
          } }, { key: "_onIORecoveredEarlyEof", value: function () {
            this._emitter.emit(k.default.RECOVERED_EARLY_EOF);
          } }, { key: "_onIOException", value: function (e, t) {
            l.default.e(this.TAG, "IOException: type = " + e + ", code = " + t.code + ", msg = " + t.msg), this._emitter.emit(k.default.IO_ERROR, e, t), this._disableStatisticsReporter();
          } }, { key: "_onDemuxException", value: function (e, t) {
            l.default.e(this.TAG, "DemuxException: type = " + e + ", info = " + t), this._emitter.emit(k.default.DEMUX_ERROR, e, t);
          } }, { key: "_onRemuxerInitSegmentArrival", value: function (e, t) {
            this._emitter.emit(k.default.INIT_SEGMENT, e, t);
          } }, { key: "_onRemuxerMediaSegmentArrival", value: function (e, t) {
            if (null == this._pendingSeekTime && (this._emitter.emit(k.default.MEDIA_SEGMENT, e, t), null != this._pendingResolveSeekPoint && "video" === e)) {
              var n = t.info.syncPoints,
                  i = this._pendingResolveSeekPoint;this._pendingResolveSeekPoint = null, h.default.safari && n.length > 0 && n[0].originalDts === i && (i = n[0].pts), this._emitter.emit(k.default.RECOMMEND_SEEKPOINT, i);
            }
          } }, { key: "_enableStatisticsReporter", value: function () {
            null == this._statisticsReporter && (this._statisticsReporter = self.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval));
          } }, { key: "_disableStatisticsReporter", value: function () {
            this._statisticsReporter && (self.clearInterval(this._statisticsReporter), this._statisticsReporter = null);
          } }, { key: "_reportSegmentMediaInfo", value: function (e) {
            var t = this._mediaInfo.segments[e],
                n = Object.assign({}, t);n.duration = this._mediaInfo.duration, n.segmentCount = this._mediaInfo.segmentCount, delete n.segments, delete n.keyframesIndex, this._emitter.emit(k.default.MEDIA_INFO, n);
          } }, { key: "_reportStatisticsInfo", value: function () {
            var e = {};e.url = this._ioctl.currentURL, e.hasRedirect = this._ioctl.hasRedirect, e.hasRedirect && (e.redirectedURL = this._ioctl.currentRedirectedURL), e.speed = this._ioctl.currentSpeed, e.loaderType = this._ioctl.loaderType, e.currentSegmentIndex = this._currentSegmentIndex, e.totalSegmentCount = this._mediaDataSource.segments.length, this._emitter.emit(k.default.STATISTICS_INFO, e);
          } }]), e;
      }());n.default = L;
    }, { "../demux/demux-errors.js": 16, "../demux/flv-demuxer.js": 18, "../io/io-controller.js": 23, "../io/loader.js": 24, "../remux/mp4-remuxer.js": 38, "../utils/browser.js": 39, "../utils/logger.js": 41, "./media-info.js": 7, "./transmuxing-events.js": 13, events: 2 }], 13: [function (e, t, n) {
      "use strict";
      Object.defineProperty(n, "__esModule", { value: !0 });var i = { IO_ERROR: "io_error", DEMUX_ERROR: "demux_error", INIT_SEGMENT: "init_segment", MEDIA_SEGMENT: "media_segment", LOADING_COMPLETE: "loading_complete", RECOVERED_EARLY_EOF: "recovered_early_eof", MEDIA_INFO: "media_info", STATISTICS_INFO: "statistics_info", RECOMMEND_SEEKPOINT: "recommend_seekpoint" };n.default = i;
    }, {}], 14: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = e("../utils/logger.js"),
          s = (i(r), e("../utils/logging-control.js")),
          a = i(s),
          o = e("../utils/polyfill.js"),
          u = i(o),
          l = e("./transmuxing-controller.js"),
          d = i(l),
          h = e("./transmuxing-events.js"),
          f = i(h),
          c = function (e) {
        function t(t, n) {
          var i = { msg: f.default.INIT_SEGMENT, data: { type: t, data: n } };e.postMessage(i, [n.data]);
        }function n(t, n) {
          var i = { msg: f.default.MEDIA_SEGMENT, data: { type: t, data: n } };e.postMessage(i, [n.data]);
        }function i() {
          var t = { msg: f.default.LOADING_COMPLETE };e.postMessage(t);
        }function r() {
          var t = { msg: f.default.RECOVERED_EARLY_EOF };e.postMessage(t);
        }function s(t) {
          var n = { msg: f.default.MEDIA_INFO, data: t };e.postMessage(n);
        }function o(t) {
          var n = { msg: f.default.STATISTICS_INFO, data: t };e.postMessage(n);
        }function l(t, n) {
          e.postMessage({ msg: f.default.IO_ERROR, data: { type: t, info: n } });
        }function h(t, n) {
          e.postMessage({ msg: f.default.DEMUX_ERROR, data: { type: t, info: n } });
        }function c(t) {
          e.postMessage({ msg: f.default.RECOMMEND_SEEKPOINT, data: t });
        }function _(t, n) {
          e.postMessage({ msg: "logcat_callback", data: { type: t, logcat: n } });
        }var m = null,
            p = _.bind(this);u.default.install(), e.addEventListener("message", function (u) {
          switch (u.data.cmd) {case "init":
              m = new d.default(u.data.param[0], u.data.param[1]), m.on(f.default.IO_ERROR, l.bind(this)), m.on(f.default.DEMUX_ERROR, h.bind(this)), m.on(f.default.INIT_SEGMENT, t.bind(this)), m.on(f.default.MEDIA_SEGMENT, n.bind(this)), m.on(f.default.LOADING_COMPLETE, i.bind(this)), m.on(f.default.RECOVERED_EARLY_EOF, r.bind(this)), m.on(f.default.MEDIA_INFO, s.bind(this)), m.on(f.default.STATISTICS_INFO, o.bind(this)), m.on(f.default.RECOMMEND_SEEKPOINT, c.bind(this));break;case "destroy":
              m && (m.destroy(), m = null), e.postMessage({ msg: "destroyed" });break;case "start":
              m.start();break;case "stop":
              m.stop();break;case "seek":
              m.seek(u.data.param);break;case "pause":
              m.pause();break;case "resume":
              m.resume();break;case "logging_config":
              var _ = u.data.param;a.default.applyConfig(_), !0 === _.enableCallback ? a.default.addLogListener(p) : a.default.removeLogListener(p);}
        });
      };n.default = c;
    }, { "../utils/logger.js": 41, "../utils/logging-control.js": 42, "../utils/polyfill.js": 43, "./transmuxing-controller.js": 12, "./transmuxing-events.js": 13 }], 15: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var s = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          a = e("../utils/logger.js"),
          o = i(a),
          u = e("../utils/utf8-conv.js"),
          l = i(u),
          d = e("../utils/exception.js"),
          h = function () {
        var e = new ArrayBuffer(2);return new DataView(e).setInt16(0, 256, !0), 256 === new Int16Array(e)[0];
      }(),
          f = function () {
        function e() {
          r(this, e);
        }return s(e, null, [{ key: "parseScriptData", value: function (t, n, i) {
            var r = {};try {
              var s = e.parseValue(t, n, i),
                  a = e.parseValue(t, n + s.size, i - s.size);r[s.data] = a.data;
            } catch (e) {
              o.default.e("AMF", e.toString());
            }return r;
          } }, { key: "parseObject", value: function (t, n, i) {
            if (i < 3) throw new d.IllegalStateException("Data not enough when parse ScriptDataObject");var r = e.parseString(t, n, i),
                s = e.parseValue(t, n + r.size, i - r.size),
                a = s.objectEnd;return { data: { name: r.data, value: s.data }, size: r.size + s.size, objectEnd: a };
          } }, { key: "parseVariable", value: function (t, n, i) {
            return e.parseObject(t, n, i);
          } }, { key: "parseString", value: function (e, t, n) {
            if (n < 2) throw new d.IllegalStateException("Data not enough when parse String");var i = new DataView(e, t, n),
                r = i.getUint16(0, !h),
                s = void 0;return s = r > 0 ? (0, l.default)(new Uint8Array(e, t + 2, r)) : "", { data: s, size: 2 + r };
          } }, { key: "parseLongString", value: function (e, t, n) {
            if (n < 4) throw new d.IllegalStateException("Data not enough when parse LongString");var i = new DataView(e, t, n),
                r = i.getUint32(0, !h),
                s = void 0;return s = r > 0 ? (0, l.default)(new Uint8Array(e, t + 4, r)) : "", { data: s, size: 4 + r };
          } }, { key: "parseDate", value: function (e, t, n) {
            if (n < 10) throw new d.IllegalStateException("Data size invalid when parse Date");var i = new DataView(e, t, n),
                r = i.getFloat64(0, !h);return r += 60 * i.getInt16(8, !h) * 1e3, { data: new Date(r), size: 10 };
          } }, { key: "parseValue", value: function (t, n, i) {
            if (i < 1) throw new d.IllegalStateException("Data not enough when parse Value");var r = new DataView(t, n, i),
                s = 1,
                a = r.getUint8(0),
                u = void 0,
                l = !1;try {
              switch (a) {case 0:
                  u = r.getFloat64(1, !h), s += 8;break;case 1:
                  u = !!r.getUint8(1), s += 1;break;case 2:
                  var f = e.parseString(t, n + 1, i - 1);u = f.data, s += f.size;break;case 3:
                  u = {};var c = 0;for (9 == (16777215 & r.getUint32(i - 4, !h)) && (c = 3); s < i - 4;) {
                    var _ = e.parseObject(t, n + s, i - s - c);if (_.objectEnd) break;u[_.data.name] = _.data.value, s += _.size;
                  }if (s <= i - 3) {
                    9 === (16777215 & r.getUint32(s - 1, !h)) && (s += 3);
                  }break;case 8:
                  u = {}, s += 4;var m = 0;for (9 == (16777215 & r.getUint32(i - 4, !h)) && (m = 3); s < i - 8;) {
                    var p = e.parseVariable(t, n + s, i - s - m);if (p.objectEnd) break;u[p.data.name] = p.data.value, s += p.size;
                  }if (s <= i - 3) {
                    9 === (16777215 & r.getUint32(s - 1, !h)) && (s += 3);
                  }break;case 9:
                  u = void 0, s = 1, l = !0;break;case 10:
                  u = [];var v = r.getUint32(1, !h);s += 4;for (var g = 0; g < v; g++) {
                    var y = e.parseValue(t, n + s, i - s);u.push(y.data), s += y.size;
                  }break;case 11:
                  var E = e.parseDate(t, n + 1, i - 1);u = E.data, s += E.size;break;case 12:
                  var b = e.parseString(t, n + 1, i - 1);u = b.data, s += b.size;break;default:
                  s = i, o.default.w("AMF", "Unsupported AMF value type " + a);}
            } catch (e) {
              o.default.e("AMF", e.toString());
            }return { data: u, size: s, objectEnd: l };
          } }]), e;
      }();n.default = f;
    }, { "../utils/exception.js": 40, "../utils/logger.js": 41, "../utils/utf8-conv.js": 44 }], 16: [function (e, t, n) {
      "use strict";
      Object.defineProperty(n, "__esModule", { value: !0 });var i = { OK: "OK", FORMAT_ERROR: "FormatError", FORMAT_UNSUPPORTED: "FormatUnsupported", CODEC_UNSUPPORTED: "CodecUnsupported" };n.default = i;
    }, {}], 17: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = e("../utils/exception.js"),
          a = function () {
        function e(t) {
          i(this, e), this.TAG = "ExpGolomb", this._buffer = t, this._buffer_index = 0, this._total_bytes = t.byteLength, this._total_bits = 8 * t.byteLength, this._current_word = 0, this._current_word_bits_left = 0;
        }return r(e, [{ key: "destroy", value: function () {
            this._buffer = null;
          } }, { key: "_fillCurrentWord", value: function () {
            var e = this._total_bytes - this._buffer_index;if (e <= 0) throw new s.IllegalStateException("ExpGolomb: _fillCurrentWord() but no bytes available");var t = Math.min(4, e),
                n = new Uint8Array(4);n.set(this._buffer.subarray(this._buffer_index, this._buffer_index + t)), this._current_word = new DataView(n.buffer).getUint32(0, !1), this._buffer_index += t, this._current_word_bits_left = 8 * t;
          } }, { key: "readBits", value: function (e) {
            if (e > 32) throw new s.InvalidArgumentException("ExpGolomb: readBits() bits exceeded max 32bits!");if (e <= this._current_word_bits_left) {
              var t = this._current_word >>> 32 - e;return this._current_word <<= e, this._current_word_bits_left -= e, t;
            }var n = this._current_word_bits_left ? this._current_word : 0;n >>>= 32 - this._current_word_bits_left;var i = e - this._current_word_bits_left;this._fillCurrentWord();var r = Math.min(i, this._current_word_bits_left),
                a = this._current_word >>> 32 - r;return this._current_word <<= r, this._current_word_bits_left -= r, n = n << r | a;
          } }, { key: "readBool", value: function () {
            return 1 === this.readBits(1);
          } }, { key: "readByte", value: function () {
            return this.readBits(8);
          } }, { key: "_skipLeadingZero", value: function () {
            var e = void 0;for (e = 0; e < this._current_word_bits_left; e++) if (0 != (this._current_word & 2147483648 >>> e)) return this._current_word <<= e, this._current_word_bits_left -= e, e;return this._fillCurrentWord(), e + this._skipLeadingZero();
          } }, { key: "readUEG", value: function () {
            var e = this._skipLeadingZero();return this.readBits(e + 1) - 1;
          } }, { key: "readSEG", value: function () {
            var e = this.readUEG();return 1 & e ? e + 1 >>> 1 : -1 * (e >>> 1);
          } }]), e;
      }();n.default = a;
    }, { "../utils/exception.js": 40 }], 18: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }function s(e, t) {
        return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];
      }Object.defineProperty(n, "__esModule", { value: !0 });var a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      },
          o = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          u = e("../utils/logger.js"),
          l = i(u),
          d = e("./amf-parser.js"),
          h = i(d),
          f = e("./sps-parser.js"),
          c = i(f),
          _ = e("./demux-errors.js"),
          m = i(_),
          p = e("../core/media-info.js"),
          v = i(p),
          g = e("../utils/exception.js"),
          y = function () {
        function e(t, n) {
          r(this, e), this.TAG = "FLVDemuxer", this._config = n, this._onError = null, this._onMediaInfo = null, this._onTrackMetadata = null, this._onDataAvailable = null, this._dataOffset = t.dataOffset, this._firstParse = !0, this._dispatch = !1, this._hasAudio = t.hasAudioTrack, this._hasVideo = t.hasVideoTrack, this._hasAudioFlagOverrided = !1, this._hasVideoFlagOverrided = !1, this._audioInitialMetadataDispatched = !1, this._videoInitialMetadataDispatched = !1, this._mediaInfo = new v.default(), this._mediaInfo.hasAudio = this._hasAudio, this._mediaInfo.hasVideo = this._hasVideo, this._metadata = null, this._audioMetadata = null, this._videoMetadata = null, this._naluLengthSize = 4, this._timestampBase = 0, this._timescale = 1e3, this._duration = 0, this._durationOverrided = !1, this._referenceFrameRate = { fixed: !0, fps: 23.976, fps_num: 23976, fps_den: 1e3 }, this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48e3], this._mpegSamplingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], this._mpegAudioV10SampleRateTable = [44100, 48e3, 32e3, 0], this._mpegAudioV20SampleRateTable = [22050, 24e3, 16e3, 0], this._mpegAudioV25SampleRateTable = [11025, 12e3, 8e3, 0], this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1], this._mpegAudioL2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1], this._mpegAudioL3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1], this._videoTrack = { type: "video", id: 1, sequenceNumber: 0, samples: [], length: 0 }, this._audioTrack = { type: "audio", id: 2, sequenceNumber: 0, samples: [], length: 0 }, this._littleEndian = function () {
            var e = new ArrayBuffer(2);return new DataView(e).setInt16(0, 256, !0), 256 === new Int16Array(e)[0];
          }();
        }return o(e, [{ key: "destroy", value: function () {
            this._mediaInfo = null, this._metadata = null, this._audioMetadata = null, this._videoMetadata = null, this._videoTrack = null, this._audioTrack = null, this._onError = null, this._onMediaInfo = null, this._onTrackMetadata = null, this._onDataAvailable = null;
          } }, { key: "bindDataSource", value: function (e) {
            return e.onDataArrival = this.parseChunks.bind(this), this;
          } }, { key: "resetMediaInfo", value: function () {
            this._mediaInfo = new v.default();
          } }, { key: "_isInitialMetadataDispatched", value: function () {
            return this._hasAudio && this._hasVideo ? this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched : this._hasAudio && !this._hasVideo ? this._audioInitialMetadataDispatched : !(this._hasAudio || !this._hasVideo) && this._videoInitialMetadataDispatched;
          } }, { key: "parseChunks", value: function (t, n) {
            if (!(this._onError && this._onMediaInfo && this._onTrackMetadata && this._onDataAvailable)) throw new g.IllegalStateException("Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified");var i = 0,
                r = this._littleEndian;if (0 === n) {
              if (!(t.byteLength > 13)) return 0;i = e.probe(t).dataOffset;
            }if (this._firstParse) {
              this._firstParse = !1, n + i !== this._dataOffset && l.default.w(this.TAG, "First time parsing but chunk byteStart invalid!");0 !== new DataView(t, i).getUint32(0, !r) && l.default.w(this.TAG, "PrevTagSize0 !== 0 !!!"), i += 4;
            }for (; i < t.byteLength;) {
              this._dispatch = !0;var s = new DataView(t, i);if (i + 11 + 4 > t.byteLength) break;var a = s.getUint8(0),
                  o = 16777215 & s.getUint32(0, !r);if (i + 11 + o + 4 > t.byteLength) break;if (8 === a || 9 === a || 18 === a) {
                var u = s.getUint8(4),
                    d = s.getUint8(5),
                    h = s.getUint8(6),
                    f = s.getUint8(7),
                    c = h | d << 8 | u << 16 | f << 24;0 !== (16777215 & s.getUint32(7, !r)) && l.default.w(this.TAG, "Meet tag which has StreamID != 0!");var _ = i + 11;switch (a) {case 8:
                    this._parseAudioData(t, _, o, c);break;case 9:
                    this._parseVideoData(t, _, o, c, n + i);break;case 18:
                    this._parseScriptData(t, _, o);}var m = s.getUint32(11 + o, !r);m !== 11 + o && l.default.w(this.TAG, "Invalid PrevTagSize " + m), i += 11 + o + 4;
              } else l.default.w(this.TAG, "Unsupported tag type " + a + ", skipped"), i += 11 + o + 4;
            }return this._isInitialMetadataDispatched() && this._dispatch && (this._audioTrack.length || this._videoTrack.length) && this._onDataAvailable(this._audioTrack, this._videoTrack), i;
          } }, { key: "_parseScriptData", value: function (e, t, n) {
            var i = h.default.parseScriptData(e, t, n);if (i.hasOwnProperty("onMetaData")) {
              if (null == i.onMetaData || "object" !== a(i.onMetaData)) return void l.default.w(this.TAG, "Invalid onMetaData structure!");this._metadata && l.default.w(this.TAG, "Found another onMetaData tag!"), this._metadata = i;var r = this._metadata.onMetaData;if ("boolean" == typeof r.hasAudio && !1 === this._hasAudioFlagOverrided && (this._hasAudio = r.hasAudio, this._mediaInfo.hasAudio = this._hasAudio), "boolean" == typeof r.hasVideo && !1 === this._hasVideoFlagOverrided && (this._hasVideo = r.hasVideo, this._mediaInfo.hasVideo = this._hasVideo), "number" == typeof r.audiodatarate && (this._mediaInfo.audioDataRate = r.audiodatarate), "number" == typeof r.videodatarate && (this._mediaInfo.videoDataRate = r.videodatarate), "number" == typeof r.width && (this._mediaInfo.width = r.width), "number" == typeof r.height && (this._mediaInfo.height = r.height), "number" == typeof r.duration) {
                if (!this._durationOverrided) {
                  var s = Math.floor(r.duration * this._timescale);this._duration = s, this._mediaInfo.duration = s;
                }
              } else this._mediaInfo.duration = 0;if ("number" == typeof r.framerate) {
                var o = Math.floor(1e3 * r.framerate);if (o > 0) {
                  var u = o / 1e3;this._referenceFrameRate.fixed = !0, this._referenceFrameRate.fps = u, this._referenceFrameRate.fps_num = o, this._referenceFrameRate.fps_den = 1e3, this._mediaInfo.fps = u;
                }
              }if ("object" === a(r.keyframes)) {
                this._mediaInfo.hasKeyframesIndex = !0;var d = r.keyframes;this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(d), r.keyframes = null;
              } else this._mediaInfo.hasKeyframesIndex = !1;this._dispatch = !1, this._mediaInfo.metadata = r, l.default.v(this.TAG, "Parsed onMetaData"), this._mediaInfo.isComplete() && this._onMediaInfo(this._mediaInfo);
            }
          } }, { key: "_parseKeyframesIndex", value: function (e) {
            for (var t = [], n = [], i = 1; i < e.times.length; i++) {
              var r = this._timestampBase + Math.floor(1e3 * e.times[i]);t.push(r), n.push(e.filepositions[i]);
            }return { times: t, filepositions: n };
          } }, { key: "_parseAudioData", value: function (e, t, n, i) {
            if (n <= 1) return void l.default.w(this.TAG, "Flv: Invalid audio packet, missing SoundData payload!");if (!0 !== this._hasAudioFlagOverrided || !1 !== this._hasAudio) {
              var r = (this._littleEndian, new DataView(e, t, n)),
                  s = r.getUint8(0),
                  a = s >>> 4;if (2 !== a && 10 !== a) return void this._onError(m.default.CODEC_UNSUPPORTED, "Flv: Unsupported audio codec idx: " + a);var o = 0,
                  u = (12 & s) >>> 2;if (!(u >= 0 && u <= 4)) return void this._onError(m.default.FORMAT_ERROR, "Flv: Invalid audio sample rate idx: " + u);o = this._flvSoundRateTable[u];var d = 1 & s,
                  h = this._audioMetadata,
                  f = this._audioTrack;if (h || (!1 === this._hasAudio && !1 === this._hasAudioFlagOverrided && (this._hasAudio = !0, this._mediaInfo.hasAudio = !0), h = this._audioMetadata = {}, h.type = "audio", h.id = f.id, h.timescale = this._timescale, h.duration = this._duration, h.audioSampleRate = o, h.channelCount = 0 === d ? 1 : 2), 10 === a) {
                var c = this._parseAACAudioData(e, t + 1, n - 1);if (void 0 == c) return;if (0 === c.packetType) {
                  h.config && l.default.w(this.TAG, "Found another AudioSpecificConfig!");var _ = c.data;h.audioSampleRate = _.samplingRate, h.channelCount = _.channelCount, h.codec = _.codec, h.originalCodec = _.originalCodec, h.config = _.config, h.refSampleDuration = 1024 / h.audioSampleRate * h.timescale, l.default.v(this.TAG, "Parsed AudioSpecificConfig"), this._isInitialMetadataDispatched() ? this._dispatch && (this._audioTrack.length || this._videoTrack.length) && this._onDataAvailable(this._audioTrack, this._videoTrack) : this._audioInitialMetadataDispatched = !0, this._dispatch = !1, this._onTrackMetadata("audio", h);var p = this._mediaInfo;p.audioCodec = h.originalCodec, p.audioSampleRate = h.audioSampleRate, p.audioChannelCount = h.channelCount, p.hasVideo ? null != p.videoCodec && (p.mimeType = 'video/x-flv; codecs="' + p.videoCodec + "," + p.audioCodec + '"') : p.mimeType = 'video/x-flv; codecs="' + p.audioCodec + '"', p.isComplete() && this._onMediaInfo(p);
                } else if (1 === c.packetType) {
                  var v = this._timestampBase + i,
                      g = { unit: c.data, dts: v, pts: v };f.samples.push(g), f.length += c.data.length;
                } else l.default.e(this.TAG, "Flv: Unsupported AAC data type " + c.packetType);
              } else if (2 === a) {
                if (!h.codec) {
                  var y = this._parseMP3AudioData(e, t + 1, n - 1, !0);if (void 0 == y) return;h.audioSampleRate = y.samplingRate, h.channelCount = y.channelCount, h.codec = y.codec, h.originalCodec = y.originalCodec, h.refSampleDuration = 1152 / h.audioSampleRate * h.timescale, l.default.v(this.TAG, "Parsed MPEG Audio Frame Header"), this._audioInitialMetadataDispatched = !0, this._onTrackMetadata("audio", h);var E = this._mediaInfo;E.audioCodec = h.codec, E.audioSampleRate = h.audioSampleRate, E.audioChannelCount = h.channelCount, E.audioDataRate = y.bitRate, E.hasVideo ? null != E.videoCodec && (E.mimeType = 'video/x-flv; codecs="' + E.videoCodec + "," + E.audioCodec + '"') : E.mimeType = 'video/x-flv; codecs="' + E.audioCodec + '"', E.isComplete() && this._onMediaInfo(E);
                }var b = this._parseMP3AudioData(e, t + 1, n - 1, !1);if (void 0 == b) return;var S = this._timestampBase + i,
                    k = { unit: b, dts: S, pts: S };f.samples.push(k), f.length += b.length;
              }
            }
          } }, {
          key: "_parseAACAudioData", value: function (e, t, n) {
            if (n <= 1) return void l.default.w(this.TAG, "Flv: Invalid AAC packet, missing AACPacketType or/and Data!");var i = {},
                r = new Uint8Array(e, t, n);return i.packetType = r[0], 0 === r[0] ? i.data = this._parseAACAudioSpecificConfig(e, t + 1, n - 1) : i.data = r.subarray(1), i;
          } }, { key: "_parseAACAudioSpecificConfig", value: function (e, t, n) {
            var i = new Uint8Array(e, t, n),
                r = null,
                s = 0,
                a = 0,
                o = 0,
                u = null;if (s = a = i[0] >>> 3, (o = (7 & i[0]) << 1 | i[1] >>> 7) < 0 || o >= this._mpegSamplingRates.length) return void this._onError(m.default.FORMAT_ERROR, "Flv: AAC invalid sampling frequency index!");var l = this._mpegSamplingRates[o],
                d = (120 & i[1]) >>> 3;if (d < 0 || d >= 8) return void this._onError(m.default.FORMAT_ERROR, "Flv: AAC invalid channel configuration");5 === s && (u = (7 & i[1]) << 1 | i[2] >>> 7, i[2]);var h = self.navigator.userAgent.toLowerCase();return -1 !== h.indexOf("firefox") ? o >= 6 ? (s = 5, r = new Array(4), u = o - 3) : (s = 2, r = new Array(2), u = o) : -1 !== h.indexOf("android") ? (s = 2, r = new Array(2), u = o) : (s = 5, u = o, r = new Array(4), o >= 6 ? u = o - 3 : 1 === d && (s = 2, r = new Array(2), u = o)), r[0] = s << 3, r[0] |= (15 & o) >>> 1, r[1] = (15 & o) << 7, r[1] |= (15 & d) << 3, 5 === s && (r[1] |= (15 & u) >>> 1, r[2] = (1 & u) << 7, r[2] |= 8, r[3] = 0), { config: r, samplingRate: l, channelCount: d, codec: "mp4a.40." + s, originalCodec: "mp4a.40." + a };
          } }, { key: "_parseMP3AudioData", value: function (e, t, n, i) {
            if (n < 4) return void l.default.w(this.TAG, "Flv: Invalid MP3 packet, header missing!");var r = (this._littleEndian, new Uint8Array(e, t, n)),
                s = null;if (i) {
              if (255 !== r[0]) return;var a = r[1] >>> 3 & 3,
                  o = (6 & r[1]) >> 1,
                  u = (240 & r[2]) >>> 4,
                  d = (12 & r[2]) >>> 2,
                  h = r[3] >>> 6 & 3,
                  f = 3 !== h ? 2 : 1,
                  c = 0,
                  _ = 0;switch (a) {case 0:
                  c = this._mpegAudioV25SampleRateTable[d];break;case 2:
                  c = this._mpegAudioV20SampleRateTable[d];break;case 3:
                  c = this._mpegAudioV10SampleRateTable[d];}switch (o) {case 1:
                  34, u < this._mpegAudioL3BitRateTable.length && (_ = this._mpegAudioL3BitRateTable[u]);break;case 2:
                  33, u < this._mpegAudioL2BitRateTable.length && (_ = this._mpegAudioL2BitRateTable[u]);break;case 3:
                  32, u < this._mpegAudioL1BitRateTable.length && (_ = this._mpegAudioL1BitRateTable[u]);}s = { bitRate: _, samplingRate: c, channelCount: f, codec: "mp3", originalCodec: "mp3" };
            } else s = r;return s;
          } }, { key: "_parseVideoData", value: function (e, t, n, i, r) {
            if (n <= 1) return void l.default.w(this.TAG, "Flv: Invalid video packet, missing VideoData payload!");if (!0 !== this._hasVideoFlagOverrided || !1 !== this._hasVideo) {
              var s = new Uint8Array(e, t, n)[0],
                  a = (240 & s) >>> 4,
                  o = 15 & s;if (7 !== o) return void this._onError(m.default.CODEC_UNSUPPORTED, "Flv: Unsupported codec in video frame: " + o);this._parseAVCVideoPacket(e, t + 1, n - 1, i, r, a);
            }
          } }, { key: "_parseAVCVideoPacket", value: function (e, t, n, i, r, s) {
            if (n < 4) return void l.default.w(this.TAG, "Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime");var a = this._littleEndian,
                o = new DataView(e, t, n),
                u = o.getUint8(0),
                d = 16777215 & o.getUint32(0, !a);if (0 === u) this._parseAVCDecoderConfigurationRecord(e, t + 4, n - 4);else if (1 === u) this._parseAVCVideoData(e, t + 4, n - 4, i, r, s, d);else if (2 !== u) return void this._onError(m.default.FORMAT_ERROR, "Flv: Invalid video packet type " + u);
          } }, { key: "_parseAVCDecoderConfigurationRecord", value: function (e, t, n) {
            if (n < 7) return void l.default.w(this.TAG, "Flv: Invalid AVCDecoderConfigurationRecord, lack of data!");var i = this._videoMetadata,
                r = this._videoTrack,
                s = this._littleEndian,
                a = new DataView(e, t, n);i ? void 0 !== i.avcc && l.default.w(this.TAG, "Found another AVCDecoderConfigurationRecord!") : (!1 === this._hasVideo && !1 === this._hasVideoFlagOverrided && (this._hasVideo = !0, this._mediaInfo.hasVideo = !0), i = this._videoMetadata = {}, i.type = "video", i.id = r.id, i.timescale = this._timescale, i.duration = this._duration);var o = a.getUint8(0),
                u = a.getUint8(1);a.getUint8(2), a.getUint8(3);if (1 !== o || 0 === u) return void this._onError(m.default.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord");if (this._naluLengthSize = 1 + (3 & a.getUint8(4)), 3 !== this._naluLengthSize && 4 !== this._naluLengthSize) return void this._onError(m.default.FORMAT_ERROR, "Flv: Strange NaluLengthSizeMinusOne: " + (this._naluLengthSize - 1));var d = 31 & a.getUint8(5);if (0 === d) return void this._onError(m.default.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord: No SPS");d > 1 && l.default.w(this.TAG, "Flv: Strange AVCDecoderConfigurationRecord: SPS Count = " + d);for (var h = 6, f = 0; f < d; f++) {
              var _ = a.getUint16(h, !s);if (h += 2, 0 !== _) {
                var p = new Uint8Array(e, t + h, _);h += _;var v = c.default.parseSPS(p);if (0 === f) {
                  i.codecWidth = v.codec_size.width, i.codecHeight = v.codec_size.height, i.presentWidth = v.present_size.width, i.presentHeight = v.present_size.height, i.profile = v.profile_string, i.level = v.level_string, i.bitDepth = v.bit_depth, i.chromaFormat = v.chroma_format, i.sarRatio = v.sar_ratio, i.frameRate = v.frame_rate, !1 !== v.frame_rate.fixed && 0 !== v.frame_rate.fps_num && 0 !== v.frame_rate.fps_den || (i.frameRate = this._referenceFrameRate);var g = i.frameRate.fps_den,
                      y = i.frameRate.fps_num;i.refSampleDuration = i.timescale * (g / y);for (var E = p.subarray(1, 4), b = "avc1.", S = 0; S < 3; S++) {
                    var k = E[S].toString(16);k.length < 2 && (k = "0" + k), b += k;
                  }i.codec = b;var L = this._mediaInfo;L.width = i.codecWidth, L.height = i.codecHeight, L.fps = i.frameRate.fps, L.profile = i.profile, L.level = i.level, L.chromaFormat = v.chroma_format_string, L.sarNum = i.sarRatio.width, L.sarDen = i.sarRatio.height, L.videoCodec = b, L.hasAudio ? null != L.audioCodec && (L.mimeType = 'video/x-flv; codecs="' + L.videoCodec + "," + L.audioCodec + '"') : L.mimeType = 'video/x-flv; codecs="' + L.videoCodec + '"', L.isComplete() && this._onMediaInfo(L);
                }
              }
            }var w = a.getUint8(h);if (0 === w) return void this._onError(m.default.FORMAT_ERROR, "Flv: Invalid AVCDecoderConfigurationRecord: No PPS");w > 1 && l.default.w(this.TAG, "Flv: Strange AVCDecoderConfigurationRecord: PPS Count = " + w), h++;for (var R = 0; R < w; R++) {
              var A = a.getUint16(h, !s);h += 2, 0 !== A && (h += A);
            }i.avcc = new Uint8Array(n), i.avcc.set(new Uint8Array(e, t, n), 0), l.default.v(this.TAG, "Parsed AVCDecoderConfigurationRecord"), this._isInitialMetadataDispatched() ? this._dispatch && (this._audioTrack.length || this._videoTrack.length) && this._onDataAvailable(this._audioTrack, this._videoTrack) : this._videoInitialMetadataDispatched = !0, this._dispatch = !1, this._onTrackMetadata("video", i);
          } }, { key: "_parseAVCVideoData", value: function (e, t, n, i, r, s, a) {
            for (var o = this._littleEndian, u = new DataView(e, t, n), d = [], h = 0, f = 0, c = this._naluLengthSize, _ = this._timestampBase + i, m = 1 === s; f < n;) {
              if (f + 4 >= n) {
                l.default.w(this.TAG, "Malformed Nalu near timestamp " + _ + ", offset = " + f + ", dataSize = " + n);break;
              }var p = u.getUint32(f, !o);if (3 === c && (p >>>= 8), p > n - c) return void l.default.w(this.TAG, "Malformed Nalus near timestamp " + _ + ", NaluSize > DataSize!");var v = 31 & u.getUint8(f + c);5 === v && (m = !0);var g = new Uint8Array(e, t + f, c + p),
                  y = { type: v, data: g };d.push(y), h += g.byteLength, f += c + p;
            }if (d.length) {
              var E = this._videoTrack,
                  b = { units: d, length: h, isKeyframe: m, dts: _, cts: a, pts: _ + a };m && (b.fileposition = r), E.samples.push(b), E.length += h;
            }
          } }, { key: "onTrackMetadata", get: function () {
            return this._onTrackMetadata;
          }, set: function (e) {
            this._onTrackMetadata = e;
          } }, { key: "onMediaInfo", get: function () {
            return this._onMediaInfo;
          }, set: function (e) {
            this._onMediaInfo = e;
          } }, { key: "onError", get: function () {
            return this._onError;
          }, set: function (e) {
            this._onError = e;
          } }, { key: "onDataAvailable", get: function () {
            return this._onDataAvailable;
          }, set: function (e) {
            this._onDataAvailable = e;
          } }, { key: "timestampBase", get: function () {
            return this._timestampBase;
          }, set: function (e) {
            this._timestampBase = e;
          } }, { key: "overridedDuration", get: function () {
            return this._duration;
          }, set: function (e) {
            this._durationOverrided = !0, this._duration = e, this._mediaInfo.duration = e;
          } }, { key: "overridedHasAudio", set: function (e) {
            this._hasAudioFlagOverrided = !0, this._hasAudio = e, this._mediaInfo.hasAudio = e;
          } }, { key: "overridedHasVideo", set: function (e) {
            this._hasVideoFlagOverrided = !0, this._hasVideo = e, this._mediaInfo.hasVideo = e;
          } }], [{ key: "probe", value: function (e) {
            var t = new Uint8Array(e),
                n = { match: !1 };if (70 !== t[0] || 76 !== t[1] || 86 !== t[2] || 1 !== t[3]) return n;var i = (4 & t[4]) >>> 2 != 0,
                r = 0 != (1 & t[4]),
                a = s(t, 5);return a < 9 ? n : { match: !0, consumed: a, dataOffset: a, hasAudioTrack: i, hasVideoTrack: r };
          } }]), e;
      }();n.default = y;
    }, { "../core/media-info.js": 7, "../utils/exception.js": 40, "../utils/logger.js": 41, "./amf-parser.js": 15, "./demux-errors.js": 16, "./sps-parser.js": 19 }], 19: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = e("./exp-golomb.js"),
          a = function (e) {
        return e && e.__esModule ? e : { default: e };
      }(s),
          o = function () {
        function e() {
          i(this, e);
        }return r(e, null, [{ key: "_ebsp2rbsp", value: function (e) {
            for (var t = e, n = t.byteLength, i = new Uint8Array(n), r = 0, s = 0; s < n; s++) s >= 2 && 3 === t[s] && 0 === t[s - 1] && 0 === t[s - 2] || (i[r] = t[s], r++);return new Uint8Array(i.buffer, 0, r);
          } }, { key: "parseSPS", value: function (t) {
            var n = e._ebsp2rbsp(t),
                i = new a.default(n);i.readByte();var r = i.readByte();i.readByte();var s = i.readByte();i.readUEG();var o = e.getProfileString(r),
                u = e.getLevelString(s),
                l = 1,
                d = 420,
                h = [0, 420, 422, 444],
                f = 8;if ((100 === r || 110 === r || 122 === r || 244 === r || 44 === r || 83 === r || 86 === r || 118 === r || 128 === r || 138 === r || 144 === r) && (l = i.readUEG(), 3 === l && i.readBits(1), l <= 3 && (d = h[l]), f = i.readUEG() + 8, i.readUEG(), i.readBits(1), i.readBool())) for (var c = 3 !== l ? 8 : 12, _ = 0; _ < c; _++) i.readBool() && (_ < 6 ? e._skipScalingList(i, 16) : e._skipScalingList(i, 64));i.readUEG();var m = i.readUEG();if (0 === m) i.readUEG();else if (1 === m) {
              i.readBits(1), i.readSEG(), i.readSEG();for (var p = i.readUEG(), v = 0; v < p; v++) i.readSEG();
            }i.readUEG(), i.readBits(1);var g = i.readUEG(),
                y = i.readUEG(),
                E = i.readBits(1);0 === E && i.readBits(1), i.readBits(1);var b = 0,
                S = 0,
                k = 0,
                L = 0;i.readBool() && (b = i.readUEG(), S = i.readUEG(), k = i.readUEG(), L = i.readUEG());var w = 1,
                R = 1,
                A = 0,
                O = !0,
                T = 0,
                C = 0;if (i.readBool()) {
              if (i.readBool()) {
                var I = i.readByte(),
                    x = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2],
                    M = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];I > 0 && I < 16 ? (w = x[I - 1], R = M[I - 1]) : 255 === I && (w = i.readByte() << 8 | i.readByte(), R = i.readByte() << 8 | i.readByte());
              }if (i.readBool() && i.readBool(), i.readBool() && (i.readBits(4), i.readBool() && i.readBits(24)), i.readBool() && (i.readUEG(), i.readUEG()), i.readBool()) {
                var D = i.readBits(32),
                    B = i.readBits(32);O = i.readBool(), T = B, C = 2 * D, A = T / C;
              }
            }var j = 1;1 === w && 1 === R || (j = w / R);var P = 0,
                U = 0;if (0 === l) P = 1, U = 2 - E;else {
              var N = 3 === l ? 1 : 2,
                  F = 1 === l ? 2 : 1;P = N, U = F * (2 - E);
            }var G = 16 * (g + 1),
                V = 16 * (y + 1) * (2 - E);G -= (b + S) * P, V -= (k + L) * U;var z = Math.ceil(G * j);return i.destroy(), i = null, { profile_string: o, level_string: u, bit_depth: f, chroma_format: d, chroma_format_string: e.getChromaFormatString(d), frame_rate: { fixed: O, fps: A, fps_den: C, fps_num: T }, sar_ratio: { width: w, height: R }, codec_size: { width: G, height: V }, present_size: { width: z, height: V } };
          } }, { key: "_skipScalingList", value: function (e, t) {
            for (var n = 8, i = 8, r = 0, s = 0; s < t; s++) 0 !== i && (r = e.readSEG(), i = (n + r + 256) % 256), n = 0 === i ? n : i;
          } }, { key: "getProfileString", value: function (e) {
            switch (e) {case 66:
                return "Baseline";case 77:
                return "Main";case 88:
                return "Extended";case 100:
                return "High";case 110:
                return "High10";case 122:
                return "High422";case 244:
                return "High444";default:
                return "Unknown";}
          } }, { key: "getLevelString", value: function (e) {
            return (e / 10).toFixed(1);
          } }, { key: "getChromaFormatString", value: function (e) {
            switch (e) {case 420:
                return "4:2:0";case 422:
                return "4:2:2";case 444:
                return "4:4:4";default:
                return "Unknown";}
          } }]), e;
      }();n.default = o;
    }, { "./exp-golomb.js": 17 }], 20: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        var n = e;if (null == n || "object" !== (void 0 === n ? "undefined" : o(n))) throw new b.InvalidArgumentException("MediaDataSource must be an javascript object!");if (!n.hasOwnProperty("type")) throw new b.InvalidArgumentException("MediaDataSource must has type field to indicate video file type!");switch (n.type) {case "flv":
            return new c.default(n, t);default:
            return new m.default(n, t);}
      }function s() {
        return h.default.supportMSEH264Playback();
      }function a() {
        return h.default.getFeatureList();
      }Object.defineProperty(n, "__esModule", { value: !0 });var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      },
          u = e("./utils/polyfill.js"),
          l = i(u),
          d = e("./core/features.js"),
          h = i(d),
          f = e("./player/flv-player.js"),
          c = i(f),
          _ = e("./player/native-player.js"),
          m = i(_),
          p = e("./player/player-events.js"),
          v = i(p),
          g = e("./player/player-errors.js"),
          y = e("./utils/logging-control.js"),
          E = i(y),
          b = e("./utils/exception.js");l.default.install();var S = {};S.createPlayer = r, S.isSupported = s, S.getFeatureList = a, S.Events = v.default, S.ErrorTypes = g.ErrorTypes, S.ErrorDetails = g.ErrorDetails, S.FlvPlayer = c.default, S.NativePlayer = m.default, S.LoggingControl = E.default, Object.defineProperty(S, "version", { enumerable: !0, get: function () {
          return "1.3.2";
        } }), n.default = S;
    }, { "./core/features.js": 6, "./player/flv-player.js": 32, "./player/native-player.js": 33, "./player/player-errors.js": 34, "./player/player-events.js": 35, "./utils/exception.js": 40, "./utils/logging-control.js": 42, "./utils/polyfill.js": 43 }], 21: [function (e, t, n) {
      "use strict";
      t.exports = e("./flv.js").default;
    }, { "./flv.js": 20 }], 22: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }function s(e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != typeof t && "function" != typeof t ? e : t;
      }function a(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
      }Object.defineProperty(n, "__esModule", { value: !0 });var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      },
          u = function e(t, n, i) {
        null === t && (t = Function.prototype);var r = Object.getOwnPropertyDescriptor(t, n);if (void 0 === r) {
          var s = Object.getPrototypeOf(t);return null === s ? void 0 : e(s, n, i);
        }if ("value" in r) return r.value;var a = r.get;if (void 0 !== a) return a.call(i);
      },
          l = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          d = e("../utils/logger.js"),
          h = (i(d), e("../utils/browser.js")),
          f = i(h),
          c = e("./loader.js"),
          _ = e("../utils/exception.js"),
          m = function (e) {
        function t(e, n) {
          r(this, t);var i = s(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, "fetch-stream-loader"));return i.TAG = "FetchStreamLoader", i._seekHandler = e, i._config = n, i._needStash = !0, i._requestAbort = !1, i._contentLength = null, i._receivedLength = 0, i;
        }return a(t, e), l(t, null, [{ key: "isSupported", value: function () {
            try {
              var e = f.default.msedge && f.default.version.minor >= 15048,
                  t = !f.default.msedge || e;return self.fetch && self.ReadableStream && t;
            } catch (e) {
              return !1;
            }
          } }]), l(t, [{ key: "destroy", value: function () {
            this.isWorking() && this.abort(), u(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "destroy", this).call(this);
          } }, { key: "open", value: function (e, t) {
            var n = this;this._dataSource = e, this._range = t;var i = e.url;this._config.reuseRedirectedURL && void 0 != e.redirectedURL && (i = e.redirectedURL);var r = this._seekHandler.getConfig(i, t),
                s = new self.Headers();if ("object" === o(r.headers)) {
              var a = r.headers;for (var u in a) a.hasOwnProperty(u) && s.append(u, a[u]);
            }var l = { method: "GET", headers: s, mode: "cors", cache: "default", referrerPolicy: "no-referrer-when-downgrade" };!1 === e.cors && (l.mode = "same-origin"), e.withCredentials && (l.credentials = "include"), e.referrerPolicy && (l.referrerPolicy = e.referrerPolicy), this._status = c.LoaderStatus.kConnecting, self.fetch(r.url, l).then(function (e) {
              if (n._requestAbort) return n._requestAbort = !1, void (n._status = c.LoaderStatus.kIdle);if (e.ok && e.status >= 200 && e.status <= 299) {
                if (e.url !== r.url && n._onURLRedirect) {
                  var t = n._seekHandler.removeURLParameters(e.url);n._onURLRedirect(t);
                }var i = e.headers.get("Content-Length");return null != i && (n._contentLength = parseInt(i), 0 !== n._contentLength && n._onContentLengthKnown && n._onContentLengthKnown(n._contentLength)), n._pump.call(n, e.body.getReader());
              }if (n._status = c.LoaderStatus.kError, !n._onError) throw new _.RuntimeException("FetchStreamLoader: Http code invalid, " + e.status + " " + e.statusText);n._onError(c.LoaderErrors.HTTP_STATUS_CODE_INVALID, { code: e.status, msg: e.statusText });
            }).catch(function (e) {
              if (n._status = c.LoaderStatus.kError, !n._onError) throw e;n._onError(c.LoaderErrors.EXCEPTION, { code: -1, msg: e.message });
            });
          } }, { key: "abort", value: function () {
            this._requestAbort = !0;
          } }, { key: "_pump", value: function (e) {
            var t = this;return e.read().then(function (n) {
              if (!n.done) {
                if (!0 === t._requestAbort) return t._requestAbort = !1, t._status = c.LoaderStatus.kComplete, e.cancel();t._status = c.LoaderStatus.kBuffering;var i = n.value.buffer,
                    r = t._range.from + t._receivedLength;return t._receivedLength += i.byteLength, t._onDataArrival && t._onDataArrival(i, r, t._receivedLength), t._pump(e);
              }t._status = c.LoaderStatus.kComplete, t._onComplete && t._onComplete(t._range.from, t._range.from + t._receivedLength - 1);
            }).catch(function (e) {
              if (11 !== e.code || !f.default.msedge) {
                t._status = c.LoaderStatus.kError;var n = 0,
                    i = null;if (19 !== e.code && "network error" !== e.message || !(null === t._contentLength || null !== t._contentLength && t._receivedLength < t._contentLength) ? (n = c.LoaderErrors.EXCEPTION, i = { code: e.code, msg: e.message }) : (n = c.LoaderErrors.EARLY_EOF, i = { code: e.code, msg: "Fetch stream meet Early-EOF" }), !t._onError) throw new _.RuntimeException(i.msg);t._onError(n, i);
              }
            });
          } }]), t;
      }(c.BaseLoader);n.default = m;
    }, { "../utils/browser.js": 39, "../utils/exception.js": 40, "../utils/logger.js": 41, "./loader.js": 24 }], 23: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var s = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          a = e("../utils/logger.js"),
          o = i(a),
          u = e("./speed-sampler.js"),
          l = i(u),
          d = e("./loader.js"),
          h = e("./fetch-stream-loader.js"),
          f = i(h),
          c = e("./xhr-moz-chunked-loader.js"),
          _ = i(c),
          m = e("./xhr-msstream-loader.js"),
          p = (i(m), e("./xhr-range-loader.js")),
          v = i(p),
          g = e("./websocket-loader.js"),
          y = i(g),
          E = e("./range-seek-handler.js"),
          b = i(E),
          S = e("./param-seek-handler.js"),
          k = i(S),
          L = e("../utils/exception.js"),
          w = function () {
        function e(t, n, i) {
          r(this, e), this.TAG = "IOController", this._config = n, this._extraData = i, this._stashInitialSize = 393216, void 0 != n.stashInitialSize && n.stashInitialSize > 0 && (this._stashInitialSize = n.stashInitialSize), this._stashUsed = 0, this._stashSize = this._stashInitialSize, this._bufferSize = 3145728, this._stashBuffer = new ArrayBuffer(this._bufferSize), this._stashByteStart = 0, this._enableStash = !0, !1 === n.enableStashBuffer && (this._enableStash = !1), this._loader = null, this._loaderClass = null, this._seekHandler = null, this._dataSource = t, this._isWebSocketURL = /wss?:\/\/(.+?)/.test(t.url), this._refTotalLength = t.filesize ? t.filesize : null, this._totalLength = this._refTotalLength, this._fullRequestFlag = !1, this._currentRange = null, this._redirectedURL = null, this._speedNormalized = 0, this._speedSampler = new l.default(), this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096], this._isEarlyEofReconnecting = !1, this._paused = !1, this._resumeFrom = 0, this._onDataArrival = null, this._onSeeked = null, this._onError = null, this._onComplete = null, this._onRedirect = null, this._onRecoveredEarlyEof = null, this._selectSeekHandler(), this._selectLoader(), this._createLoader();
        }return s(e, [{ key: "destroy", value: function () {
            this._loader.isWorking() && this._loader.abort(), this._loader.destroy(), this._loader = null, this._loaderClass = null, this._dataSource = null, this._stashBuffer = null, this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0, this._currentRange = null, this._speedSampler = null, this._isEarlyEofReconnecting = !1, this._onDataArrival = null, this._onSeeked = null, this._onError = null, this._onComplete = null, this._onRedirect = null, this._onRecoveredEarlyEof = null, this._extraData = null;
          } }, { key: "isWorking", value: function () {
            return this._loader && this._loader.isWorking() && !this._paused;
          } }, { key: "isPaused", value: function () {
            return this._paused;
          } }, { key: "_selectSeekHandler", value: function () {
            var e = this._config;if ("range" === e.seekType) this._seekHandler = new b.default(this._config.rangeLoadZeroStart);else if ("param" === e.seekType) {
              var t = e.seekParamStart || "bstart",
                  n = e.seekParamEnd || "bend";this._seekHandler = new k.default(t, n);
            } else {
              if ("custom" !== e.seekType) throw new L.InvalidArgumentException("Invalid seekType in config: " + e.seekType);if ("function" != typeof e.customSeekHandler) throw new L.InvalidArgumentException("Custom seekType specified in config but invalid customSeekHandler!");this._seekHandler = new e.customSeekHandler();
            }
          } }, { key: "_selectLoader", value: function () {
            if (this._isWebSocketURL) this._loaderClass = y.default;else if (f.default.isSupported()) this._loaderClass = f.default;else if (_.default.isSupported()) this._loaderClass = _.default;else {
              if (!v.default.isSupported()) throw new L.RuntimeException("Your browser doesn't support xhr with arraybuffer responseType!");this._loaderClass = v.default;
            }
          } }, { key: "_createLoader", value: function () {
            this._loader = new this._loaderClass(this._seekHandler, this._config), !1 === this._loader.needStashBuffer && (this._enableStash = !1), this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this), this._loader.onURLRedirect = this._onURLRedirect.bind(this), this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this), this._loader.onComplete = this._onLoaderComplete.bind(this), this._loader.onError = this._onLoaderError.bind(this);
          } }, { key: "open", value: function (e) {
            this._currentRange = { from: 0, to: -1 }, e && (this._currentRange.from = e), this._speedSampler.reset(), e || (this._fullRequestFlag = !0), this._loader.open(this._dataSource, Object.assign({}, this._currentRange));
          } }, { key: "abort", value: function () {
            this._loader.abort(), this._paused && (this._paused = !1, this._resumeFrom = 0);
          } }, { key: "pause", value: function () {
            this.isWorking() && (this._loader.abort(), 0 !== this._stashUsed ? (this._resumeFrom = this._stashByteStart, this._currentRange.to = this._stashByteStart - 1) : this._resumeFrom = this._currentRange.to + 1, this._stashUsed = 0, this._stashByteStart = 0, this._paused = !0);
          } }, { key: "resume", value: function () {
            if (this._paused) {
              this._paused = !1;var e = this._resumeFrom;this._resumeFrom = 0, this._internalSeek(e, !0);
            }
          } }, { key: "seek", value: function (e) {
            this._paused = !1, this._stashUsed = 0, this._stashByteStart = 0, this._internalSeek(e, !0);
          } }, { key: "_internalSeek", value: function (e, t) {
            this._loader.isWorking() && this._loader.abort(), this._flushStashBuffer(t), this._loader.destroy(), this._loader = null;var n = { from: e, to: -1 };this._currentRange = { from: n.from, to: -1 }, this._speedSampler.reset(), this._stashSize = this._stashInitialSize, this._createLoader(), this._loader.open(this._dataSource, n), this._onSeeked && this._onSeeked();
          } }, { key: "updateUrl", value: function (e) {
            if (!e || "string" != typeof e || 0 === e.length) throw new L.InvalidArgumentException("Url must be a non-empty string!");this._dataSource.url = e;
          } }, { key: "_expandBuffer", value: function (e) {
            for (var t = this._stashSize; t + 1048576 < e;) t *= 2;if ((t += 1048576) !== this._bufferSize) {
              var n = new ArrayBuffer(t);if (this._stashUsed > 0) {
                var i = new Uint8Array(this._stashBuffer, 0, this._stashUsed);new Uint8Array(n, 0, t).set(i, 0);
              }this._stashBuffer = n, this._bufferSize = t;
            }
          } }, { key: "_normalizeSpeed", value: function (e) {
            var t = this._speedNormalizeList,
                n = t.length - 1,
                i = 0,
                r = 0,
                s = n;if (e < t[0]) return t[0];for (; r <= s;) {
              if ((i = r + Math.floor((s - r) / 2)) === n || e >= t[i] && e < t[i + 1]) return t[i];t[i] < e ? r = i + 1 : s = i - 1;
            }
          } }, { key: "_adjustStashSize", value: function (e) {
            var t = 0;(t = this._config.isLive ? e : e < 512 ? e : e >= 512 && e <= 1024 ? Math.floor(1.5 * e) : 2 * e) > 8192 && (t = 8192);var n = 1024 * t + 1048576;this._bufferSize < n && this._expandBuffer(n), this._stashSize = 1024 * t;
          } }, { key: "_dispatchChunks", value: function (e, t) {
            return this._currentRange.to = t + e.byteLength - 1, this._onDataArrival(e, t);
          } }, { key: "_onURLRedirect", value: function (e) {
            this._redirectedURL = e, this._onRedirect && this._onRedirect(e);
          } }, { key: "_onContentLengthKnown", value: function (e) {
            e && this._fullRequestFlag && (this._totalLength = e, this._fullRequestFlag = !1);
          } }, { key: "_onLoaderChunkArrival", value: function (e, t, n) {
            if (!this._onDataArrival) throw new L.IllegalStateException("IOController: No existing consumer (onDataArrival) callback!");if (!this._paused) {
              this._isEarlyEofReconnecting && (this._isEarlyEofReconnecting = !1, this._onRecoveredEarlyEof && this._onRecoveredEarlyEof()), this._speedSampler.addBytes(e.byteLength);var i = this._speedSampler.lastSecondKBps;if (0 !== i) {
                var r = this._normalizeSpeed(i);this._speedNormalized !== r && (this._speedNormalized = r, this._adjustStashSize(r));
              }if (this._enableStash) {
                if (0 === this._stashUsed && 0 === this._stashByteStart && (this._stashByteStart = t), this._stashUsed + e.byteLength <= this._stashSize) {
                  var s = new Uint8Array(this._stashBuffer, 0, this._stashSize);s.set(new Uint8Array(e), this._stashUsed), this._stashUsed += e.byteLength;
                } else {
                  var a = new Uint8Array(this._stashBuffer, 0, this._bufferSize);if (this._stashUsed > 0) {
                    var o = this._stashBuffer.slice(0, this._stashUsed),
                        u = this._dispatchChunks(o, this._stashByteStart);if (u < o.byteLength) {
                      if (u > 0) {
                        var l = new Uint8Array(o, u);a.set(l, 0), this._stashUsed = l.byteLength, this._stashByteStart += u;
                      }
                    } else this._stashUsed = 0, this._stashByteStart += u;this._stashUsed + e.byteLength > this._bufferSize && (this._expandBuffer(this._stashUsed + e.byteLength), a = new Uint8Array(this._stashBuffer, 0, this._bufferSize)), a.set(new Uint8Array(e), this._stashUsed), this._stashUsed += e.byteLength;
                  } else {
                    var d = this._dispatchChunks(e, t);if (d < e.byteLength) {
                      var h = e.byteLength - d;h > this._bufferSize && (this._expandBuffer(h), a = new Uint8Array(this._stashBuffer, 0, this._bufferSize)), a.set(new Uint8Array(e, d), 0), this._stashUsed += h, this._stashByteStart = t + d;
                    }
                  }
                }
              } else if (0 === this._stashUsed) {
                var f = this._dispatchChunks(e, t);if (f < e.byteLength) {
                  var c = e.byteLength - f;c > this._bufferSize && this._expandBuffer(c);var _ = new Uint8Array(this._stashBuffer, 0, this._bufferSize);_.set(new Uint8Array(e, f), 0), this._stashUsed += c, this._stashByteStart = t + f;
                }
              } else {
                this._stashUsed + e.byteLength > this._bufferSize && this._expandBuffer(this._stashUsed + e.byteLength);var m = new Uint8Array(this._stashBuffer, 0, this._bufferSize);m.set(new Uint8Array(e), this._stashUsed), this._stashUsed += e.byteLength;var p = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);if (p < this._stashUsed && p > 0) {
                  var v = new Uint8Array(this._stashBuffer, p);m.set(v, 0);
                }this._stashUsed -= p, this._stashByteStart += p;
              }
            }
          } }, { key: "_flushStashBuffer", value: function (e) {
            if (this._stashUsed > 0) {
              var t = this._stashBuffer.slice(0, this._stashUsed),
                  n = this._dispatchChunks(t, this._stashByteStart),
                  i = t.byteLength - n;if (n < t.byteLength) {
                if (!e) {
                  if (n > 0) {
                    var r = new Uint8Array(this._stashBuffer, 0, this._bufferSize),
                        s = new Uint8Array(t, n);r.set(s, 0), this._stashUsed = s.byteLength, this._stashByteStart += n;
                  }return 0;
                }o.default.w(this.TAG, i + " bytes unconsumed data remain when flush buffer, dropped");
              }return this._stashUsed = 0, this._stashByteStart = 0, i;
            }return 0;
          } }, { key: "_onLoaderComplete", value: function (e, t) {
            this._flushStashBuffer(!0), this._onComplete && this._onComplete(this._extraData);
          } }, { key: "_onLoaderError", value: function (e, t) {
            switch (o.default.e(this.TAG, "Loader error, code = " + t.code + ", msg = " + t.msg), this._flushStashBuffer(!1), this._isEarlyEofReconnecting && (this._isEarlyEofReconnecting = !1, e = d.LoaderErrors.UNRECOVERABLE_EARLY_EOF), e) {case d.LoaderErrors.EARLY_EOF:
                if (!this._config.isLive && this._totalLength) {
                  var n = this._currentRange.to + 1;return void (n < this._totalLength && (o.default.w(this.TAG, "Connection lost, trying reconnect..."), this._isEarlyEofReconnecting = !0, this._internalSeek(n, !1)));
                }e = d.LoaderErrors.UNRECOVERABLE_EARLY_EOF;break;case d.LoaderErrors.UNRECOVERABLE_EARLY_EOF:case d.LoaderErrors.CONNECTING_TIMEOUT:case d.LoaderErrors.HTTP_STATUS_CODE_INVALID:case d.LoaderErrors.EXCEPTION:}if (!this._onError) throw new L.RuntimeException("IOException: " + t.msg);this._onError(e, t);
          } }, { key: "status", get: function () {
            return this._loader.status;
          } }, { key: "extraData", get: function () {
            return this._extraData;
          }, set: function (e) {
            this._extraData = e;
          } }, { key: "onDataArrival", get: function () {
            return this._onDataArrival;
          }, set: function (e) {
            this._onDataArrival = e;
          } }, { key: "onSeeked", get: function () {
            return this._onSeeked;
          }, set: function (e) {
            this._onSeeked = e;
          } }, { key: "onError", get: function () {
            return this._onError;
          }, set: function (e) {
            this._onError = e;
          } }, { key: "onComplete", get: function () {
            return this._onComplete;
          }, set: function (e) {
            this._onComplete = e;
          } }, { key: "onRedirect", get: function () {
            return this._onRedirect;
          }, set: function (e) {
            this._onRedirect = e;
          } }, { key: "onRecoveredEarlyEof", get: function () {
            return this._onRecoveredEarlyEof;
          }, set: function (e) {
            this._onRecoveredEarlyEof = e;
          } }, { key: "currentURL", get: function () {
            return this._dataSource.url;
          } }, { key: "hasRedirect", get: function () {
            return null != this._redirectedURL || void 0 != this._dataSource.redirectedURL;
          } }, { key: "currentRedirectedURL", get: function () {
            return this._redirectedURL || this._dataSource.redirectedURL;
          } }, { key: "currentSpeed", get: function () {
            return this._loaderClass === v.default ? this._loader.currentSpeed : this._speedSampler.lastSecondKBps;
          } }, { key: "loaderType", get: function () {
            return this._loader.type;
          } }]), e;
      }();n.default = w;
    }, { "../utils/exception.js": 40, "../utils/logger.js": 41, "./fetch-stream-loader.js": 22, "./loader.js": 24, "./param-seek-handler.js": 25, "./range-seek-handler.js": 26, "./speed-sampler.js": 27, "./websocket-loader.js": 28, "./xhr-moz-chunked-loader.js": 29, "./xhr-msstream-loader.js": 30, "./xhr-range-loader.js": 31 }], 24: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 }), n.BaseLoader = n.LoaderErrors = n.LoaderStatus = void 0;var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = e("../utils/exception.js"),
          a = n.LoaderStatus = { kIdle: 0, kConnecting: 1, kBuffering: 2, kError: 3, kComplete: 4 };n.LoaderErrors = { OK: "OK", EXCEPTION: "Exception", HTTP_STATUS_CODE_INVALID: "HttpStatusCodeInvalid", CONNECTING_TIMEOUT: "ConnectingTimeout", EARLY_EOF: "EarlyEof", UNRECOVERABLE_EARLY_EOF: "UnrecoverableEarlyEof" }, n.BaseLoader = function () {
        function e(t) {
          i(this, e), this._type = t || "undefined", this._status = a.kIdle, this._needStash = !1, this._onContentLengthKnown = null, this._onURLRedirect = null, this._onDataArrival = null, this._onError = null, this._onComplete = null;
        }return r(e, [{ key: "destroy", value: function () {
            this._status = a.kIdle, this._onContentLengthKnown = null, this._onURLRedirect = null, this._onDataArrival = null, this._onError = null, this._onComplete = null;
          } }, { key: "isWorking", value: function () {
            return this._status === a.kConnecting || this._status === a.kBuffering;
          } }, { key: "open", value: function (e, t) {
            throw new s.NotImplementedException("Unimplemented abstract function!");
          } }, { key: "abort", value: function () {
            throw new s.NotImplementedException("Unimplemented abstract function!");
          } }, { key: "type", get: function () {
            return this._type;
          } }, { key: "status", get: function () {
            return this._status;
          } }, { key: "needStashBuffer", get: function () {
            return this._needStash;
          } }, { key: "onContentLengthKnown", get: function () {
            return this._onContentLengthKnown;
          }, set: function (e) {
            this._onContentLengthKnown = e;
          } }, { key: "onURLRedirect", get: function () {
            return this._onURLRedirect;
          }, set: function (e) {
            this._onURLRedirect = e;
          } }, { key: "onDataArrival", get: function () {
            return this._onDataArrival;
          }, set: function (e) {
            this._onDataArrival = e;
          } }, { key: "onError", get: function () {
            return this._onError;
          }, set: function (e) {
            this._onError = e;
          } }, { key: "onComplete", get: function () {
            return this._onComplete;
          }, set: function (e) {
            this._onComplete = e;
          } }]), e;
      }();
    }, { "../utils/exception.js": 40 }], 25: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = function () {
        function e(t, n) {
          i(this, e), this._startName = t, this._endName = n;
        }return r(e, [{ key: "getConfig", value: function (e, t) {
            var n = e;if (0 !== t.from || -1 !== t.to) {
              var i = !0;-1 === n.indexOf("?") && (n += "?", i = !1), i && (n += "&"), n += this._startName + "=" + t.from.toString(), -1 !== t.to && (n += "&" + this._endName + "=" + t.to.toString());
            }return { url: n, headers: {} };
          } }, { key: "removeURLParameters", value: function (e) {
            var t = e.split("?")[0],
                n = void 0,
                i = e.indexOf("?");-1 !== i && (n = e.substring(i + 1));var r = "";if (void 0 != n && n.length > 0) for (var s = n.split("&"), a = 0; a < s.length; a++) {
              var o = s[a].split("="),
                  u = a > 0;o[0] !== this._startName && o[0] !== this._endName && (u && (r += "&"), r += s[a]);
            }return 0 === r.length ? t : t + "?" + r;
          } }]), e;
      }();n.default = s;
    }, {}], 26: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = function () {
        function e(t) {
          i(this, e), this._zeroStart = t || !1;
        }return r(e, [{ key: "getConfig", value: function (e, t) {
            var n = {};if (0 !== t.from || -1 !== t.to) {
              var i = void 0;i = -1 !== t.to ? "bytes=" + t.from.toString() + "-" + t.to.toString() : "bytes=" + t.from.toString() + "-", n.Range = i;
            } else this._zeroStart && (n.Range = "bytes=0-");return { url: e, headers: n };
          } }, { key: "removeURLParameters", value: function (e) {
            return e;
          } }]), e;
      }();n.default = s;
    }, {}], 27: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = function () {
        function e() {
          i(this, e), this._firstCheckpoint = 0, this._lastCheckpoint = 0, this._intervalBytes = 0, this._totalBytes = 0, this._lastSecondBytes = 0, self.performance && self.performance.now ? this._now = self.performance.now.bind(self.performance) : this._now = Date.now;
        }return r(e, [{ key: "reset", value: function () {
            this._firstCheckpoint = this._lastCheckpoint = 0, this._totalBytes = this._intervalBytes = 0, this._lastSecondBytes = 0;
          } }, { key: "addBytes", value: function (e) {
            0 === this._firstCheckpoint ? (this._firstCheckpoint = this._now(), this._lastCheckpoint = this._firstCheckpoint, this._intervalBytes += e, this._totalBytes += e) : this._now() - this._lastCheckpoint < 1e3 ? (this._intervalBytes += e, this._totalBytes += e) : (this._lastSecondBytes = this._intervalBytes, this._intervalBytes = e, this._totalBytes += e, this._lastCheckpoint = this._now());
          } }, { key: "currentKBps", get: function () {
            this.addBytes(0);var e = (this._now() - this._lastCheckpoint) / 1e3;return 0 == e && (e = 1), this._intervalBytes / e / 1024;
          } }, { key: "lastSecondKBps", get: function () {
            return this.addBytes(0), 0 !== this._lastSecondBytes ? this._lastSecondBytes / 1024 : this._now() - this._lastCheckpoint >= 500 ? this.currentKBps : 0;
          } }, { key: "averageKBps", get: function () {
            var e = (this._now() - this._firstCheckpoint) / 1e3;return this._totalBytes / e / 1024;
          } }]), e;
      }();n.default = s;
    }, {}], 28: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }function r(e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != typeof t && "function" != typeof t ? e : t;
      }function s(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
      }Object.defineProperty(n, "__esModule", { value: !0 });var a = function e(t, n, i) {
        null === t && (t = Function.prototype);var r = Object.getOwnPropertyDescriptor(t, n);if (void 0 === r) {
          var s = Object.getPrototypeOf(t);return null === s ? void 0 : e(s, n, i);
        }if ("value" in r) return r.value;var a = r.get;if (void 0 !== a) return a.call(i);
      },
          o = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          u = e("../utils/logger.js"),
          l = (function (e) {
        e && e.__esModule;
      }(u), e("./loader.js")),
          d = e("../utils/exception.js"),
          h = function (e) {
        function t() {
          i(this, t);var e = r(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, "websocket-loader"));return e.TAG = "WebSocketLoader", e._needStash = !0, e._ws = null, e._requestAbort = !1, e._receivedLength = 0, e;
        }return s(t, e), o(t, null, [{ key: "isSupported", value: function () {
            try {
              return void 0 !== self.WebSocket;
            } catch (e) {
              return !1;
            }
          } }]), o(t, [{ key: "destroy", value: function () {
            this._ws && this.abort(), a(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "destroy", this).call(this);
          } }, { key: "open", value: function (e) {
            try {
              var t = this._ws = new self.WebSocket(e.url);t.binaryType = "arraybuffer", t.onopen = this._onWebSocketOpen.bind(this), t.onclose = this._onWebSocketClose.bind(this), t.onmessage = this._onWebSocketMessage.bind(this), t.onerror = this._onWebSocketError.bind(this), this._status = l.LoaderStatus.kConnecting;
            } catch (e) {
              this._status = l.LoaderStatus.kError;var n = { code: e.code, msg: e.message };if (!this._onError) throw new d.RuntimeException(n.msg);this._onError(l.LoaderErrors.EXCEPTION, n);
            }
          } }, { key: "abort", value: function () {
            var e = this._ws;!e || 0 !== e.readyState && 1 !== e.readyState || (this._requestAbort = !0, e.close()), this._ws = null, this._status = l.LoaderStatus.kComplete;
          } }, { key: "_onWebSocketOpen", value: function (e) {
            this._status = l.LoaderStatus.kBuffering;
          } }, { key: "_onWebSocketClose", value: function (e) {
            if (!0 === this._requestAbort) return void (this._requestAbort = !1);this._status = l.LoaderStatus.kComplete, this._onComplete && this._onComplete(0, this._receivedLength - 1);
          } }, { key: "_onWebSocketMessage", value: function (e) {
            var t = this;if (e.data instanceof ArrayBuffer) this._dispatchArrayBuffer(e.data);else if (e.data instanceof Blob) {
              var n = new FileReader();n.onload = function () {
                t._dispatchArrayBuffer(n.result);
              }, n.readAsArrayBuffer(e.data);
            } else {
              this._status = l.LoaderStatus.kError;var i = { code: -1, msg: "Unsupported WebSocket message type: " + e.data.constructor.name };if (!this._onError) throw new d.RuntimeException(i.msg);this._onError(l.LoaderErrors.EXCEPTION, i);
            }
          } }, { key: "_dispatchArrayBuffer", value: function (e) {
            var t = e,
                n = this._receivedLength;this._receivedLength += t.byteLength, this._onDataArrival && this._onDataArrival(t, n, this._receivedLength);
          } }, { key: "_onWebSocketError", value: function (e) {
            this._status = l.LoaderStatus.kError;var t = { code: e.code, msg: e.message };if (!this._onError) throw new d.RuntimeException(t.msg);this._onError(l.LoaderErrors.EXCEPTION, t);
          } }]), t;
      }(l.BaseLoader);n.default = h;
    }, { "../utils/exception.js": 40, "../utils/logger.js": 41, "./loader.js": 24 }], 29: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }function r(e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != typeof t && "function" != typeof t ? e : t;
      }function s(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
      }Object.defineProperty(n, "__esModule", { value: !0 });var a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      },
          o = function e(t, n, i) {
        null === t && (t = Function.prototype);var r = Object.getOwnPropertyDescriptor(t, n);if (void 0 === r) {
          var s = Object.getPrototypeOf(t);return null === s ? void 0 : e(s, n, i);
        }if ("value" in r) return r.value;var a = r.get;if (void 0 !== a) return a.call(i);
      },
          u = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          l = e("../utils/logger.js"),
          d = function (e) {
        return e && e.__esModule ? e : { default: e };
      }(l),
          h = e("./loader.js"),
          f = e("../utils/exception.js"),
          c = function (e) {
        function t(e, n) {
          i(this, t);var s = r(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, "xhr-moz-chunked-loader"));return s.TAG = "MozChunkedLoader", s._seekHandler = e, s._config = n, s._needStash = !0, s._xhr = null, s._requestAbort = !1, s._contentLength = null, s._receivedLength = 0, s;
        }return s(t, e), u(t, null, [{ key: "isSupported", value: function () {
            try {
              var e = new XMLHttpRequest();return e.open("GET", "https://example.com", !0), e.responseType = "moz-chunked-arraybuffer", "moz-chunked-arraybuffer" === e.responseType;
            } catch (e) {
              return d.default.w("MozChunkedLoader", e.message), !1;
            }
          } }]), u(t, [{ key: "destroy", value: function () {
            this.isWorking() && this.abort(), this._xhr && (this._xhr.onreadystatechange = null, this._xhr.onprogress = null, this._xhr.onloadend = null, this._xhr.onerror = null, this._xhr = null), o(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "destroy", this).call(this);
          } }, { key: "open", value: function (e, t) {
            this._dataSource = e, this._range = t;var n = e.url;this._config.reuseRedirectedURL && void 0 != e.redirectedURL && (n = e.redirectedURL);var i = this._seekHandler.getConfig(n, t);this._requestURL = i.url;var r = this._xhr = new XMLHttpRequest();if (r.open("GET", i.url, !0), r.responseType = "moz-chunked-arraybuffer", r.onreadystatechange = this._onReadyStateChange.bind(this), r.onprogress = this._onProgress.bind(this), r.onloadend = this._onLoadEnd.bind(this), r.onerror = this._onXhrError.bind(this), e.withCredentials && r.withCredentials && (r.withCredentials = !0), "object" === a(i.headers)) {
              var s = i.headers;for (var o in s) s.hasOwnProperty(o) && r.setRequestHeader(o, s[o]);
            }this._status = h.LoaderStatus.kConnecting, r.send();
          } }, { key: "abort", value: function () {
            this._requestAbort = !0, this._xhr && this._xhr.abort(), this._status = h.LoaderStatus.kComplete;
          } }, { key: "_onReadyStateChange", value: function (e) {
            var t = e.target;if (2 === t.readyState) {
              if (void 0 != t.responseURL && t.responseURL !== this._requestURL && this._onURLRedirect) {
                var n = this._seekHandler.removeURLParameters(t.responseURL);this._onURLRedirect(n);
              }if (0 !== t.status && (t.status < 200 || t.status > 299)) {
                if (this._status = h.LoaderStatus.kError, !this._onError) throw new f.RuntimeException("MozChunkedLoader: Http code invalid, " + t.status + " " + t.statusText);this._onError(h.LoaderErrors.HTTP_STATUS_CODE_INVALID, { code: t.status, msg: t.statusText });
              } else this._status = h.LoaderStatus.kBuffering;
            }
          } }, { key: "_onProgress", value: function (e) {
            null === this._contentLength && null !== e.total && 0 !== e.total && (this._contentLength = e.total, this._onContentLengthKnown && this._onContentLengthKnown(this._contentLength));var t = e.target.response,
                n = this._range.from + this._receivedLength;this._receivedLength += t.byteLength, this._onDataArrival && this._onDataArrival(t, n, this._receivedLength);
          } }, { key: "_onLoadEnd", value: function (e) {
            if (!0 === this._requestAbort) return void (this._requestAbort = !1);this._status !== h.LoaderStatus.kError && (this._status = h.LoaderStatus.kComplete, this._onComplete && this._onComplete(this._range.from, this._range.from + this._receivedLength - 1));
          } }, { key: "_onXhrError", value: function (e) {
            this._status = h.LoaderStatus.kError;var t = 0,
                n = null;if (this._contentLength && e.loaded < this._contentLength ? (t = h.LoaderErrors.EARLY_EOF, n = { code: -1, msg: "Moz-Chunked stream meet Early-Eof" }) : (t = h.LoaderErrors.EXCEPTION, n = { code: -1, msg: e.constructor.name + " " + e.type }), !this._onError) throw new f.RuntimeException(n.msg);this._onError(t, n);
          } }]), t;
      }(h.BaseLoader);n.default = c;
    }, { "../utils/exception.js": 40, "../utils/logger.js": 41, "./loader.js": 24 }], 30: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }function r(e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != typeof t && "function" != typeof t ? e : t;
      }function s(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
      }Object.defineProperty(n, "__esModule", { value: !0 });var a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      },
          o = function e(t, n, i) {
        null === t && (t = Function.prototype);var r = Object.getOwnPropertyDescriptor(t, n);if (void 0 === r) {
          var s = Object.getPrototypeOf(t);return null === s ? void 0 : e(s, n, i);
        }if ("value" in r) return r.value;var a = r.get;if (void 0 !== a) return a.call(i);
      },
          u = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          l = e("../utils/logger.js"),
          d = function (e) {
        return e && e.__esModule ? e : { default: e };
      }(l),
          h = e("./loader.js"),
          f = e("../utils/exception.js"),
          c = function (e) {
        function t(e, n) {
          i(this, t);var s = r(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, "xhr-msstream-loader"));return s.TAG = "MSStreamLoader", s._seekHandler = e, s._config = n, s._needStash = !0, s._xhr = null, s._reader = null, s._totalRange = null, s._currentRange = null, s._currentRequestURL = null, s._currentRedirectedURL = null, s._contentLength = null, s._receivedLength = 0, s._bufferLimit = 16777216, s._lastTimeBufferSize = 0, s._isReconnecting = !1, s;
        }return s(t, e), u(t, null, [{ key: "isSupported", value: function () {
            try {
              if (void 0 === self.MSStream || void 0 === self.MSStreamReader) return !1;var e = new XMLHttpRequest();return e.open("GET", "https://example.com", !0), e.responseType = "ms-stream", "ms-stream" === e.responseType;
            } catch (e) {
              return d.default.w("MSStreamLoader", e.message), !1;
            }
          } }]), u(t, [{ key: "destroy", value: function () {
            this.isWorking() && this.abort(), this._reader && (this._reader.onprogress = null, this._reader.onload = null, this._reader.onerror = null, this._reader = null), this._xhr && (this._xhr.onreadystatechange = null, this._xhr = null), o(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "destroy", this).call(this);
          } }, { key: "open", value: function (e, t) {
            this._internalOpen(e, t, !1);
          } }, { key: "_internalOpen", value: function (e, t, n) {
            this._dataSource = e, n ? this._currentRange = t : this._totalRange = t;var i = e.url;this._config.reuseRedirectedURL && (void 0 != this._currentRedirectedURL ? i = this._currentRedirectedURL : void 0 != e.redirectedURL && (i = e.redirectedURL));var r = this._seekHandler.getConfig(i, t);this._currentRequestURL = r.url;var s = this._reader = new self.MSStreamReader();s.onprogress = this._msrOnProgress.bind(this), s.onload = this._msrOnLoad.bind(this), s.onerror = this._msrOnError.bind(this);var o = this._xhr = new XMLHttpRequest();if (o.open("GET", r.url, !0), o.responseType = "ms-stream", o.onreadystatechange = this._xhrOnReadyStateChange.bind(this), o.onerror = this._xhrOnError.bind(this), e.withCredentials && (o.withCredentials = !0), "object" === a(r.headers)) {
              var u = r.headers;for (var l in u) u.hasOwnProperty(l) && o.setRequestHeader(l, u[l]);
            }this._isReconnecting ? this._isReconnecting = !1 : this._status = h.LoaderStatus.kConnecting, o.send();
          } }, { key: "abort", value: function () {
            this._internalAbort(), this._status = h.LoaderStatus.kComplete;
          } }, { key: "_internalAbort", value: function () {
            this._reader && (1 === this._reader.readyState && this._reader.abort(), this._reader.onprogress = null, this._reader.onload = null, this._reader.onerror = null, this._reader = null), this._xhr && (this._xhr.abort(), this._xhr.onreadystatechange = null, this._xhr = null);
          } }, { key: "_xhrOnReadyStateChange", value: function (e) {
            var t = e.target;if (2 === t.readyState) {
              if (t.status >= 200 && t.status <= 299) {
                if (this._status = h.LoaderStatus.kBuffering, void 0 != t.responseURL) {
                  var n = this._seekHandler.removeURLParameters(t.responseURL);t.responseURL !== this._currentRequestURL && n !== this._currentRedirectedURL && (this._currentRedirectedURL = n, this._onURLRedirect && this._onURLRedirect(n));
                }var i = t.getResponseHeader("Content-Length");if (null != i && null == this._contentLength) {
                  var r = parseInt(i);r > 0 && (this._contentLength = r, this._onContentLengthKnown && this._onContentLengthKnown(this._contentLength));
                }
              } else {
                if (this._status = h.LoaderStatus.kError, !this._onError) throw new f.RuntimeException("MSStreamLoader: Http code invalid, " + t.status + " " + t.statusText);this._onError(h.LoaderErrors.HTTP_STATUS_CODE_INVALID, { code: t.status, msg: t.statusText });
              }
            } else if (3 === t.readyState && t.status >= 200 && t.status <= 299) {
              this._status = h.LoaderStatus.kBuffering;var s = t.response;this._reader.readAsArrayBuffer(s);
            }
          } }, { key: "_xhrOnError", value: function (e) {
            this._status = h.LoaderStatus.kError;var t = h.LoaderErrors.EXCEPTION,
                n = { code: -1, msg: e.constructor.name + " " + e.type };if (!this._onError) throw new f.RuntimeException(n.msg);this._onError(t, n);
          } }, { key: "_msrOnProgress", value: function (e) {
            var t = e.target,
                n = t.result;if (null == n) return void this._doReconnectIfNeeded();var i = n.slice(this._lastTimeBufferSize);this._lastTimeBufferSize = n.byteLength;var r = this._totalRange.from + this._receivedLength;this._receivedLength += i.byteLength, this._onDataArrival && this._onDataArrival(i, r, this._receivedLength), n.byteLength >= this._bufferLimit && (d.default.v(this.TAG, "MSStream buffer exceeded max size near " + (r + i.byteLength) + ", reconnecting..."), this._doReconnectIfNeeded());
          } }, { key: "_doReconnectIfNeeded", value: function () {
            if (null == this._contentLength || this._receivedLength < this._contentLength) {
              this._isReconnecting = !0, this._lastTimeBufferSize = 0, this._internalAbort();var e = { from: this._totalRange.from + this._receivedLength, to: -1 };this._internalOpen(this._dataSource, e, !0);
            }
          } }, { key: "_msrOnLoad", value: function (e) {
            this._status = h.LoaderStatus.kComplete, this._onComplete && this._onComplete(this._totalRange.from, this._totalRange.from + this._receivedLength - 1);
          } }, { key: "_msrOnError", value: function (e) {
            this._status = h.LoaderStatus.kError;var t = 0,
                n = null;if (this._contentLength && this._receivedLength < this._contentLength ? (t = h.LoaderErrors.EARLY_EOF, n = { code: -1, msg: "MSStream meet Early-Eof" }) : (t = h.LoaderErrors.EARLY_EOF, n = { code: -1, msg: e.constructor.name + " " + e.type }), !this._onError) throw new f.RuntimeException(n.msg);this._onError(t, n);
          } }]), t;
      }(h.BaseLoader);n.default = c;
    }, { "../utils/exception.js": 40, "../utils/logger.js": 41, "./loader.js": 24 }], 31: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }function s(e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != typeof t && "function" != typeof t ? e : t;
      }function a(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
      }Object.defineProperty(n, "__esModule", { value: !0 });var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      },
          u = function e(t, n, i) {
        null === t && (t = Function.prototype);var r = Object.getOwnPropertyDescriptor(t, n);if (void 0 === r) {
          var s = Object.getPrototypeOf(t);return null === s ? void 0 : e(s, n, i);
        }if ("value" in r) return r.value;var a = r.get;if (void 0 !== a) return a.call(i);
      },
          l = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          d = e("../utils/logger.js"),
          h = i(d),
          f = e("./speed-sampler.js"),
          c = i(f),
          _ = e("./loader.js"),
          m = e("../utils/exception.js"),
          p = function (e) {
        function t(e, n) {
          r(this, t);var i = s(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, "xhr-range-loader"));return i.TAG = "RangeLoader", i._seekHandler = e, i._config = n, i._needStash = !1, i._chunkSizeKBList = [128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 5120, 6144, 7168, 8192], i._currentChunkSizeKB = 384, i._currentSpeedNormalized = 0, i._zeroSpeedChunkCount = 0, i._xhr = null, i._speedSampler = new c.default(), i._requestAbort = !1, i._waitForTotalLength = !1, i._totalLengthReceived = !1, i._currentRequestURL = null, i._currentRedirectedURL = null, i._currentRequestRange = null, i._totalLength = null, i._contentLength = null, i._receivedLength = 0, i._lastTimeLoaded = 0, i;
        }return a(t, e), l(t, null, [{ key: "isSupported", value: function () {
            try {
              var e = new XMLHttpRequest();return e.open("GET", "https://example.com", !0), e.responseType = "arraybuffer", "arraybuffer" === e.responseType;
            } catch (e) {
              return h.default.w("RangeLoader", e.message), !1;
            }
          } }]), l(t, [{ key: "destroy", value: function () {
            this.isWorking() && this.abort(), this._xhr && (this._xhr.onreadystatechange = null, this._xhr.onprogress = null, this._xhr.onload = null, this._xhr.onerror = null, this._xhr = null), u(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "destroy", this).call(this);
          } }, { key: "open", value: function (e, t) {
            this._dataSource = e, this._range = t, this._status = _.LoaderStatus.kConnecting, this._totalLengthReceived ? this._openSubRange() : (this._waitForTotalLength = !0, this._internalOpen(this._dataSource, { from: 0, to: -1 }));
          } }, { key: "_openSubRange", value: function () {
            var e = 1024 * this._currentChunkSizeKB,
                t = this._range.from + this._receivedLength,
                n = t + e;null != this._contentLength && n - this._range.from >= this._contentLength && (n = this._range.from + this._contentLength - 1), this._currentRequestRange = { from: t, to: n }, this._internalOpen(this._dataSource, this._currentRequestRange);
          } }, { key: "_internalOpen", value: function (e, t) {
            this._lastTimeLoaded = 0;var n = e.url;this._config.reuseRedirectedURL && (void 0 != this._currentRedirectedURL ? n = this._currentRedirectedURL : void 0 != e.redirectedURL && (n = e.redirectedURL));var i = this._seekHandler.getConfig(n, t);this._currentRequestURL = i.url;var r = this._xhr = new XMLHttpRequest();if (r.open("GET", i.url, !0), r.responseType = "arraybuffer", r.onreadystatechange = this._onReadyStateChange.bind(this), r.onprogress = this._onProgress.bind(this), r.onload = this._onLoad.bind(this), r.onerror = this._onXhrError.bind(this), e.withCredentials && r.withCredentials && (r.withCredentials = !0), "object" === o(i.headers)) {
              var s = i.headers;for (var a in s) s.hasOwnProperty(a) && r.setRequestHeader(a, s[a]);
            }r.send();
          } }, { key: "abort", value: function () {
            this._requestAbort = !0, this._internalAbort(), this._status = _.LoaderStatus.kComplete;
          } }, { key: "_internalAbort", value: function () {
            this._xhr && (this._xhr.onreadystatechange = null, this._xhr.onprogress = null, this._xhr.onload = null, this._xhr.onerror = null, this._xhr.abort(), this._xhr = null);
          } }, { key: "_onReadyStateChange", value: function (e) {
            var t = e.target;if (2 === t.readyState) {
              if (void 0 != t.responseURL) {
                var n = this._seekHandler.removeURLParameters(t.responseURL);t.responseURL !== this._currentRequestURL && n !== this._currentRedirectedURL && (this._currentRedirectedURL = n, this._onURLRedirect && this._onURLRedirect(n));
              }if (t.status >= 200 && t.status <= 299) {
                if (this._waitForTotalLength) return;this._status = _.LoaderStatus.kBuffering;
              } else {
                if (this._status = _.LoaderStatus.kError, !this._onError) throw new m.RuntimeException("RangeLoader: Http code invalid, " + t.status + " " + t.statusText);this._onError(_.LoaderErrors.HTTP_STATUS_CODE_INVALID, { code: t.status, msg: t.statusText });
              }
            }
          } }, { key: "_onProgress", value: function (e) {
            if (null === this._contentLength) {
              var t = !1;if (this._waitForTotalLength) {
                this._waitForTotalLength = !1, this._totalLengthReceived = !0, t = !0;var n = e.total;this._internalAbort(), null != n & 0 !== n && (this._totalLength = n);
              }if (-1 === this._range.to ? this._contentLength = this._totalLength - this._range.from : this._contentLength = this._range.to - this._range.from + 1, t) return void this._openSubRange();this._onContentLengthKnown && this._onContentLengthKnown(this._contentLength);
            }var i = e.loaded - this._lastTimeLoaded;this._lastTimeLoaded = e.loaded, this._speedSampler.addBytes(i);
          } }, { key: "_normalizeSpeed", value: function (e) {
            var t = this._chunkSizeKBList,
                n = t.length - 1,
                i = 0,
                r = 0,
                s = n;if (e < t[0]) return t[0];for (; r <= s;) {
              if ((i = r + Math.floor((s - r) / 2)) === n || e >= t[i] && e < t[i + 1]) return t[i];t[i] < e ? r = i + 1 : s = i - 1;
            }
          } }, { key: "_onLoad", value: function (e) {
            if (this._waitForTotalLength) return void (this._waitForTotalLength = !1);this._lastTimeLoaded = 0;var t = this._speedSampler.lastSecondKBps;if (0 === t && ++this._zeroSpeedChunkCount >= 3 && (t = this._speedSampler.currentKBps), 0 !== t) {
              var n = this._normalizeSpeed(t);this._currentSpeedNormalized !== n && (this._currentSpeedNormalized = n, this._currentChunkSizeKB = n);
            }var i = e.target.response,
                r = this._range.from + this._receivedLength;this._receivedLength += i.byteLength;var s = !1;null != this._contentLength && this._receivedLength < this._contentLength ? this._openSubRange() : s = !0, this._onDataArrival && this._onDataArrival(i, r, this._receivedLength), s && (this._status = _.LoaderStatus.kComplete, this._onComplete && this._onComplete(this._range.from, this._range.from + this._receivedLength - 1));
          } }, { key: "_onXhrError", value: function (e) {
            this._status = _.LoaderStatus.kError;var t = 0,
                n = null;if (this._contentLength && this._receivedLength > 0 && this._receivedLength < this._contentLength ? (t = _.LoaderErrors.EARLY_EOF, n = { code: -1, msg: "RangeLoader meet Early-Eof" }) : (t = _.LoaderErrors.EXCEPTION, n = { code: -1, msg: e.constructor.name + " " + e.type }), !this._onError) throw new m.RuntimeException(n.msg);this._onError(t, n);
          } }, { key: "currentSpeed", get: function () {
            return this._speedSampler.lastSecondKBps;
          } }]), t;
      }(_.BaseLoader);n.default = p;
    }, { "../utils/exception.js": 40, "../utils/logger.js": 41, "./loader.js": 24, "./speed-sampler.js": 27 }], 32: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      },
          a = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          o = e("events"),
          u = i(o),
          l = e("../utils/logger.js"),
          d = i(l),
          h = e("../utils/browser.js"),
          f = i(h),
          c = e("./player-events.js"),
          _ = i(c),
          m = e("../core/transmuxer.js"),
          p = i(m),
          v = e("../core/transmuxing-events.js"),
          g = i(v),
          y = e("../core/mse-controller.js"),
          E = i(y),
          b = e("../core/mse-events.js"),
          S = i(b),
          k = e("./player-errors.js"),
          L = e("../config.js"),
          w = e("../utils/exception.js"),
          R = function () {
        function e(t, n) {
          if (r(this, e), this.TAG = "FlvPlayer", this._type = "FlvPlayer", this._emitter = new u.default(), this._config = (0, L.createDefaultConfig)(), "object" === (void 0 === n ? "undefined" : s(n)) && Object.assign(this._config, n), "flv" !== t.type.toLowerCase()) throw new w.InvalidArgumentException("FlvPlayer requires an flv MediaDataSource input!");!0 === t.isLive && (this._config.isLive = !0), this.e = { onvLoadedMetadata: this._onvLoadedMetadata.bind(this), onvSeeking: this._onvSeeking.bind(this), onvCanPlay: this._onvCanPlay.bind(this), onvStalled: this._onvStalled.bind(this), onvProgress: this._onvProgress.bind(this) }, self.performance && self.performance.now ? this._now = self.performance.now.bind(self.performance) : this._now = Date.now, this._pendingSeekTime = null, this._requestSetTime = !1, this._seekpointRecord = null, this._progressChecker = null, this._mediaDataSource = t, this._mediaElement = null, this._msectl = null, this._transmuxer = null, this._mseSourceOpened = !1, this._hasPendingLoad = !1, this._receivedCanPlay = !1, this._mediaInfo = null, this._statisticsInfo = null;var i = f.default.chrome && (f.default.version.major < 50 || 50 === f.default.version.major && f.default.version.build < 2661);this._alwaysSeekKeyframe = !!(i || f.default.msedge || f.default.msie), this._alwaysSeekKeyframe && (this._config.accurateSeek = !1);
        }return a(e, [{ key: "destroy", value: function () {
            null != this._progressChecker && (window.clearInterval(this._progressChecker), this._progressChecker = null), this._transmuxer && this.unload(), this._mediaElement && this.detachMediaElement(), this.e = null, this._mediaDataSource = null, this._emitter.removeAllListeners(), this._emitter = null;
          } }, { key: "on", value: function (e, t) {
            var n = this;e === _.default.MEDIA_INFO ? null != this._mediaInfo && Promise.resolve().then(function () {
              n._emitter.emit(_.default.MEDIA_INFO, n.mediaInfo);
            }) : e === _.default.STATISTICS_INFO && null != this._statisticsInfo && Promise.resolve().then(function () {
              n._emitter.emit(_.default.STATISTICS_INFO, n.statisticsInfo);
            }), this._emitter.addListener(e, t);
          } }, { key: "off", value: function (e, t) {
            this._emitter.removeListener(e, t);
          } }, { key: "attachMediaElement", value: function (e) {
            var t = this;if (this._mediaElement = e, e.addEventListener("loadedmetadata", this.e.onvLoadedMetadata), e.addEventListener("seeking", this.e.onvSeeking), e.addEventListener("canplay", this.e.onvCanPlay), e.addEventListener("stalled", this.e.onvStalled), e.addEventListener("progress", this.e.onvProgress), this._msectl = new E.default(this._config), this._msectl.on(S.default.UPDATE_END, this._onmseUpdateEnd.bind(this)), this._msectl.on(S.default.BUFFER_FULL, this._onmseBufferFull.bind(this)), this._msectl.on(S.default.SOURCE_OPEN, function () {
              t._mseSourceOpened = !0, t._hasPendingLoad && (t._hasPendingLoad = !1, t.load());
            }), this._msectl.on(S.default.ERROR, function (e) {
              t._emitter.emit(_.default.ERROR, k.ErrorTypes.MEDIA_ERROR, k.ErrorDetails.MEDIA_MSE_ERROR, e);
            }), this._msectl.attachMediaElement(e), null != this._pendingSeekTime) try {
              e.currentTime = this._pendingSeekTime, this._pendingSeekTime = null;
            } catch (e) {}
          } }, { key: "detachMediaElement", value: function () {
            this._mediaElement && (this._msectl.detachMediaElement(), this._mediaElement.removeEventListener("loadedmetadata", this.e.onvLoadedMetadata), this._mediaElement.removeEventListener("seeking", this.e.onvSeeking), this._mediaElement.removeEventListener("canplay", this.e.onvCanPlay), this._mediaElement.removeEventListener("stalled", this.e.onvStalled), this._mediaElement.removeEventListener("progress", this.e.onvProgress), this._mediaElement = null), this._msectl && (this._msectl.destroy(), this._msectl = null);
          } }, { key: "load", value: function () {
            var e = this;if (!this._mediaElement) throw new w.IllegalStateException("HTMLMediaElement must be attached before load()!");if (this._transmuxer) throw new w.IllegalStateException("FlvPlayer.load() has been called, please call unload() first!");if (!this._hasPendingLoad) {
              if (this._config.deferLoadAfterSourceOpen && !1 === this._mseSourceOpened) return void (this._hasPendingLoad = !0);this._mediaElement.readyState > 0 && (this._requestSetTime = !0, this._mediaElement.currentTime = 0), this._transmuxer = new p.default(this._mediaDataSource, this._config), this._transmuxer.on(g.default.INIT_SEGMENT, function (t, n) {
                e._msectl.appendInitSegment(n);
              }), this._transmuxer.on(g.default.MEDIA_SEGMENT, function (t, n) {
                if (e._msectl.appendMediaSegment(n), e._config.lazyLoad && !e._config.isLive) {
                  var i = e._mediaElement.currentTime;n.info.endDts >= 1e3 * (i + e._config.lazyLoadMaxDuration) && null == e._progressChecker && (d.default.v(e.TAG, "Maximum buffering duration exceeded, suspend transmuxing task"), e._suspendTransmuxer());
                }
              }), this._transmuxer.on(g.default.LOADING_COMPLETE, function () {
                e._msectl.endOfStream(), e._emitter.emit(_.default.LOADING_COMPLETE);
              }), this._transmuxer.on(g.default.RECOVERED_EARLY_EOF, function () {
                e._emitter.emit(_.default.RECOVERED_EARLY_EOF);
              }), this._transmuxer.on(g.default.IO_ERROR, function (t, n) {
                e._emitter.emit(_.default.ERROR, k.ErrorTypes.NETWORK_ERROR, t, n);
              }), this._transmuxer.on(g.default.DEMUX_ERROR, function (t, n) {
                e._emitter.emit(_.default.ERROR, k.ErrorTypes.MEDIA_ERROR, t, { code: -1, msg: n });
              }), this._transmuxer.on(g.default.MEDIA_INFO, function (t) {
                e._mediaInfo = t, e._emitter.emit(_.default.MEDIA_INFO, Object.assign({}, t));
              }), this._transmuxer.on(g.default.STATISTICS_INFO, function (t) {
                e._statisticsInfo = e._fillStatisticsInfo(t), e._emitter.emit(_.default.STATISTICS_INFO, Object.assign({}, e._statisticsInfo));
              }), this._transmuxer.on(g.default.RECOMMEND_SEEKPOINT, function (t) {
                e._mediaElement && !e._config.accurateSeek && (e._requestSetTime = !0, e._mediaElement.currentTime = t / 1e3);
              }), this._transmuxer.open();
            }
          } }, { key: "unload", value: function () {
            this._mediaElement && this._mediaElement.pause(), this._msectl && this._msectl.seek(0), this._transmuxer && (this._transmuxer.close(), this._transmuxer.destroy(), this._transmuxer = null);
          } }, { key: "play", value: function () {
            return this._mediaElement.play();
          } }, { key: "pause", value: function () {
            this._mediaElement.pause();
          } }, { key: "_fillStatisticsInfo", value: function (e) {
            if (e.playerType = this._type, !(this._mediaElement instanceof HTMLVideoElement)) return e;var t = !0,
                n = 0,
                i = 0;if (this._mediaElement.getVideoPlaybackQuality) {
              var r = this._mediaElement.getVideoPlaybackQuality();n = r.totalVideoFrames, i = r.droppedVideoFrames;
            } else void 0 != this._mediaElement.webkitDecodedFrameCount ? (n = this._mediaElement.webkitDecodedFrameCount, i = this._mediaElement.webkitDroppedFrameCount) : t = !1;return t && (e.decodedFrames = n, e.droppedFrames = i), e;
          } }, { key: "_onmseUpdateEnd", value: function () {
            if (this._config.lazyLoad && !this._config.isLive) {
              for (var e = this._mediaElement.buffered, t = this._mediaElement.currentTime, n = 0, i = 0; i < e.length; i++) {
                var r = e.start(i),
                    s = e.end(i);if (r <= t && t < s) {
                  r, n = s;break;
                }
              }n >= t + this._config.lazyLoadMaxDuration && null == this._progressChecker && (d.default.v(this.TAG, "Maximum buffering duration exceeded, suspend transmuxing task"), this._suspendTransmuxer());
            }
          } }, { key: "_onmseBufferFull", value: function () {
            d.default.v(this.TAG, "MSE SourceBuffer is full, suspend transmuxing task"), null == this._progressChecker && this._suspendTransmuxer();
          } }, { key: "_suspendTransmuxer", value: function () {
            this._transmuxer && (this._transmuxer.pause(), null == this._progressChecker && (this._progressChecker = window.setInterval(this._checkProgressAndResume.bind(this), 1e3)));
          } }, { key: "_checkProgressAndResume", value: function () {
            for (var e = this._mediaElement.currentTime, t = this._mediaElement.buffered, n = !1, i = 0; i < t.length; i++) {
              var r = t.start(i),
                  s = t.end(i);if (e >= r && e < s) {
                e >= s - this._config.lazyLoadRecoverDuration && (n = !0);break;
              }
            }n && (window.clearInterval(this._progressChecker), this._progressChecker = null, n && (d.default.v(this.TAG, "Continue loading from paused position"), this._transmuxer.resume()));
          } }, { key: "_isTimepointBuffered", value: function (e) {
            for (var t = this._mediaElement.buffered, n = 0; n < t.length; n++) {
              var i = t.start(n),
                  r = t.end(n);if (e >= i && e < r) return !0;
            }return !1;
          } }, { key: "_internalSeek", value: function (e) {
            var t = this._isTimepointBuffered(e),
                n = !1,
                i = 0;if (e < 1 && this._mediaElement.buffered.length > 0) {
              var r = this._mediaElement.buffered.start(0);(r < 1 && e < r || f.default.safari) && (n = !0, i = f.default.safari ? .1 : r);
            }if (n) this._requestSetTime = !0, this._mediaElement.currentTime = i;else if (t) {
              if (this._alwaysSeekKeyframe) {
                var s = this._msectl.getNearestKeyframe(Math.floor(1e3 * e));this._requestSetTime = !0, this._mediaElement.currentTime = null != s ? s.dts / 1e3 : e;
              } else this._requestSetTime = !0, this._mediaElement.currentTime = e;null != this._progressChecker && this._checkProgressAndResume();
            } else null != this._progressChecker && (window.clearInterval(this._progressChecker), this._progressChecker = null), this._msectl.seek(e), this._transmuxer.seek(Math.floor(1e3 * e)), this._config.accurateSeek && (this._requestSetTime = !0, this._mediaElement.currentTime = e);
          } }, { key: "_checkAndApplyUnbufferedSeekpoint", value: function () {
            if (this._seekpointRecord) if (this._seekpointRecord.recordTime <= this._now() - 100) {
              var e = this._mediaElement.currentTime;this._seekpointRecord = null, this._isTimepointBuffered(e) || (null != this._progressChecker && (window.clearTimeout(this._progressChecker), this._progressChecker = null), this._msectl.seek(e), this._transmuxer.seek(Math.floor(1e3 * e)), this._config.accurateSeek && (this._requestSetTime = !0, this._mediaElement.currentTime = e));
            } else window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);
          } }, { key: "_checkAndResumeStuckPlayback", value: function (e) {
            var t = this._mediaElement;if (e || !this._receivedCanPlay || t.readyState < 2) {
              var n = t.buffered;n.length > 0 && t.currentTime < n.start(0) && (d.default.w(this.TAG, "Playback seems stuck at " + t.currentTime + ", seek to " + n.start(0)), this._requestSetTime = !0, this._mediaElement.currentTime = n.start(0), this._mediaElement.removeEventListener("progress", this.e.onvProgress));
            } else this._mediaElement.removeEventListener("progress", this.e.onvProgress);
          } }, { key: "_onvLoadedMetadata", value: function (e) {
            null != this._pendingSeekTime && (this._mediaElement.currentTime = this._pendingSeekTime, this._pendingSeekTime = null);
          } }, { key: "_onvSeeking", value: function (e) {
            var t = this._mediaElement.currentTime,
                n = this._mediaElement.buffered;if (this._requestSetTime) return void (this._requestSetTime = !1);if (t < 1 && n.length > 0) {
              var i = n.start(0);if (i < 1 && t < i || f.default.safari) return this._requestSetTime = !0, void (this._mediaElement.currentTime = f.default.safari ? .1 : i);
            }if (this._isTimepointBuffered(t)) {
              if (this._alwaysSeekKeyframe) {
                var r = this._msectl.getNearestKeyframe(Math.floor(1e3 * t));null != r && (this._requestSetTime = !0, this._mediaElement.currentTime = r.dts / 1e3);
              }return void (null != this._progressChecker && this._checkProgressAndResume());
            }this._seekpointRecord = { seekPoint: t, recordTime: this._now() }, window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);
          } }, { key: "_onvCanPlay", value: function (e) {
            this._receivedCanPlay = !0, this._mediaElement.removeEventListener("canplay", this.e.onvCanPlay);
          } }, { key: "_onvStalled", value: function (e) {
            this._checkAndResumeStuckPlayback(!0);
          } }, { key: "_onvProgress", value: function (e) {
            this._checkAndResumeStuckPlayback();
          } }, { key: "type", get: function () {
            return this._type;
          } }, { key: "buffered", get: function () {
            return this._mediaElement.buffered;
          } }, { key: "duration", get: function () {
            return this._mediaElement.duration;
          } }, { key: "volume", get: function () {
            return this._mediaElement.volume;
          }, set: function (e) {
            this._mediaElement.volume = e;
          } }, { key: "muted", get: function () {
            return this._mediaElement.muted;
          }, set: function (e) {
            this._mediaElement.muted = e;
          } }, { key: "currentTime", get: function () {
            return this._mediaElement ? this._mediaElement.currentTime : 0;
          }, set: function (e) {
            this._mediaElement ? this._internalSeek(e) : this._pendingSeekTime = e;
          } }, { key: "mediaInfo", get: function () {
            return Object.assign({}, this._mediaInfo);
          } }, { key: "statisticsInfo", get: function () {
            return null == this._statisticsInfo && (this._statisticsInfo = {}), this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo), Object.assign({}, this._statisticsInfo);
          } }]), e;
      }();n.default = R;
    }, { "../config.js": 5, "../core/mse-controller.js": 9, "../core/mse-events.js": 10, "../core/transmuxer.js": 11, "../core/transmuxing-events.js": 13, "../utils/browser.js": 39, "../utils/exception.js": 40, "../utils/logger.js": 41, "./player-errors.js": 34, "./player-events.js": 35, events: 2 }], 33: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
        return typeof e;
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      },
          a = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          o = e("events"),
          u = i(o),
          l = e("./player-events.js"),
          d = i(l),
          h = e("../config.js"),
          f = e("../utils/exception.js"),
          c = function () {
        function e(t, n) {
          if (r(this, e), this.TAG = "NativePlayer", this._type = "NativePlayer", this._emitter = new u.default(), this._config = (0, h.createDefaultConfig)(), "object" === (void 0 === n ? "undefined" : s(n)) && Object.assign(this._config, n), "flv" === t.type.toLowerCase()) throw new f.InvalidArgumentException("NativePlayer does't support flv MediaDataSource input!");if (t.hasOwnProperty("segments")) throw new f.InvalidArgumentException("NativePlayer(" + t.type + ") doesn't support multipart playback!");this.e = { onvLoadedMetadata: this._onvLoadedMetadata.bind(this) }, this._pendingSeekTime = null, this._statisticsReporter = null, this._mediaDataSource = t, this._mediaElement = null;
        }return a(e, [{ key: "destroy", value: function () {
            this._mediaElement && (this.unload(), this.detachMediaElement()), this.e = null, this._mediaDataSource = null, this._emitter.removeAllListeners(), this._emitter = null;
          } }, { key: "on", value: function (e, t) {
            var n = this;e === d.default.MEDIA_INFO ? null != this._mediaElement && 0 !== this._mediaElement.readyState && Promise.resolve().then(function () {
              n._emitter.emit(d.default.MEDIA_INFO, n.mediaInfo);
            }) : e === d.default.STATISTICS_INFO && null != this._mediaElement && 0 !== this._mediaElement.readyState && Promise.resolve().then(function () {
              n._emitter.emit(d.default.STATISTICS_INFO, n.statisticsInfo);
            }), this._emitter.addListener(e, t);
          } }, { key: "off", value: function (e, t) {
            this._emitter.removeListener(e, t);
          } }, { key: "attachMediaElement", value: function (e) {
            if (this._mediaElement = e, e.addEventListener("loadedmetadata", this.e.onvLoadedMetadata), null != this._pendingSeekTime) try {
              e.currentTime = this._pendingSeekTime, this._pendingSeekTime = null;
            } catch (e) {}
          } }, { key: "detachMediaElement", value: function () {
            this._mediaElement && (this._mediaElement.src = "", this._mediaElement.removeAttribute("src"), this._mediaElement.removeEventListener("loadedmetadata", this.e.onvLoadedMetadata), this._mediaElement = null), null != this._statisticsReporter && (window.clearInterval(this._statisticsReporter), this._statisticsReporter = null);
          } }, { key: "load", value: function () {
            if (!this._mediaElement) throw new f.IllegalStateException("HTMLMediaElement must be attached before load()!");this._mediaElement.src = this._mediaDataSource.url, this._mediaElement.readyState > 0 && (this._mediaElement.currentTime = 0), this._mediaElement.preload = "auto", this._mediaElement.load(), this._statisticsReporter = window.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval);
          } }, { key: "unload", value: function () {
            this._mediaElement && (this._mediaElement.src = "", this._mediaElement.removeAttribute("src")), null != this._statisticsReporter && (window.clearInterval(this._statisticsReporter), this._statisticsReporter = null);
          } }, { key: "play", value: function () {
            return this._mediaElement.play();
          } }, { key: "pause", value: function () {
            this._mediaElement.pause();
          } }, { key: "_onvLoadedMetadata", value: function (e) {
            null != this._pendingSeekTime && (this._mediaElement.currentTime = this._pendingSeekTime, this._pendingSeekTime = null), this._emitter.emit(d.default.MEDIA_INFO, this.mediaInfo);
          } }, { key: "_reportStatisticsInfo", value: function () {
            this._emitter.emit(d.default.STATISTICS_INFO, this.statisticsInfo);
          } }, { key: "type", get: function () {
            return this._type;
          } }, { key: "buffered", get: function () {
            return this._mediaElement.buffered;
          } }, { key: "duration", get: function () {
            return this._mediaElement.duration;
          } }, { key: "volume", get: function () {
            return this._mediaElement.volume;
          }, set: function (e) {
            this._mediaElement.volume = e;
          } }, { key: "muted", get: function () {
            return this._mediaElement.muted;
          }, set: function (e) {
            this._mediaElement.muted = e;
          } }, { key: "currentTime", get: function () {
            return this._mediaElement ? this._mediaElement.currentTime : 0;
          }, set: function (e) {
            this._mediaElement ? this._mediaElement.currentTime = e : this._pendingSeekTime = e;
          } }, { key: "mediaInfo", get: function () {
            var e = this._mediaElement instanceof HTMLAudioElement ? "audio/" : "video/",
                t = { mimeType: e + this._mediaDataSource.type };return this._mediaElement && (t.duration = Math.floor(1e3 * this._mediaElement.duration), this._mediaElement instanceof HTMLVideoElement && (t.width = this._mediaElement.videoWidth, t.height = this._mediaElement.videoHeight)), t;
          } }, { key: "statisticsInfo", get: function () {
            var e = { playerType: this._type, url: this._mediaDataSource.url };if (!(this._mediaElement instanceof HTMLVideoElement)) return e;var t = !0,
                n = 0,
                i = 0;if (this._mediaElement.getVideoPlaybackQuality) {
              var r = this._mediaElement.getVideoPlaybackQuality();n = r.totalVideoFrames, i = r.droppedVideoFrames;
            } else void 0 != this._mediaElement.webkitDecodedFrameCount ? (n = this._mediaElement.webkitDecodedFrameCount, i = this._mediaElement.webkitDroppedFrameCount) : t = !1;return t && (e.decodedFrames = n, e.droppedFrames = i), e;
          } }]), e;
      }();n.default = c;
    }, { "../config.js": 5, "../utils/exception.js": 40, "./player-events.js": 35, events: 2 }], 34: [function (e, t, n) {
      "use strict";
      Object.defineProperty(n, "__esModule", { value: !0 }), n.ErrorDetails = n.ErrorTypes = void 0;var i = e("../io/loader.js"),
          r = e("../demux/demux-errors.js"),
          s = function (e) {
        return e && e.__esModule ? e : { default: e };
      }(r);n.ErrorTypes = { NETWORK_ERROR: "NetworkError", MEDIA_ERROR: "MediaError", OTHER_ERROR: "OtherError" }, n.ErrorDetails = { NETWORK_EXCEPTION: i.LoaderErrors.EXCEPTION, NETWORK_STATUS_CODE_INVALID: i.LoaderErrors.HTTP_STATUS_CODE_INVALID, NETWORK_TIMEOUT: i.LoaderErrors.CONNECTING_TIMEOUT, NETWORK_UNRECOVERABLE_EARLY_EOF: i.LoaderErrors.UNRECOVERABLE_EARLY_EOF, MEDIA_MSE_ERROR: "MediaMSEError", MEDIA_FORMAT_ERROR: s.default.FORMAT_ERROR, MEDIA_FORMAT_UNSUPPORTED: s.default.FORMAT_UNSUPPORTED, MEDIA_CODEC_UNSUPPORTED: s.default.CODEC_UNSUPPORTED };
    }, { "../demux/demux-errors.js": 16, "../io/loader.js": 24 }], 35: [function (e, t, n) {
      "use strict";
      Object.defineProperty(n, "__esModule", { value: !0 });var i = { ERROR: "error", LOADING_COMPLETE: "loading_complete", RECOVERED_EARLY_EOF: "recovered_early_eof", MEDIA_INFO: "media_info", STATISTICS_INFO: "statistics_info" };n.default = i;
    }, {}], 36: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = function () {
        function e() {
          i(this, e);
        }return r(e, null, [{ key: "getSilentFrame", value: function (e, t) {
            if ("mp4a.40.2" === e) {
              if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
            } else {
              if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            }return null;
          } }]), e;
      }();n.default = s;
    }, {}], 37: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = function () {
        function e() {
          i(this, e);
        }return r(e, null, [{ key: "init", value: function () {
            e.types = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], mvex: [], mvhd: [], sdtp: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [], smhd: [], ".mp3": [] };for (var t in e.types) e.types.hasOwnProperty(t) && (e.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);var n = e.constants = {};n.FTYP = new Uint8Array([105, 115, 111, 109, 0, 0, 0, 1, 105, 115, 111, 109, 97, 118, 99, 49]), n.STSD_PREFIX = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), n.STTS = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), n.STSC = n.STCO = n.STTS, n.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), n.HDLR_VIDEO = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), n.HDLR_AUDIO = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), n.DREF = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), n.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), n.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]);
          } }, { key: "box", value: function (e) {
            for (var t = 8, n = null, i = Array.prototype.slice.call(arguments, 1), r = i.length, s = 0; s < r; s++) t += i[s].byteLength;n = new Uint8Array(t), n[0] = t >>> 24 & 255, n[1] = t >>> 16 & 255, n[2] = t >>> 8 & 255, n[3] = 255 & t, n.set(e, 4);for (var a = 8, o = 0; o < r; o++) n.set(i[o], a), a += i[o].byteLength;return n;
          } }, { key: "generateInitSegment", value: function (t) {
            var n = e.box(e.types.ftyp, e.constants.FTYP),
                i = e.moov(t),
                r = new Uint8Array(n.byteLength + i.byteLength);return r.set(n, 0), r.set(i, n.byteLength), r;
          } }, { key: "moov", value: function (t) {
            var n = e.mvhd(t.timescale, t.duration),
                i = e.trak(t),
                r = e.mvex(t);return e.box(e.types.moov, n, i, r);
          } }, { key: "mvhd", value: function (t, n) {
            return e.box(e.types.mvhd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]));
          } }, { key: "trak", value: function (t) {
            return e.box(e.types.trak, e.tkhd(t), e.mdia(t));
          } }, { key: "tkhd", value: function (t) {
            var n = t.id,
                i = t.duration,
                r = t.presentWidth,
                s = t.presentHeight;return e.box(e.types.tkhd, new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, 0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >>> 8 & 255, 255 & r, 0, 0, s >>> 8 & 255, 255 & s, 0, 0]));
          } }, { key: "mdia", value: function (t) {
            return e.box(e.types.mdia, e.mdhd(t), e.hdlr(t), e.minf(t));
          } }, { key: "mdhd", value: function (t) {
            var n = t.timescale,
                i = t.duration;return e.box(e.types.mdhd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, 85, 196, 0, 0]));
          } }, { key: "hdlr", value: function (t) {
            var n = null;return n = "audio" === t.type ? e.constants.HDLR_AUDIO : e.constants.HDLR_VIDEO, e.box(e.types.hdlr, n);
          } }, { key: "minf", value: function (t) {
            var n = null;return n = "audio" === t.type ? e.box(e.types.smhd, e.constants.SMHD) : e.box(e.types.vmhd, e.constants.VMHD), e.box(e.types.minf, n, e.dinf(), e.stbl(t));
          } }, { key: "dinf", value: function () {
            return e.box(e.types.dinf, e.box(e.types.dref, e.constants.DREF));
          } }, { key: "stbl", value: function (t) {
            return e.box(e.types.stbl, e.stsd(t), e.box(e.types.stts, e.constants.STTS), e.box(e.types.stsc, e.constants.STSC), e.box(e.types.stsz, e.constants.STSZ), e.box(e.types.stco, e.constants.STCO));
          } }, { key: "stsd", value: function (t) {
            return "audio" === t.type ? "mp3" === t.codec ? e.box(e.types.stsd, e.constants.STSD_PREFIX, e.mp3(t)) : e.box(e.types.stsd, e.constants.STSD_PREFIX, e.mp4a(t)) : e.box(e.types.stsd, e.constants.STSD_PREFIX, e.avc1(t));
          } }, { key: "mp3", value: function (t) {
            var n = t.channelCount,
                i = t.audioSampleRate,
                r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, n, 0, 16, 0, 0, 0, 0, i >>> 8 & 255, 255 & i, 0, 0]);return e.box(e.types[".mp3"], r);
          } }, { key: "mp4a", value: function (t) {
            var n = t.channelCount,
                i = t.audioSampleRate,
                r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, n, 0, 16, 0, 0, 0, 0, i >>> 8 & 255, 255 & i, 0, 0]);return e.box(e.types.mp4a, r, e.esds(t));
          } }, { key: "esds", value: function (t) {
            var n = t.config || [],
                i = n.length,
                r = new Uint8Array([0, 0, 0, 0, 3, 23 + i, 0, 1, 0, 4, 15 + i, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([i]).concat(n).concat([6, 1, 2]));return e.box(e.types.esds, r);
          } }, { key: "avc1", value: function (t) {
            var n = t.avcc,
                i = t.codecWidth,
                r = t.codecHeight,
                s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, i >>> 8 & 255, 255 & i, r >>> 8 & 255, 255 & r, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 10, 120, 113, 113, 47, 102, 108, 118, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 255, 255]);return e.box(e.types.avc1, s, e.box(e.types.avcC, n));
          } }, { key: "mvex", value: function (t) {
            return e.box(e.types.mvex, e.trex(t));
          } }, { key: "trex", value: function (t) {
            var n = t.id,
                i = new Uint8Array([0, 0, 0, 0, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]);return e.box(e.types.trex, i);
          } }, { key: "moof", value: function (t, n) {
            return e.box(e.types.moof, e.mfhd(t.sequenceNumber), e.traf(t, n));
          } }, { key: "mfhd", value: function (t) {
            var n = new Uint8Array([0, 0, 0, 0, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t]);return e.box(e.types.mfhd, n);
          } }, { key: "traf", value: function (t, n) {
            var i = t.id,
                r = e.box(e.types.tfhd, new Uint8Array([0, 0, 0, 0, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i])),
                s = e.box(e.types.tfdt, new Uint8Array([0, 0, 0, 0, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n])),
                a = e.sdtp(t),
                o = e.trun(t, a.byteLength + 16 + 16 + 8 + 16 + 8 + 8);return e.box(e.types.traf, r, s, o, a);
          } }, { key: "sdtp", value: function (t) {
            for (var n = t.samples || [], i = n.length, r = new Uint8Array(4 + i), s = 0; s < i; s++) {
              var a = n[s].flags;r[s + 4] = a.isLeading << 6 | a.dependsOn << 4 | a.isDependedOn << 2 | a.hasRedundancy;
            }return e.box(e.types.sdtp, r);
          } }, { key: "trun", value: function (t, n) {
            var i = t.samples || [],
                r = i.length,
                s = 12 + 16 * r,
                a = new Uint8Array(s);n += 8 + s, a.set([0, 0, 15, 1, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n], 0);for (var o = 0; o < r; o++) {
              var u = i[o].duration,
                  l = i[o].size,
                  d = i[o].flags,
                  h = i[o].cts;a.set([u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l, d.isLeading << 2 | d.dependsOn, d.isDependedOn << 6 | d.hasRedundancy << 4 | d.isNonSync, 0, 0, h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, 255 & h], 12 + 16 * o);
            }return e.box(e.types.trun, a);
          } }, { key: "mdat", value: function (t) {
            return e.box(e.types.mdat, t);
          } }]), e;
      }();s.init(), n.default = s;
    }, {}], 38: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var s = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          a = e("../utils/logger.js"),
          o = i(a),
          u = e("./mp4-generator.js"),
          l = i(u),
          d = e("./aac-silent.js"),
          h = i(d),
          f = e("../utils/browser.js"),
          c = i(f),
          _ = e("../core/media-segment-info.js"),
          m = e("../utils/exception.js"),
          p = function () {
        function e(t) {
          r(this, e), this.TAG = "MP4Remuxer", this._config = t, this._isLive = !0 === t.isLive, this._dtsBase = -1, this._dtsBaseInited = !1, this._audioDtsBase = 1 / 0, this._videoDtsBase = 1 / 0, this._audioNextDts = void 0, this._videoNextDts = void 0, this._audioMeta = null, this._videoMeta = null, this._audioSegmentInfoList = new _.MediaSegmentInfoList("audio"), this._videoSegmentInfoList = new _.MediaSegmentInfoList("video"), this._onInitSegment = null, this._onMediaSegment = null, this._forceFirstIDR = !(!c.default.chrome || !(c.default.version.major < 50 || 50 === c.default.version.major && c.default.version.build < 2661)), this._fillSilentAfterSeek = c.default.msedge || c.default.msie, this._mp3UseMpegAudio = !c.default.firefox, this._fillAudioTimestampGap = this._config.fixAudioTimestampGap;
        }return s(e, [{ key: "destroy", value: function () {
            this._dtsBase = -1, this._dtsBaseInited = !1, this._audioMeta = null, this._videoMeta = null, this._audioSegmentInfoList.clear(), this._audioSegmentInfoList = null, this._videoSegmentInfoList.clear(), this._videoSegmentInfoList = null, this._onInitSegment = null, this._onMediaSegment = null;
          } }, { key: "bindDataSource", value: function (e) {
            return e.onDataAvailable = this.remux.bind(this), e.onTrackMetadata = this._onTrackMetadataReceived.bind(this), this;
          } }, { key: "insertDiscontinuity", value: function () {
            this._audioNextDts = this._videoNextDts = void 0;
          } }, { key: "seek", value: function (e) {
            this._videoSegmentInfoList.clear(), this._audioSegmentInfoList.clear();
          } }, { key: "remux", value: function (e, t) {
            if (!this._onMediaSegment) throw new m.IllegalStateException("MP4Remuxer: onMediaSegment callback must be specificed!");this._dtsBaseInited || this._calculateDtsBase(e, t), this._remuxVideo(t), this._remuxAudio(e);
          } }, { key: "_onTrackMetadataReceived", value: function (e, t) {
            var n = null,
                i = "mp4",
                r = t.codec;if ("audio" === e) this._audioMeta = t, "mp3" === t.codec && this._mp3UseMpegAudio ? (i = "mpeg", r = "", n = new Uint8Array()) : n = l.default.generateInitSegment(t);else {
              if ("video" !== e) return;this._videoMeta = t, n = l.default.generateInitSegment(t);
            }if (!this._onInitSegment) throw new m.IllegalStateException("MP4Remuxer: onInitSegment callback must be specified!");this._onInitSegment(e, { type: e, data: n.buffer, codec: r, container: e + "/" + i, mediaDuration: t.duration });
          } }, { key: "_calculateDtsBase", value: function (e, t) {
            this._dtsBaseInited || (e.samples && e.samples.length && (this._audioDtsBase = e.samples[0].dts), t.samples && t.samples.length && (this._videoDtsBase = t.samples[0].dts), this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase), this._dtsBaseInited = !0);
          } }, { key: "_remuxAudio", value: function (e) {
            if (null != this._audioMeta) {
              var t = e,
                  n = t.samples,
                  i = void 0,
                  r = -1,
                  s = -1,
                  a = this._audioMeta.refSampleDuration,
                  u = "mp3" === this._audioMeta.codec && this._mp3UseMpegAudio,
                  d = this._dtsBaseInited && void 0 === this._audioNextDts,
                  f = !1;if (n && 0 !== n.length) {
                var m = 0,
                    p = null,
                    v = 0;u ? (m = 0, v = t.length) : (m = 8, v = 8 + t.length);var g = n[0].dts - this._dtsBase;if (this._audioNextDts) i = g - this._audioNextDts;else if (this._audioSegmentInfoList.isEmpty()) i = 0, this._fillSilentAfterSeek && !this._videoSegmentInfoList.isEmpty() && "mp3" !== this._audioMeta.originalCodec && (f = !0);else {
                  var y = this._audioSegmentInfoList.getLastSampleBefore(g);if (null != y) {
                    var E = g - (y.originalDts + y.duration);E <= 3 && (E = 0);var b = y.dts + y.duration + E;i = g - b;
                  } else i = 0;
                }if (f) {
                  var S = g - i,
                      k = this._videoSegmentInfoList.getLastSegmentBefore(g);if (null != k && k.beginDts < S) {
                    var L = h.default.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);if (L) {
                      var w = k.beginDts,
                          R = S - k.beginDts;o.default.v(this.TAG, "InsertPrefixSilentAudio: dts: " + w + ", duration: " + R), n.unshift({ unit: L, dts: w, pts: w }), v += L.byteLength;
                    }
                  } else f = !1;
                }for (var A = [], O = 0; O < n.length; O++) {
                  var T = n[O],
                      C = T.unit,
                      I = T.dts - this._dtsBase,
                      x = I - i;-1 === r && (r = x);var M = 0;if (O !== n.length - 1) {
                    M = n[O + 1].dts - this._dtsBase - i - x;
                  } else M = A.length >= 1 ? A[A.length - 1].duration : Math.floor(a);var D = !1,
                      B = null;if (M > 1.5 * a && "mp3" !== this._audioMeta.codec && this._fillAudioTimestampGap && !c.default.safari) {
                    D = !0;var j = Math.abs(M - a),
                        P = Math.ceil(j / a),
                        U = x + a;o.default.w(this.TAG, "Large audio timestamp gap detected, may cause AV sync to drift. Silent frames will be generated to avoid unsync.\ndts: " + (x + M) + " ms, expected: " + (x + Math.round(a)) + " ms, delta: " + Math.round(j) + " ms, generate: " + P + " frames");var N = h.default.getSilentFrame(this._audioMeta.originalCodec, this._audioMeta.channelCount);null == N && (o.default.w(this.TAG, "Unable to generate silent frame for " + this._audioMeta.originalCodec + " with " + this._audioMeta.channelCount + " channels, repeat last frame"), N = C), B = [];for (var F = 0; F < P; F++) {
                      var G = Math.round(U);if (B.length > 0) {
                        var V = B[B.length - 1];V.duration = G - V.dts;
                      }var z = { dts: G, pts: G, cts: 0, unit: N, size: N.byteLength, duration: 0, originalDts: I, flags: { isLeading: 0, dependsOn: 1, isDependedOn: 0, hasRedundancy: 0 } };B.push(z), v += C.byteLength, U += a;
                    }var H = B[B.length - 1];H.duration = x + M - H.dts, M = Math.round(a);
                  }A.push({ dts: x, pts: x, cts: 0, unit: T.unit, size: T.unit.byteLength, duration: M, originalDts: I, flags: { isLeading: 0, dependsOn: 1, isDependedOn: 0, hasRedundancy: 0 } }), D && A.push.apply(A, B);
                }u ? p = new Uint8Array(v) : (p = new Uint8Array(v), p[0] = v >>> 24 & 255, p[1] = v >>> 16 & 255, p[2] = v >>> 8 & 255, p[3] = 255 & v, p.set(l.default.types.mdat, 4));for (var K = 0; K < A.length; K++) {
                  var q = A[K].unit;p.set(q, m), m += q.byteLength;
                }var W = A[A.length - 1];s = W.dts + W.duration, this._audioNextDts = s;var X = new _.MediaSegmentInfo();X.beginDts = r, X.endDts = s, X.beginPts = r, X.endPts = s, X.originalBeginDts = A[0].originalDts, X.originalEndDts = W.originalDts + W.duration, X.firstSample = new _.SampleInfo(A[0].dts, A[0].pts, A[0].duration, A[0].originalDts, !1), X.lastSample = new _.SampleInfo(W.dts, W.pts, W.duration, W.originalDts, !1), this._isLive || this._audioSegmentInfoList.append(X), t.samples = A, t.sequenceNumber++;var Y = null;Y = u ? new Uint8Array() : l.default.moof(t, r), t.samples = [], t.length = 0;var Z = { type: "audio", data: this._mergeBoxes(Y, p).buffer, sampleCount: A.length, info: X };u && d && (Z.timestampOffset = r), this._onMediaSegment("audio", Z);
              }
            }
          } }, { key: "_remuxVideo", value: function (e) {
            if (null != this._videoMeta) {
              var t = e,
                  n = t.samples,
                  i = void 0,
                  r = -1,
                  s = -1,
                  a = -1,
                  o = -1;if (n && 0 !== n.length) {
                var u = 8,
                    d = 8 + e.length,
                    h = new Uint8Array(d);h[0] = d >>> 24 & 255, h[1] = d >>> 16 & 255, h[2] = d >>> 8 & 255, h[3] = 255 & d, h.set(l.default.types.mdat, 4);var f = n[0].dts - this._dtsBase;if (this._videoNextDts) i = f - this._videoNextDts;else if (this._videoSegmentInfoList.isEmpty()) i = 0;else {
                  var c = this._videoSegmentInfoList.getLastSampleBefore(f);if (null != c) {
                    var m = f - (c.originalDts + c.duration);m <= 3 && (m = 0);var p = c.dts + c.duration + m;i = f - p;
                  } else i = 0;
                }for (var v = new _.MediaSegmentInfo(), g = [], y = 0; y < n.length; y++) {
                  var E = n[y],
                      b = E.dts - this._dtsBase,
                      S = E.isKeyframe,
                      k = b - i,
                      L = E.cts,
                      w = k + L;-1 === r && (r = k, a = w);var R = 0;if (y !== n.length - 1) {
                    R = n[y + 1].dts - this._dtsBase - i - k;
                  } else R = g.length >= 1 ? g[g.length - 1].duration : Math.floor(this._videoMeta.refSampleDuration);if (S) {
                    var A = new _.SampleInfo(k, w, R, E.dts, !0);A.fileposition = E.fileposition, v.appendSyncPoint(A);
                  }g.push({ dts: k, pts: w, cts: L, units: E.units, size: E.length, isKeyframe: S, duration: R, originalDts: b, flags: { isLeading: 0, dependsOn: S ? 2 : 1, isDependedOn: S ? 1 : 0, hasRedundancy: 0, isNonSync: S ? 0 : 1 } });
                }for (var O = 0; O < g.length; O++) for (var T = g[O].units; T.length;) {
                  var C = T.shift(),
                      I = C.data;h.set(I, u), u += I.byteLength;
                }var x = g[g.length - 1];if (s = x.dts + x.duration, o = x.pts + x.duration, this._videoNextDts = s, v.beginDts = r, v.endDts = s, v.beginPts = a, v.endPts = o, v.originalBeginDts = g[0].originalDts, v.originalEndDts = x.originalDts + x.duration, v.firstSample = new _.SampleInfo(g[0].dts, g[0].pts, g[0].duration, g[0].originalDts, g[0].isKeyframe), v.lastSample = new _.SampleInfo(x.dts, x.pts, x.duration, x.originalDts, x.isKeyframe), this._isLive || this._videoSegmentInfoList.append(v), t.samples = g, t.sequenceNumber++, this._forceFirstIDR) {
                  var M = g[0].flags;M.dependsOn = 2, M.isNonSync = 0;
                }var D = l.default.moof(t, r);t.samples = [], t.length = 0, this._onMediaSegment("video", { type: "video", data: this._mergeBoxes(D, h).buffer, sampleCount: g.length, info: v });
              }
            }
          } }, { key: "_mergeBoxes", value: function (e, t) {
            var n = new Uint8Array(e.byteLength + t.byteLength);return n.set(e, 0), n.set(t, e.byteLength), n;
          } }, { key: "onInitSegment", get: function () {
            return this._onInitSegment;
          }, set: function (e) {
            this._onInitSegment = e;
          } }, { key: "onMediaSegment", get: function () {
            return this._onMediaSegment;
          }, set: function (e) {
            this._onMediaSegment = e;
          } }]), e;
      }();n.default = p;
    }, { "../core/media-segment-info.js": 8, "../utils/browser.js": 39, "../utils/exception.js": 40, "../utils/logger.js": 41, "./aac-silent.js": 36, "./mp4-generator.js": 37 }], 39: [function (e, t, n) {
      "use strict";
      Object.defineProperty(n, "__esModule", { value: !0 });var i = {};!function () {
        var e = self.navigator.userAgent.toLowerCase(),
            t = /(edge)\/([\w.]+)/.exec(e) || /(opr)[\/]([\w.]+)/.exec(e) || /(chrome)[ \/]([\w.]+)/.exec(e) || /(iemobile)[\/]([\w.]+)/.exec(e) || /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || e.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(e) || e.indexOf("compatible") < 0 && /(firefox)[ \/]([\w.]+)/.exec(e) || [],
            n = /(ipad)/.exec(e) || /(ipod)/.exec(e) || /(windows phone)/.exec(e) || /(iphone)/.exec(e) || /(kindle)/.exec(e) || /(android)/.exec(e) || /(windows)/.exec(e) || /(mac)/.exec(e) || /(linux)/.exec(e) || /(cros)/.exec(e) || [],
            r = { browser: t[5] || t[3] || t[1] || "", version: t[2] || t[4] || "0", majorVersion: t[4] || t[2] || "0", platform: n[0] || "" },
            s = {};if (r.browser) {
          s[r.browser] = !0;var a = r.majorVersion.split(".");s.version = { major: parseInt(r.majorVersion, 10), string: r.version }, a.length > 1 && (s.version.minor = parseInt(a[1], 10)), a.length > 2 && (s.version.build = parseInt(a[2], 10));
        }r.platform && (s[r.platform] = !0), (s.chrome || s.opr || s.safari) && (s.webkit = !0), (s.rv || s.iemobile) && (s.rv && delete s.rv, r.browser = "msie", s.msie = !0), s.edge && (delete s.edge, r.browser = "msedge", s.msedge = !0), s.opr && (r.browser = "opera", s.opera = !0), s.safari && s.android && (r.browser = "android", s.android = !0), s.name = r.browser, s.platform = r.platform;for (var o in i) i.hasOwnProperty(o) && delete i[o];Object.assign(i, s);
      }(), n.default = i;
    }, {}], 40: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t || "object" != typeof t && "function" != typeof t ? e : t;
      }function r(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
      }function s(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var a = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          o = n.RuntimeException = function () {
        function e(t) {
          s(this, e), this._message = t;
        }return a(e, [{ key: "toString", value: function () {
            return this.name + ": " + this.message;
          } }, { key: "name", get: function () {
            return "RuntimeException";
          } }, { key: "message", get: function () {
            return this._message;
          } }]), e;
      }();n.IllegalStateException = function (e) {
        function t(e) {
          return s(this, t), i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
        }return r(t, e), a(t, [{ key: "name", get: function () {
            return "IllegalStateException";
          } }]), t;
      }(o), n.InvalidArgumentException = function (e) {
        function t(e) {
          return s(this, t), i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
        }return r(t, e), a(t, [{ key: "name", get: function () {
            return "InvalidArgumentException";
          } }]), t;
      }(o), n.NotImplementedException = function (e) {
        function t(e) {
          return s(this, t), i(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
        }return r(t, e), a(t, [{ key: "name", get: function () {
            return "NotImplementedException";
          } }]), t;
      }(o);
    }, {}], 41: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = e("events"),
          a = function (e) {
        return e && e.__esModule ? e : { default: e };
      }(s),
          o = function () {
        function e() {
          i(this, e);
        }return r(e, null, [{ key: "e", value: function (t, n) {
            t && !e.FORCE_GLOBAL_TAG || (t = e.GLOBAL_TAG);var i = "[" + t + "] > " + n;e.ENABLE_CALLBACK && e.emitter.emit("log", "error", i), e.ENABLE_ERROR && (console.error ? console.error(i) : console.warn ? console.warn(i) : console.log(i));
          } }, { key: "i", value: function (t, n) {
            t && !e.FORCE_GLOBAL_TAG || (t = e.GLOBAL_TAG);var i = "[" + t + "] > " + n;e.ENABLE_CALLBACK && e.emitter.emit("log", "info", i), e.ENABLE_INFO && (console.info ? console.info(i) : console.log(i));
          } }, { key: "w", value: function (t, n) {
            t && !e.FORCE_GLOBAL_TAG || (t = e.GLOBAL_TAG);var i = "[" + t + "] > " + n;e.ENABLE_CALLBACK && e.emitter.emit("log", "warn", i), e.ENABLE_WARN && (console.warn ? console.warn(i) : console.log(i));
          } }, { key: "d", value: function (t, n) {
            t && !e.FORCE_GLOBAL_TAG || (t = e.GLOBAL_TAG);var i = "[" + t + "] > " + n;e.ENABLE_CALLBACK && e.emitter.emit("log", "debug", i), e.ENABLE_DEBUG && (console.debug ? console.debug(i) : console.log(i));
          } }, { key: "v", value: function (t, n) {
            t && !e.FORCE_GLOBAL_TAG || (t = e.GLOBAL_TAG);var i = "[" + t + "] > " + n;e.ENABLE_CALLBACK && e.emitter.emit("log", "verbose", i), e.ENABLE_VERBOSE && console.log(i);
          } }]), e;
      }();o.GLOBAL_TAG = "flv.js", o.FORCE_GLOBAL_TAG = !1, o.ENABLE_ERROR = !0, o.ENABLE_INFO = !0, o.ENABLE_WARN = !0, o.ENABLE_DEBUG = !0, o.ENABLE_VERBOSE = !0, o.ENABLE_CALLBACK = !1, o.emitter = new a.default(), n.default = o;
    }, { events: 2 }], 42: [function (e, t, n) {
      "use strict";
      function i(e) {
        return e && e.__esModule ? e : { default: e };
      }function r(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var s = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          a = e("events"),
          o = i(a),
          u = e("./logger.js"),
          l = i(u),
          d = function () {
        function e() {
          r(this, e);
        }return s(e, null, [{ key: "getConfig", value: function () {
            return { globalTag: l.default.GLOBAL_TAG, forceGlobalTag: l.default.FORCE_GLOBAL_TAG, enableVerbose: l.default.ENABLE_VERBOSE, enableDebug: l.default.ENABLE_DEBUG, enableInfo: l.default.ENABLE_INFO, enableWarn: l.default.ENABLE_WARN, enableError: l.default.ENABLE_ERROR, enableCallback: l.default.ENABLE_CALLBACK };
          } }, { key: "applyConfig", value: function (e) {
            l.default.GLOBAL_TAG = e.globalTag, l.default.FORCE_GLOBAL_TAG = e.forceGlobalTag, l.default.ENABLE_VERBOSE = e.enableVerbose, l.default.ENABLE_DEBUG = e.enableDebug, l.default.ENABLE_INFO = e.enableInfo, l.default.ENABLE_WARN = e.enableWarn, l.default.ENABLE_ERROR = e.enableError, l.default.ENABLE_CALLBACK = e.enableCallback;
          } }, { key: "_notifyChange", value: function () {
            var t = e.emitter;if (t.listenerCount("change") > 0) {
              var n = e.getConfig();t.emit("change", n);
            }
          } }, { key: "registerListener", value: function (t) {
            e.emitter.addListener("change", t);
          } }, { key: "removeListener", value: function (t) {
            e.emitter.removeListener("change", t);
          } }, { key: "addLogListener", value: function (t) {
            l.default.emitter.addListener("log", t), l.default.emitter.listenerCount("log") > 0 && (l.default.ENABLE_CALLBACK = !0, e._notifyChange());
          } }, { key: "removeLogListener", value: function (t) {
            l.default.emitter.removeListener("log", t), 0 === l.default.emitter.listenerCount("log") && (l.default.ENABLE_CALLBACK = !1, e._notifyChange());
          } }, { key: "forceGlobalTag", get: function () {
            return l.default.FORCE_GLOBAL_TAG;
          }, set: function (t) {
            l.default.FORCE_GLOBAL_TAG = t, e._notifyChange();
          } }, { key: "globalTag", get: function () {
            return l.default.GLOBAL_TAG;
          }, set: function (t) {
            l.default.GLOBAL_TAG = t, e._notifyChange();
          } }, { key: "enableAll", get: function () {
            return l.default.ENABLE_VERBOSE && l.default.ENABLE_DEBUG && l.default.ENABLE_INFO && l.default.ENABLE_WARN && l.default.ENABLE_ERROR;
          }, set: function (t) {
            l.default.ENABLE_VERBOSE = t, l.default.ENABLE_DEBUG = t, l.default.ENABLE_INFO = t, l.default.ENABLE_WARN = t, l.default.ENABLE_ERROR = t, e._notifyChange();
          } }, { key: "enableDebug", get: function () {
            return l.default.ENABLE_DEBUG;
          }, set: function (t) {
            l.default.ENABLE_DEBUG = t, e._notifyChange();
          } }, { key: "enableVerbose", get: function () {
            return l.default.ENABLE_VERBOSE;
          }, set: function (t) {
            l.default.ENABLE_VERBOSE = t, e._notifyChange();
          } }, { key: "enableInfo", get: function () {
            return l.default.ENABLE_INFO;
          }, set: function (t) {
            l.default.ENABLE_INFO = t, e._notifyChange();
          } }, { key: "enableWarn", get: function () {
            return l.default.ENABLE_WARN;
          }, set: function (t) {
            l.default.ENABLE_WARN = t, e._notifyChange();
          } }, { key: "enableError", get: function () {
            return l.default.ENABLE_ERROR;
          }, set: function (t) {
            l.default.ENABLE_ERROR = t, e._notifyChange();
          } }]), e;
      }();d.emitter = new o.default(), n.default = d;
    }, { "./logger.js": 41, events: 2 }], 43: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }Object.defineProperty(n, "__esModule", { value: !0 });var r = function () {
        function e(e, t) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n];i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
          }
        }return function (t, n, i) {
          return n && e(t.prototype, n), i && e(t, i), t;
        };
      }(),
          s = function () {
        function t() {
          i(this, t);
        }return r(t, null, [{ key: "install", value: function () {
            Object.setPrototypeOf = Object.setPrototypeOf || function (e, t) {
              return e.__proto__ = t, e;
            }, Object.assign = Object.assign || function (e) {
              if (void 0 === e || null === e) throw new TypeError("Cannot convert undefined or null to object");for (var t = Object(e), n = 1; n < arguments.length; n++) {
                var i = arguments[n];if (void 0 !== i && null !== i) for (var r in i) i.hasOwnProperty(r) && (t[r] = i[r]);
              }return t;
            }, "function" != typeof self.Promise && e("es6-promise").polyfill();
          } }]), t;
      }();s.install(), n.default = s;
    }, { "es6-promise": 1 }], 44: [function (e, t, n) {
      "use strict";
      function i(e, t, n) {
        var i = e;if (t + n < i.length) {
          for (; n--;) if (128 != (192 & i[++t])) return !1;return !0;
        }return !1;
      }function r(e) {
        for (var t = [], n = e, r = 0, s = e.length; r < s;) if (n[r] < 128) t.push(String.fromCharCode(n[r])), ++r;else {
          if (n[r] < 192) ;else if (n[r] < 224) {
            if (i(n, r, 1)) {
              var a = (31 & n[r]) << 6 | 63 & n[r + 1];if (a >= 128) {
                t.push(String.fromCharCode(65535 & a)), r += 2;continue;
              }
            }
          } else if (n[r] < 240) {
            if (i(n, r, 2)) {
              var o = (15 & n[r]) << 12 | (63 & n[r + 1]) << 6 | 63 & n[r + 2];if (o >= 2048 && 55296 != (63488 & o)) {
                t.push(String.fromCharCode(65535 & o)), r += 3;continue;
              }
            }
          } else if (n[r] < 248 && i(n, r, 3)) {
            var u = (7 & n[r]) << 18 | (63 & n[r + 1]) << 12 | (63 & n[r + 2]) << 6 | 63 & n[r + 3];if (u > 65536 && u < 1114112) {
              u -= 65536, t.push(String.fromCharCode(u >>> 10 | 55296)), t.push(String.fromCharCode(1023 & u | 56320)), r += 4;continue;
            }
          }t.push(String.fromCharCode(65533)), ++r;
        }return t.join("");
      }Object.defineProperty(n, "__esModule", { value: !0 }), n.default = r;
    }, {}] }, {}, [21])(21);
});
//# sourceMappingURL=flv.min.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(54),
  /* template */
  __webpack_require__(72),
  /* styles */
  null,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "D:\\newtest\\6.20\\bilibili-live\\app\\components\\routes\\livehome.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] livehome.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7ba87df1", Component.options)
  } else {
    hotAPI.reload("data-v-7ba87df1", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__liveheader_vue__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__liveheader_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__liveheader_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__liveswipe_vue__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__liveswipe_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__liveswipe_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__livelist_vue__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__livelist_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__livelist_vue__);
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
	components: {
		liveheader: __WEBPACK_IMPORTED_MODULE_0__liveheader_vue___default.a,
		liveswipe: __WEBPACK_IMPORTED_MODULE_1__liveswipe_vue___default.a,
		livelist: __WEBPACK_IMPORTED_MODULE_2__livelist_vue___default.a
	}
});

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(56);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("458c84b0", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/_css-loader@0.28.4@css-loader/index.js!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-620466f0\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/selector.js?type=styles&index=0!./liveheader.vue", function() {
     var newContent = require("!!../../node_modules/_css-loader@0.28.4@css-loader/index.js!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-620466f0\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/selector.js?type=styles&index=0!./liveheader.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)(undefined);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n\n\n\n\n\n", ""]);

// exports


/***/ }),
/* 57 */
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] });
    } else {
      newStyles[id].parts.push(part);
    }
  }
  return styles;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _vm._m(0)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "logo-bar f-clear"
  }, [_c('a', {
    staticClass: "f-left bg-contain logo",
    attrs: {
      "href": "/index"
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "f-right link"
  }, [_c('span', {
    staticClass: "area-info",
    staticStyle: {
      "display": "none"
    }
  }, [_c('a', {
    staticClass: "bili-link",
    attrs: {
      "href": "#"
    }
  }, [_vm._v("")]), _vm._v(" "), _c('a', {
    staticClass: "bili-link"
  })])])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-620466f0", module.exports)
  }
}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(60)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(62),
  /* template */
  __webpack_require__(66),
  /* styles */
  injectStyle,
  /* scopeId */
  "data-v-142ab68f",
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "D:\\newtest\\6.20\\bilibili-live\\app\\components\\liveswipe.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] liveswipe.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-142ab68f", Component.options)
  } else {
    hotAPI.reload("data-v-142ab68f", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(61);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("2887d65e", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/_css-loader@0.28.4@css-loader/index.js!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-142ab68f\",\"scoped\":true,\"hasInlineConfig\":false}!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/selector.js?type=styles&index=0!./liveswipe.vue", function() {
     var newContent = require("!!../../node_modules/_css-loader@0.28.4@css-loader/index.js!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-142ab68f\",\"scoped\":true,\"hasInlineConfig\":false}!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/selector.js?type=styles&index=0!./liveswipe.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)(undefined);
// imports


// module
exports.push([module.i, "\nimg[data-v-142ab68f]{\n\t\twidth: 100%;\n\t\theight: 100%;\n}\n.swiper-container[data-v-142ab68f] {\n    \n            padding-top: 32px;\n}\n", ""]);

// exports


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_swiper__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue_awesome_swiper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue_awesome_swiper__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ __webpack_exports__["default"] = ({
	data() {
		return {
			imgs: [{
				id: 1,
				src: __webpack_require__(63)
			}, {
				id: 2,
				src: __webpack_require__(64)
			}, {
				id: 3,
				src: __webpack_require__(65)
			}],
			swiperOption: {
				autoplay: 3000
			}
		};
	},
	computed: {
		livebanner() {
			return this.$store.state.livebanner;
		}
	},
	methods: {
		load() {
			this.$store.dispatch("setLive");
		},
		loadMore() {
			this.$store.state.limit = 10;
		}
	},
	mounted() {
		this.load();
		console.log(this.$http);
	}
});

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = "data:image/jpeg;base64,/9j/4QlQaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzEzOCA3OS4xNTk4MjQsIDIwMTYvMDkvMTQtMDE6MDk6MDEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiLz4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+0ALFBob3Rvc2hvcCAzLjAAOEJJTQQlAAAAAAAQ1B2M2Y8AsgTpgAmY7PhCfv/bAIQAAQEBAQEBAQEBAQIBAQECAgIBAQICAgICAgICAgMCAwMDAwIDAwQEBAQEAwUFBQUFBQcHBwcHCAgICAgICAgICAEBAQECAgIFAwMFBwUEBQcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI/90ABAB4/+4ADkFkb2JlAGTAAAAAAf/AABEIASwDwAMAEQABEQECEQH/xADzAAABBAIDAQEAAAAAAAAAAAAIBgcJCgQFAAIDAQsBAAAHAQEBAQAAAAAAAAAAAAECAwQFBgcACAkKEAABBAECBAMEBQcHCAMLAhcBAgMEBQYHEQAIEiEJ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"

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABQAAD/4QMxaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzEzOCA3OS4xNTk4MjQsIDIwMTYvMDkvMTQtMDE6MDk6MDEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE3IChNYWNpbnRvc2gpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjQ0MDkzMUUyNjkyNzExRTdCQ0E1OUQwNDFENzdEMEY4IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjQ0MDkzMUUzNjkyNzExRTdCQ0E1OUQwNDFENzdEMEY4Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NDQwOTMxRTA2OTI3MTFFN0JDQTU5RDA0MUQ3N0QwRjgiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NDQwOTMxRTE2OTI3MTFFN0JDQTU5RDA0MUQ3N0QwRjgiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7/7gAOQWRvYmUAZMAAAAAB/9sAhAACAgICAgICAgICAwIC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"

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = "data:image/jpeg;base64,/9j/4QlQaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzEzOCA3OS4xNTk4MjQsIDIwMTYvMDkvMTQtMDE6MDk6MDEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiLz4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+0ALFBob3Rvc2hvcCAzLjAAOEJJTQQlAAAAAAAQ1B2M2Y8AsgTpgAmY7PhCfv/bAIQAAgICAgICAgICAgMCAgIDBAMCAgMEBAQEBAQEBAYEBQUFBQQGBgcHBwcHBgkJCgoJCQwMDAwMDAwMDAwMDAwMDAECAwMFBAUJBgYJDQoICg0PDg4ODg8PDAwMDAwPDwwMDAwMDA8MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/90ABABQ/+4ADkFkb2JlAGTAAAAAAf/AABEIAMgCgAMAEQABEQECEQH/xADRAAABBAMBAQAAAAAAAAAAAAAHAAUGCAIDBAEJAQAABgMBAAAAAAAAAAAAAAAAAwQFBgcBAggJEAABAwMDAgQDBQQFCAUKBwEBAgMEBQYRABIhBzETIkFR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"

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('swiper', {
    ref: "mySwiper",
    attrs: {
      "options": _vm.swiperOption
    }
  }, [_vm._l((_vm.imgs), function(i) {
    return _c('swiper-slide', {
      key: i.id
    }, [_c('img', {
      attrs: {
        "src": i.src
      }
    })])
  }), _vm._v(" "), _c('div', {
    staticClass: "swiper-pagination",
    slot: "pagination"
  })], 2)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-142ab68f", module.exports)
  }
}

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(68)
}
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(70),
  /* template */
  __webpack_require__(71),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "D:\\newtest\\6.20\\bilibili-live\\app\\components\\livelist.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] livelist.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7f6246d9", Component.options)
  } else {
    hotAPI.reload("data-v-7f6246d9", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(69);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("26a1081f", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/_css-loader@0.28.4@css-loader/index.js!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-7f6246d9\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/selector.js?type=styles&index=0!./livelist.vue", function() {
     var newContent = require("!!../../node_modules/_css-loader@0.28.4@css-loader/index.js!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-7f6246d9\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/_vue-loader@12.2.2@vue-loader/lib/selector.js?type=styles&index=0!./livelist.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(2)(undefined);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*.live-main,.rooms,.right-arrow,.icon {\n    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAGXRFW5qiheyJ2i02Zpi6EjvgXX+SC/b+n+kt88LHT0nykd6ZwIMAD99jKUhR5YjAAAAAElFTkSuQmCC);\n    background-position: 100%;\n    background-repeat: no-repeat;\n    background-size: contain;\n    padding-right: .666666666666667rem;\n    color: #919799;\n    font-size: .346666666666667rem;\n}\n.live-main,.rooms,.link {\n    text-decoration: none;\n    color: #000;\n}*/\n", ""]);

// exports


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
  data() {
    return {
      //news: null,
      isLoadMore: true
    };
  },
  computed: {
    livepartitions() {
      return this.$store.state.livepartitions;
    },
    limit() {
      return this.$store.state.limit;
    }
  },
  methods: {
    test(e) {
      this.$store.state.index = e;
    },
    load() {
      this.$store.dispatch("setLive");
    },
    loadMore() {
      this.$store.state.limit = 10;
    }
  },
  mounted() {
    this.load();
    console.log(this.$http);
  }
});

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', _vm._l((_vm.livepartitions), function(n) {
    return _c('div', {
      staticClass: "room-list-container rooms"
    }, [_c('div', {
      staticClass: "title-ctnr"
    }, [_c('div', {
      staticClass: "title-row f-clear"
    }, [_c('div', {
      staticClass: "f-left"
    }, [_c('span', {
      staticClass: "live-class-icon",
      staticStyle: {
        "background-image": "url()"
      },
      slot: "topLeft"
    }, [_vm._v(_vm._s(n.partition.name))])]), _vm._v(" "), _c('div', {
      staticClass: "f-right"
    }, [_c('a', {
      staticClass: "link",
      attrs: {
        "href": "/pages/h5/area?id=9&name="
      },
      slot: "topRight"
    }, [_c('span', {
      staticClass: "right-arrow icon"
    }, [_vm._v("")])])])])]), _vm._v(" "), _c('div', {
      staticClass: "block-ctnr"
    }, _vm._l((n.lives.slice(0, _vm.limit)), function(obj, index) {
      return _c('a', {
        staticClass: "room-card",
        attrs: {
          "_v-51f62538": "",
          "href": '#/livedetali/' + obj.room_id
        },
        on: {
          "click": function($event) {
            _vm.test(obj)
          }
        }
      }, [_c('div', {
        staticClass: " cover-wrap",
        attrs: {
          "_v-51f62538": ""
        }
      }, [_c('div', {
        staticClass: "cover",
        staticStyle: {
          "opacity": "1"
        },
        attrs: {
          "_v-51f62538": ""
        }
      }, [_c('img', {
        attrs: {
          "_v-51f62538": "",
          "src": "https://i0.hdslb.com/bfs/live/ff3c33bbbfe4a1c905519c300112138c1468bcf0.jpg"
        }
      }), _c('span', {
        staticClass: "hostname",
        attrs: {
          "_v-51f62538": ""
        }
      }, [_vm._v(_vm._s(obj.owner.name))]), _c('span', {
        staticClass: "viewers-count eye icon",
        attrs: {
          "_v-51f62538": ""
        }
      }, [_vm._v(_vm._s(obj.online))])])]), _vm._v(" "), _c('div', {
        staticClass: "title-container",
        attrs: {
          "_v-51f62538": ""
        }
      }, [_c('span', {
        staticClass: "title",
        attrs: {
          "_v-51f62538": ""
        }
      }, [_vm._v(_vm._s(obj.title))])])])
    }))])
  }))
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-7f6246d9", module.exports)
  }
}

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('liveheader'), _vm._v(" "), _c('liveswipe'), _vm._v(" "), _c('livelist')], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-7ba87df1", module.exports)
  }
}

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(74),
  /* template */
  __webpack_require__(80),
  /* styles */
  null,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "D:\\newtest\\6.20\\bilibili-live\\app\\components\\routes\\livedetali.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] livedetali.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0433453d", Component.options)
  } else {
    hotAPI.reload("data-v-0433453d", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__liveheader_vue__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__liveheader_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__liveheader_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__livevideo_vue__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__livevideo_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__livevideo_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__liveliuyan_vue__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__liveliuyan_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__liveliuyan_vue__);
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
	components: {
		liveheader: __WEBPACK_IMPORTED_MODULE_0__liveheader_vue___default.a,
		livevideo: __WEBPACK_IMPORTED_MODULE_1__livevideo_vue___default.a,
		liveliuyan: __WEBPACK_IMPORTED_MODULE_2__liveliuyan_vue___default.a
	}
});

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var Component = __webpack_require__(1)(
  /* script */
  __webpack_require__(76),
  /* template */
  __webpack_require__(77),
  /* styles */
  null,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "D:\\newtest\\6.20\\bilibili-live\\app\\components\\livevideo.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] livevideo.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-07f00350", Component.options)
  } else {
    hotAPI.reload("data-v-07f00350", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ __webpack_exports__["default"] = ({
	data() {
		return {
			//news: null,
			isLoadMore: true
		};
	},
	computed: {
		index() {
			return this.$store.state.index;
		}
	},
	methods: {
		load() {
			this.$store.dispatch("setLive");
		},
		vvv() {
			this.$store.state.index = "eeeee";
		}

	},
	mounted() {
		this.load();
		// console.log(this.$store.state.index,"")
		if (flv.isSupported()) {
			var videoElement = document.getElementById('videoElement');
			var flvPlayer = flv.createPlayer({
				type: 'flv',
				url: this.$store.state.index.playurl
			});
			flvPlayer.attachMediaElement(videoElement);
			flvPlayer.load();
			flvPlayer.play();
		}
	}
});

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _vm._m(0)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('video', {
    staticStyle: {
      "width": "100%"
    },
    attrs: {
      "id": "videoElement",
      "controls": "",
      "autoplay": "autoplay"
    }
  })])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-07f00350", module.exports)
  }
}

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var Component = __webpack_require__(1)(
  /* script */
  null,
  /* template */
  __webpack_require__(79),
  /* styles */
  null,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "D:\\newtest\\6.20\\bilibili-live\\app\\components\\liveliuyan.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] liveliuyan.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5ea3ea49", Component.options)
  } else {
    hotAPI.reload("data-v-5ea3ea49", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c("div")
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-5ea3ea49", module.exports)
  }
}

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('liveheader'), _vm._v(" "), _c('livevideo'), _vm._v(" "), _c('liveliuyan')], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-0433453d", module.exports)
  }
}

/***/ })
/******/ ]);